---
title: é«˜æ¥¼æ‰”é¸¡è›‹é—®é¢˜
date: 2020-09-14 14:43:05
categories: ç®—æ³•
tags: 
	- æ¡†æ¶
---
[887.é¸¡è›‹æ‰è½](https://leetcode.com/problems/super-egg-drop/)

```
// å½“å‰çŠ¶æ€ä¸º (K ä¸ªé¸¡è›‹ï¼ŒN å±‚æ¥¼)
// è¿”å›è¿™ä¸ªçŠ¶æ€ä¸‹çš„æœ€ä¼˜ç»“æœ
int dp(K, N):
    int res
    for 1 <= i <= N:
        res = min(res, è¿™æ¬¡åœ¨ç¬¬ i å±‚æ¥¼æ‰”é¸¡è›‹)
    return res
    
base case:
    if K == 1: return N
    if N == 0: return 0    
```

å¦‚æœé¸¡è›‹ç¢äº†ï¼Œé‚£ä¹ˆé¸¡è›‹çš„ä¸ªæ•°Kåº”è¯¥å‡ä¸€ï¼Œæœç´¢çš„æ¥¼å±‚åŒºé—´åº”è¯¥ä»[1..N]å˜ä¸º[1..i-1]å…±i-1å±‚æ¥¼

å¦‚æœé¸¡è›‹æ²¡ç¢ï¼Œé‚£ä¹ˆé¸¡è›‹çš„ä¸ªæ•°Kä¸å˜ï¼Œæœç´¢çš„æ¥¼å±‚åŒºé—´åº”è¯¥ä» [1..N]å˜ä¸º[i+1..N]å…±N-iå±‚æ¥¼

æœ€åæƒ…å†µä¸‹æ‰”é¸¡è›‹çš„æ¬¡æ•°ï¼Œæ‰€ä»¥é¸¡è›‹åœ¨ç¬¬iå±‚æ¥¼ç¢æ²¡ç¢ï¼Œå–å†³äºå“ªç§æƒ…å†µçš„ç»“æœæ›´å¤§

ğŸ”½ğŸ”½ğŸ”½

```
Map<String, Integer> map = new HashMap<>();
int dp(int K, int N) {
        int res = Integer.MAX_VALUE;
        if (K == 1) return N;
        if (N == 0) return 0;
        if (map.containsKey(K + "*" + N)) {
            return map.get(K + "*" + N);
        }
        for (int i = 1; i < N + 1; i++) {
            // æœ€åæƒ…å†µä¸‹çš„æœ€å°‘æ‰”é¸¡è›‹æ¬¡æ•°
            res = Math.min(res,
                    //æœ€åæƒ…å†µä¸‹
                    Math.max(dp(K, N - i), // æ²¡ç¢
                            dp(K - 1, i - 1)) //ç¢
                            + 1 //åœ¨ç¬¬ i æ¥¼æ‰”äº†ä¸€æ¬¡
            );
        }
        map.put(K + "*" + N, res);
        return res;
    }
```

ç»“æœè¶…æ—¶äº†ï¼Œå¯ä»¥å°†forå¾ªç¯æ”¹æˆäºŒåˆ†æœç´¢

```
Map<String, Integer> map = new HashMap<>();
public int dp2(int K, int N) {
        if (!map.containsKey(K+"*"+N)) {
            int ans;
            if (N == 0)
                ans = 0;
            else if (K == 1)
                ans = N;
            else {
                int lo = 1, hi = N;
                while (lo + 1 < hi) {
                    int x = (lo + hi) / 2;
                    int t1 = dp(K - 1, x - 1);
                    int t2 = dp(K, N - x);

                    if (t1 < t2)
                        lo = x;
                    else if (t1 > t2)
                        hi = x;
                    else
                        lo = hi = x;
                }

                ans = 1 + Math.min(Math.max(dp(K - 1, lo - 1), dp(K, N - lo)),
                        Math.max(dp(K - 1, hi - 1), dp(K, N - hi)));
            }

            map.put(K+"*"+N, ans);
        }

        return map.get(K+"*"+N);
    }
```