<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring Security 身份认证流程</title>
    <url>/2021/06/07/Spring-Security-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote>
<p>Spring Security 就像一个行政服务中心，如果我们去里面办事，可以办啥事呢？可以小到咨询简单问题、查询社保信息，也可以户籍登记、补办身份证，同样也可以大到企业事项、各种复杂的资质办理。但是我们并不需要跑一次行政服务中心，就挨个把业务全部办理一遍，现实中没有这样的人吧。</p>
</blockquote>
<p>总结一下，啥意思呢，就是说选择你需要的服务（功能），无视那些不需要的，等有需要的时候再了解不迟。这也是给众多工程师们的一个建议，特别是体系异常庞大的Java系，别动不动就精通，撸遍源码之类的，真没啥意义，我大脑的存储比较小，人生苦短，没必要。</p>
<a id="more"></a>
<h3 id="关于身份认证"><a href="#关于身份认证" class="headerlink" title="关于身份认证"></a>关于身份认证</h3><p>Web 身份认证是一个后端工程师永远无法避开的领域，身份认证Authentication，和授权Authorization是不同的，Authentication指的是用户身份的认证，并不介入这个用户能够做什么，不能够做什么，仅仅是确认存在这个用户而已。而Authorization授权是建立的认证的基础上的，存在这个用户了，再来约定这个用户能补能够做一件事，这点大家要区分开。本文讲的是Authentication的故事，并不会关注权限。</p>
<p>热热身，来温习一下身份认证的方式演变：</p>
<ul>
<li><p>先是最著名的入门留言板程序，相信很多做后端的工程师都做过留言板，那是一个基本没有框架的阶段，回想一下是怎么认证的。表单输入用户名密码Submit，然后后端取到数据数据库查询，查不到的话无情地抛出一个异常，哦，密码错了；查到了，愉快的将用户ID和相关信息加密写入到Session标识中存起来，响应写入Cookie，后续的请求都解密后验证就行了，对吧。是的，身认证真可以简单到仅仅是匹配Session标识而已。令人沮丧的是现代互联网的发展早已经过了 Web2.0 的时代，客户端的出现让身份认证更加复杂。我们继续</p>
</li>
<li><p>随着移动端的崛起，Android和ios占据主导，同样是用户登录认证，取到用户信息，正准备按图索骥写入Session回写Cookie的时候，等等！啥？Android不支持Cookie？这听起来不科学是吧，有点反人类是吧，有点手足无措是吧。</p>
<p>嘿嘿，聪明的人儿也许想到了办法，嗯，Android客户端不是有本地存储吗？把回传的数据存起来不就行了吗？又要抱歉了，Android本地存储并没有浏览器Cookie那么人性化，不会自动过期。没事，再注明过期时间，每次读取的时候判断就行啦，貌似可以了。</p>
<p>等等。客户端的Api接口要求轻量级，某一天一个队友想实现个性化的事情，竟然往Cookie了回传了一串字符串，貌似很方便，嗯。于是其他队友也效仿，然后Cookie变得更加复杂。此时Android队友一声吼，你们够了！STOP！我只要一个认证标识而已，够简单你们知道吗？还有Cookie过期了就要重新登陆，用户体验极差，产品经理都找我谈了几十次了，用户都快跑光了，你们还在往Cookie里加一些奇怪的东西。</p>
</li>
<li><p>Oauth 2.0来了</p>
</li>
</ul>
<p>有问题总要想办法解决是吧。客户端不是浏览器，有自己特有的交互约定，Cookie还是放弃掉了。这里就要解决五个问题：</p>
<ul>
<li>[ ] 只需要简单的一个字符串标识，不需要遵守Cookie的规则</li>
<li>[ ] 服务器端需要能够轻松认证这个标识，最好是做成标准化</li>
<li>[ ] 不要让用户反复输入密码登录，能够自动刷新</li>
<li>[ ] 这段秘钥要安全，从网络传输链路层到客户端本地层都要是安全的，就算被中途捕获，也可以让其失效</li>
<li>[ ] 多个子系统的客户端需要独立的认证标识，让他们能够独立存在（例如淘宝的认证状态不会影响到阿里旺旺的登录认证状态）</li>
</ul>
<p>需求一旦确定，方案呼之欲出，让我们来简单构思一下。</p>
<ul>
<li>[x] 首先是标识，这个最简单了，将用户标识数据进行可逆加密，OK，这个搞定。</li>
<li>[x] 然后是标识认证的标准化，最好轻量级，并且让她不干扰请求的表现方式，例如Get和Post数据，聪明的你想到了吧，没错，就是Header，我们暂且就统一成 <code>Userkey</code> 为Header名，值就是那个加密过的标识，够简洁粗暴吧，后端对每一个请求都拦截处理，如果能够解密成功并且表示有效，就告诉后边排队的小伙伴，这个家伙是自己人，叫xxx，兜里有100块钱。这个也搞定了。</li>
<li>[x] 自动刷新，因为加密标识每次请求都要传输，不能放在一起了，而且他们的作用也不一样，那就颁发加密标识的时候顺便再颁发一个刷新的秘钥吧，相当于入职的时候给你一张门禁卡，这个卡需要随身携带，开门签到少不了它，此外还有一张身份证明，这证明就不需要随身携带了，放家里都行，门禁卡掉了，没关系，拿着证明到保安大哥那里再领一张门禁卡，证明一次有效，领的时候保安大哥贴心的再给你一张证明。</li>
<li>[x] 安全问题，加密可以加强一部分安全性。传输链路还用说吗？上Https传输加密哟。至于客户端本地的安全是一个哲学问题，嗯嗯嗯。哈哈。我们暂时认为本地私有空间存储是安全的的，俗话说得好，计算机都被人破解了，还谈个鸡毛安全呀（所以大家没事还是不要去ROOT手机了，ROOT之后私有存储可以被访问侬造吗）</li>
<li>[x] 子系统独立问题，这个好办了。身份认证过程再加入一个因子，暂且叫 Client 吧。这样标识就互不影响了。</li>
</ul>
<p>打完收工，要开始实现这套系统了。先别急呀，难道没觉得似曾相识吗？没错就是 Oauth 2.0 的 password Grant 模式！</p>
<p><img src="/img/springsecurity.png"></p>
<p>这里做了一个简化，</p>
<p>根据JavaEE的流程，本质就是Filter过滤请求，转发到不同处理模块处理，最后经过业务逻辑处理，返回Response的过程。</p>
<p>当请求匹配了我们定义的Security Filter的时候，就会导向Security 模块进行处理，例如UsernamePasswordAuthenticationFilter，源码献上:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationFilter</span> <span class="title">extends</span> <span class="title">AbstractAuthenticationProcessingFilter</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SPRING_SECURITY_FORM_USERNAME_KEY = <span class="string">"username"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SPRING_SECURITY_FORM_PASSWORD_KEY = <span class="string">"password"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> usernameParameter = <span class="string">"username"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> passwordParameter = <span class="string">"password"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> postOnly = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        super(<span class="keyword">new</span> AntPathRequestMatcher(<span class="string">"/login"</span>, <span class="string">"POST"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> throws AuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">String</span> username = <span class="keyword">this</span>.obtainUsername(request);</span><br><span class="line">            <span class="keyword">String</span> password = <span class="keyword">this</span>.obtainPassword(request);</span><br><span class="line">            <span class="keyword">if</span> (username == null) &#123;</span><br><span class="line">                username = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (password == null) &#123;</span><br><span class="line">                password = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            username = username.trim();</span><br><span class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(username, password);</span><br><span class="line">            <span class="keyword">this</span>.setDetails(request, authRequest);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">String</span> <span class="title">obtainPassword</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameter(<span class="keyword">this</span>.passwordParameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">String</span> <span class="title">obtainUsername</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> request.getParameter(<span class="keyword">this</span>.usernameParameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setDetails</span><span class="params">(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest)</span> </span>&#123;</span><br><span class="line">        authRequest.setDetails(<span class="keyword">this</span>.authenticationDetailsSource.buildDetails(request));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsernameParameter</span><span class="params">(<span class="keyword">String</span> usernameParameter)</span> </span>&#123;</span><br><span class="line">        Assert.hasText(usernameParameter, <span class="string">"Username parameter must not be empty or null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.usernameParameter = usernameParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPasswordParameter</span><span class="params">(<span class="keyword">String</span> passwordParameter)</span> </span>&#123;</span><br><span class="line">        Assert.hasText(passwordParameter, <span class="string">"Password parameter must not be empty or null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.passwordParameter = passwordParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPostOnly</span><span class="params">(<span class="keyword">boolean</span> postOnly)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.postOnly = postOnly;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> <span class="title">getUsernameParameter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.usernameParameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> <span class="title">getPasswordParameter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.passwordParameter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有点复杂是吧，不用担心，我来做一些伪代码，让他看起来更友善，更好理解。注意我写的单行注释</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationFilter</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">AbstractAuthenticationProcessingFilter</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">String</span> SPRING_SECURITY_FORM_USERNAME_KEY = <span class="string">"username"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">String</span> SPRING_SECURITY_FORM_PASSWORD_KEY = <span class="string">"password"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> usernameParameter = <span class="string">"username"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> passwordParameter = <span class="string">"password"</span>;</span><br><span class="line">    <span class="keyword">private</span> boolean postOnly = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UsernamePasswordAuthenticationFilter() &#123;</span><br><span class="line">        <span class="comment">//1.匹配URL和Method</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> <span class="type">AntPathRequestMatcher</span>(<span class="string">"/login"</span>, <span class="string">"POST"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">            <span class="comment">//啥？你没有用POST方法，给你一个异常，自己反思去</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AuthenticationServiceException</span>(<span class="string">"Authentication method not supported: "</span> + request.getMethod());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从请求中获取参数</span></span><br><span class="line">            <span class="keyword">String</span> username = <span class="built_in">this</span>.obtainUsername(request);</span><br><span class="line">            <span class="keyword">String</span> password = <span class="built_in">this</span>.obtainPassword(request);</span><br><span class="line">            <span class="comment">//我不知道用户名密码是不是对的，所以构造一个未认证的Token先</span></span><br><span class="line">            UsernamePasswordAuthenticationToken token = <span class="keyword">new</span> <span class="type">UsernamePasswordAuthenticationToken</span>(username, password);</span><br><span class="line">            <span class="comment">//顺便把请求和Token存起来</span></span><br><span class="line">            <span class="built_in">this</span>.setDetails(request, token);</span><br><span class="line">            <span class="comment">//Token给谁处理呢？当然是给当前的AuthenticationManager喽</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是很清晰，问题又来了，Token是什么鬼？为啥还有已认证和未认证的区别？别着急，咱们顺藤摸瓜，来看看Token长啥样。上UsernamePasswordAuthenticationToken:</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationToken</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationToken</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">510</span>L;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object principal;</span><br><span class="line">    <span class="keyword">private</span> Object credentials;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Collection)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.principal = principal;</span><br><span class="line">        <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">        <span class="keyword">this</span>.setAuthenticated(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials, Collection&lt;? <span class="keyword">extends</span> GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(authorities);</span><br><span class="line">        <span class="keyword">this</span>.principal = principal;</span><br><span class="line">        <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">        <span class="keyword">super</span>.setAuthenticated(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.credentials;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.principal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isAuthenticated) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.setAuthenticated(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">eraseCredentials</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eraseCredentials();</span><br><span class="line">        <span class="keyword">this</span>.credentials = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一坨坨的真闹心，我再备注一下：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordAuthenticationToken</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationToken</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">510</span>L;</span><br><span class="line">    <span class="comment">//随便怎么理解吧，暂且理解为认证标识吧，没看到是一个Object么</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object principal;</span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    <span class="keyword">private</span> Object credentials;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个构造方法用来初始化一个没有认证的Token实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Collection)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.principal = principal;</span><br><span class="line">        <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">        <span class="keyword">this</span>.setAuthenticated(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//这个构造方法用来初始化一个已经认证的Token实例，为啥要多此一举，不能直接Set状态么，不着急，往后看</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UsernamePasswordAuthenticationToken</span><span class="params">(Object principal, Object credentials, Collection&lt;? <span class="keyword">extends</span> GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(authorities);</span><br><span class="line">        <span class="keyword">this</span>.principal = principal;</span><br><span class="line">        <span class="keyword">this</span>.credentials = credentials;</span><br><span class="line">        <span class="keyword">super</span>.setAuthenticated(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//便于理解无视他</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">getCredentials</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.credentials;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//便于理解无视他</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">getPrincipal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.principal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setAuthenticated</span><span class="params">(<span class="keyword">boolean</span> isAuthenticated)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isAuthenticated) &#123;</span><br><span class="line">            <span class="comment">//如果是Set认证状态，就无情的给一个异常，意思是：</span></span><br><span class="line">            <span class="comment">//不要在这里设置已认证，不要在这里设置已认证，不要在这里设置已认证</span></span><br><span class="line">            <span class="comment">//应该从构造方法里创建，别忘了要带上用户信息和权限列表哦</span></span><br><span class="line">            <span class="comment">//原来如此，是避免犯错吧</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.setAuthenticated(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">eraseCredentials</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.eraseCredentials();</span><br><span class="line">        <span class="keyword">this</span>.credentials = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞清楚了Token是什么鬼，其实只是一个载体而已啦。接下来进入核心环节，AuthenticationManager是怎么处理的。这里我简单的过渡一下，但是会让你明白。</p>
<p>AuthenticationManager会注册多种AuthenticationProvider，例如UsernamePassword对应的DaoAuthenticationProvider，既然有多种选择，那怎么确定使用哪个Provider呢？我截取了一段源码，大家一看便知：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>AuthenticationProvider &#123;</span><br><span class="line">    Authentication authenticate(Authentication var1) throws AuthenticationException;</span><br><span class="line"></span><br><span class="line">    boolean supports(Class&lt;?&gt; var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个接口，我喜欢接口，简洁明了。里面有一个supports方法，返回时一个boolean值，参数是一个Class，没错，这里就是根据Token的类来确定用什么Provider来处理，大家还记得前面的那段代码吗？</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Token给谁处理呢？当然是给当前的AuthenticationManager喽</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(token);</span><br></pre></td></tr></table></figure>
<p>因此我们进入下一步，DaoAuthenticationProvider，继承了AbstractUserDetailsAuthenticationProvider，恭喜您再坚持一会就到曙光啦。这个比较复杂，为了不让你跑掉，我将两个复杂的类合并，摘取直接触达接口核心的逻辑，直接上代码，会有所删减，让你看得更清楚，注意看注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoAuthenticationProvider</span> <span class="keyword">extends</span> <span class="title">AbstractUserDetailsAuthenticationProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">//熟悉的supports，需要UsernamePasswordAuthenticationToken</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UsernamePasswordAuthenticationToken<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">authentication</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        	<span class="comment">//取出Token里保存的值</span></span><br><span class="line">            String username = authentication.getPrincipal() == <span class="keyword">null</span> ? <span class="string">"NONE_PROVIDED"</span> : authentication.getName();</span><br><span class="line">            <span class="keyword">boolean</span> cacheWasUsed = <span class="keyword">true</span>;</span><br><span class="line">        	<span class="comment">//从缓存取</span></span><br><span class="line">            UserDetails user = <span class="keyword">this</span>.userCache.getUserFromCache(username);</span><br><span class="line">            <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cacheWasUsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//啥，没缓存？使用retrieveUser方法获取呀</span></span><br><span class="line">                user = <span class="keyword">this</span>.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...删减了一大部分，这样更简洁</span></span><br><span class="line">            Object principalToReturn = user;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.forcePrincipalAsString) &#123;</span><br><span class="line">                principalToReturn = user.getUsername();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//熟悉的loadUserByUsername</span></span><br><span class="line">            UserDetails loadedUser = <span class="keyword">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">            <span class="keyword">if</span> (loadedUser == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(<span class="string">"UserDetailsService returned null, which is an interface contract violation"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> loadedUser;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UsernameNotFoundException var4) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mitigateAgainstTimingAttack(authentication);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InternalAuthenticationServiceException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalAuthenticationServiceException(var6.getMessage(), var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//检验密码</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (authentication.getCredentials() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Authentication failed: no credentials provided"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="keyword">this</span>.messages.getMessage(<span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>, <span class="string">"Bad credentials"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String presentedPassword = authentication.getCredentials().toString();</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Authentication failed: password does not match stored value"</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BadCredentialsException(<span class="keyword">this</span>.messages.getMessage(<span class="string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>, <span class="string">"Bad credentials"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，就完成了用户名密码的认证校验逻辑，根据认证用户的信息，系统做相应的Session持久化和Cookie回写操作。</p>
<p>Spring Security的基本认证流程先写到这里，其实复杂的背后是一些预定，熟悉了之后就不难了。</p>
<blockquote>
<p>Filter-&gt;构造Token-&gt;AuthenticationManager-&gt;转给Provider处理-&gt;认证处理成功后续操作或者不通过抛异常</p>
</blockquote>
<p>有了这些基础，后面我们再来扩展短信验证码登录，以及基于Oauth 2.0 的短信验证码登录。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Github自定义Overview</title>
    <url>/2021/04/29/Github%E8%87%AA%E5%AE%9A%E4%B9%89Overview/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>最近逛别人的Github发现别人的Overview很炫酷，然后发现Github允许在个人主页 Your profile 中的 Overview 页面定义自己的内容，来突出用户的个人风格。</p>
<p>在用户名同名库的READ.ME中所填入的所有信息都会被及时渲染到 GitHub 首页，支持常规的 Markdown 语法。效果如下：</p>
<p><img src="/img/githubOverview.png"></p>
<a id="more"></a>
<p><br></p>
<p>自定义个人主页之后你会发现除了项目的展示，还有个人的其他信息介绍，下面让说下如何设置吧。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><h5 id="1-在你的-github-上创建一个新仓库"><a href="#1-在你的-github-上创建一个新仓库" class="headerlink" title="1.在你的 github 上创建一个新仓库"></a>1.在你的 github 上创建一个新仓库</h5><p>这个新仓库的名称要和你登录账号名称保持一致，注意将仓库仓库设置为 Public</p>
<h5 id="2-将远程仓库拉到本地电脑上"><a href="#2-将远程仓库拉到本地电脑上" class="headerlink" title="2.将远程仓库拉到本地电脑上"></a>2.将远程仓库拉到本地电脑上</h5><p>用git clone 一下仓库并且创建 README.md 文件，执行以下命令</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@github.com:你用户名/你用户名.git</span><br></pre></td></tr></table></figure>
<h5 id="3-在本地文件创建-README-md-文件"><a href="#3-在本地文件创建-README-md-文件" class="headerlink" title="3.在本地文件创建 README.md 文件"></a>3.在本地文件创建 README.md 文件</h5><p>完成上面几步之后，我们就可以开始推送到你的远程仓库，<strong>按照上面的步骤做完之后就可以查看属于你风格的个人主页了。</strong></p>
<p><br></p>
<p><strong>PS:可以在第一步时，选择初始化一个 README 文件，创建好后，页面会自动跳转到仓库主页，点击右上角的 <code>Edit README</code> 开始制作。</strong></p>
<p><br></p>
<h4 id="定制："><a href="#定制：" class="headerlink" title="定制："></a><strong>定制：</strong></h4><p><strong>1.My Github Stats</strong></p>
<p>这个其实就是一个url，替换一下username就行，如下所示：</p>
<blockquote>
<p><a href="https://github-readme-stats.anuraghazra1.vercel.app/api?username=username&amp;show_icons=true" target="_blank" rel="noopener">https://github-readme-stats.anuraghazra1.vercel.app/api?username=username&amp;show_icons=true</a></p>
<p><a href="https://github-readme-stats.vercel.app/api/top-langs/?username=username&amp;layout=compact" target="_blank" rel="noopener">https://github-readme-stats.vercel.app/api/top-langs/?username=username&amp;layout=compact</a></p>
</blockquote>
<p><strong>2.使用徽标</strong></p>
<p>使用徽标可以使得主页更加吸引眼球，可以在 <strong><a href="http://shield.io" target="_blank" rel="noopener">http://shield.io</a></strong> 搜索找到你想要的图标。</p>
<p><strong>3.waka</strong></p>
<p>这个是通过GitHub Action，解锁更多玩法，waka就是一款统计工具，可以嵌入各种开发工具中，方法如下：</p>
<ul>
<li><p>首先打开<a href="https://wakatime.com/" target="_blank" rel="noopener"><strong>WakaTime</strong></a> 网站，使用 GitHub 登录，在首页会生成一个密钥。然后将这个密钥储存到当前仓库的 <code>Settings/Secrets</code> 里面，我这里命名为 WAKATIME_API_KEY。</p>
</li>
<li><p>Settings/Developer settings/Personal access tokens中新建一个token，给<strong>repo, user</strong>权限即可，然后将这个密钥储存到当前仓库的 <code>Settings/Secrets</code> 里面，我这里命名为 GH_TOKEN</p>
</li>
<li><p>然后新建一个 Action，粘贴下面的代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="attribute">name</span>: Waka Readme</span><br><span class="line"></span><br><span class="line"><span class="attribute">on:</span></span><br><span class="line">  workflow_dispatch:</span><br><span class="line">  schedule:</span><br><span class="line">    # Runs at 12am UTC</span><br><span class="line">    - cron: "0 0 * * *"</span><br><span class="line"></span><br><span class="line"><span class="attribute">jobs:</span></span><br><span class="line">  update-readme:</span><br><span class="line">    name: Update this repo's README</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line"> 		# 这里我是fork到自己仓库里了，方便自定义</span><br><span class="line"> 		# 也可以用anmol098/waka-readme-stats@master</span><br><span class="line">      - uses: justdoitlee/waka-readme-stats@master</span><br><span class="line">        with:</span><br><span class="line">          WAKATIME_API_KEY: $&#123;&#123; secrets.WAKATIME_API_KEY &#125;&#125;</span><br><span class="line">          GH_TOKEN: $&#123;&#123; secrets.GH_TOKEN &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建好后，GitHub 会根据 <code>cron</code> 配置的定时任务，定时运行上面的 Action，更新 README。</p>
<p>密钥配置如图所示：</p>
<p><img src="/img/githubSecrets.png"></p>
<p><img src="/img/githubToken.png"></p>
<p>具体操作及效果如下：<a href="https://github.com/anmol098/waka-readme-stats" target="_blank" rel="noopener"><strong>waka-readme-stats</strong></a></p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Iterm2使用agnosterzak打造个性终端</title>
    <url>/2021/04/22/Iterm2%E4%BD%BF%E7%94%A8agnosterzak%E6%89%93%E9%80%A0%E4%B8%AA%E6%80%A7%E7%BB%88%E7%AB%AF/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>关机之后打开电脑，突然电脑配置全部恢复默认，Iterm2样式跟着失效了，然后重新打造一下，方便下次快速恢复终端样式。</p>
<p>效果如下：</p>
<p><img src="/img/iterm2css.png"></p>
<a id="more"></a>
<p>准备工作：</p>
<blockquote>
<p>macOS 和 <a href="https://www.whatled.com/post-tag/iterm" target="_blank" rel="noopener">iTerm</a>2 软件</p>
</blockquote>
<h3 id="iTerm-操作"><a href="#iTerm-操作" class="headerlink" title="iTerm 操作"></a>iTerm 操作</h3><p>下载 <a href="https://www.whatled.com/post-tag/iterm" target="_blank" rel="noopener">iTerm</a> 软件 ： <a href="http://iterm2.com/" target="_blank" rel="noopener">http://iterm2.com/</a> 直接下载安装即可;</p>
<h4 id="iTerm-主题"><a href="#iTerm-主题" class="headerlink" title="iTerm 主题"></a>iTerm 主题</h4><h5 id="1-1-下载主题"><a href="#1-1-下载主题" class="headerlink" title="1.1 下载主题"></a>1.1 下载主题</h5><p>下载地址 ： <a href="http://iterm2colorschemes.com/" target="_blank" rel="noopener">http://iterm2colorschemes.com/</a></p>
<p>直接下载 <code>zip</code> 即可，后解压（主要使用 termite 文件下的主题）</p>
<h5 id="1-2-配置主题"><a href="#1-2-配置主题" class="headerlink" title="1.2 配置主题"></a>1.2 配置主题</h5><p>打开 <a href="https://www.whatled.com/post-tag/iterm" target="_blank" rel="noopener">iTerm</a>2 配置 :</p>
<blockquote>
<p><a href="https://www.whatled.com/post-tag/iterm" target="_blank" rel="noopener">iTerm</a>2 / Preferences / Profiles</p>
</blockquote>
<p>新建 <code>Profile</code> ， 在 <code>Other Actions</code> 下 <code>Set as Default</code> , 这样重新打开 <code>iTerm2</code> 就是你的配置文件了，当然也可以直接修改默认的 <code>Profile</code></p>
<p>点击Other Actions将当前的Profile设置为默认。</p>
<p><strong>加载主题</strong></p>
<p>选择你要修改的<code>Profile</code></p>
<blockquote>
<p>Profile / Colors / Color Presets / import…</p>
</blockquote>
<p>点击右下角的 <code>Color Presets</code> 下，<code>Import</code> 上面我们下载的 <code>iTerm2</code> 主题</p>
<blockquote>
<p>注意: 主要是 termite 文件下的主题，可以全选加入</p>
</blockquote>
<p><img src="/img/iterm2color.png"></p>
<h3 id="Oh-my-ZSH"><a href="#Oh-my-ZSH" class="headerlink" title="Oh my ZSH"></a>Oh my ZSH</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><p>官网： <a href="http://ohmyz.sh/" target="_blank" rel="noopener">http://ohmyz.sh/</a></p>
<p>可以看见两种安装方式：</p>
<p><strong>curl</strong></p>
<p><code>$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></p>
<p><strong>wget</strong></p>
<p><code>$ sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</code></p>
<h4 id="2-配置-Theme"><a href="#2-配置-Theme" class="headerlink" title="2. 配置 Theme"></a>2. 配置 Theme</h4><p>访问本地自带的主题：</p>
<p><code>cd ~/.oh-my-zsh/themes</code></p>
<p>里面有142个自带主题，这些主题在 zsh – theme , 可以查看；</p>
<h5 id="2-1-配置默认主题"><a href="#2-1-配置默认主题" class="headerlink" title="2.1 配置默认主题"></a>2.1 配置默认主题</h5><p>打开 <a href="https://www.whatled.com/post-tag/oh-my-zsh" target="_blank" rel="noopener">Oh my ZSH</a> 配置文件</p>
<p><code>vim ~/.zshrc</code></p>
<p>找到 <code>ZSH_THEME</code> 行 修改为默认主题里的任意一个就可以 比如:</p>
<p><code>ZSH_THEME=&quot;agnosterzak&quot;</code></p>
<p><strong>注意</strong></p>
<blockquote>
<p>图片所示的 agnosterzak 非默认主题,需要下载放入 theme 文件夹中</p>
</blockquote>
<p>将命令行设置为 <strong>ZSH</strong></p>
<p><code>chsh -s /bin/zsh</code></p>
<p>重启 iTerm 可以看到效果；</p>
<p>如果设置 <code>agnoster</code> 出现乱码字符是因为没有该类型字体 ： powerline fonts ，后面会说安装该字体;</p>
<h5 id="2-2-配置拓展主题"><a href="#2-2-配置拓展主题" class="headerlink" title="2.2 配置拓展主题"></a>2.2 配置拓展主题</h5><p>预览及其下载地址： External-themes</p>
<p>安装 以 AgnosterZak 为例：</p>
<p>访问：<em><a href="https://github.com/zakaziko99/agnosterzak-ohmyzsh-theme" target="_blank" rel="noopener">https://github.com/zakaziko99/agnosterzak-ohmyzsh-theme</a></em></p>
<p><code>git clone https://github.com/zakaziko99/agnosterzak-ohmyzsh-theme.git</code></p>
<p><code>cd agnosterzak-ohmyzsh-theme/</code></p>
<p>将 <code>agnosterzak.zsh-theme</code> 复制到 <code>~/.oh-my-zsh/themes</code> 里面，比如：</p>
<p><code>cp agnosterzak.zsh-theme ~/.oh-my-zsh/themes</code></p>
<blockquote>
<p>当然 <code>agnosterzak</code> 也依赖 power line 字体；</p>
</blockquote>
<h4 id="3-powerline-字体"><a href="#3-powerline-字体" class="headerlink" title="3. powerline 字体"></a>3. powerline 字体</h4><h5 id="3-1-下载"><a href="#3-1-下载" class="headerlink" title="3.1 下载"></a>3.1 下载</h5><p>访问字体地址 ： <a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">https://github.com/powerline/fonts</a></p>
<p><strong>安装</strong></p>
<p># clone</p>
<p><code>git clone https://github.com/powerline/fonts.git</code></p>
<p># install</p>
<p><code>cd fonts ./install.sh</code></p>
<p># clean-up a bit</p>
<p><code>cd ..</code></p>
<p><code>rm -rf fonts</code></p>
<h5 id="3-2-iTerm2-配置使用"><a href="#3-2-iTerm2-配置使用" class="headerlink" title="3.2 iTerm2 配置使用"></a>3.2 iTerm2 配置使用</h5><blockquote>
<p>iTerm2 / Preference / Profiles / Text – font</p>
</blockquote>
<p>选择 <code>change font</code> ， 可以修改字体和字体大小；找到一 <a href="https://www.whatled.com/post-tag/powerline" target="_blank" rel="noopener">Powerline</a> 结尾的字体就可以；</p>
<p><img src="/img/iterm2font.png"></p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>iterm2</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2020/12/10/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a></p>
<p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p>
<p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p>
<p>什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。</p>
<p>比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。</p>
<p>然而，大部分问题明显不具有贪心选择性质。比如打斗地主，对手出对三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况甚至可能会出王炸，这种情况就不能用贪心算法，而得使用动态规划解决。</p>
<h4 id="一、问题概述"><a href="#一、问题概述" class="headerlink" title="一、问题概述"></a>一、问题概述</h4><p>经典的贪心算法问题 Interval Scheduling（区间调度问题）。</p>
<p>给你很多形如 <code>[start, end]</code> 的闭区间，<strong>算出这些区间中最多有几个互不相交的区间</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intervalSchedule</span><span class="params">(<span class="keyword">int</span>[][] intvs)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子，<code>intvs = [[1,3], [2,4], [3,6]]</code>，这些区间最多有 2 个区间互不相交，即 <code>[[1,3], [3,6]]</code>，你的算法应该返回 2。注意边界相同并不算相交。</p>
<p>这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 <code>[start, end]</code> 表示开始和结束的时间，请问你今天<strong>最多能参加几个活动呢？</strong>显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。</p>
<a id="more"></a>
<h4 id="二、贪心解法"><a href="#二、贪心解法" class="headerlink" title="二、贪心解法"></a>二、贪心解法</h4><p>这个问题有许多看起来不错的贪心思路，却都不能得到正确答案。比如说：</p>
<p>也许可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得错误地错过了一些短的区间。或者每次选择可选区间中最短的那个？或者选择出现冲突最少的那个区间？这些方案都能很容易举出反例，不是正确的方案。</p>
<p>正确的思路其实很简单，可以分为以下三步：</p>
<ol>
<li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中<strong>结束最早的</strong>（end 最小）。</li>
<li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li>
<li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li>
</ol>
<p>把这个思路实现成算法的话，可以按每个区间的 <code>end</code> 数值<strong>升序排序</strong>，因为这样处理之后实现步骤 1 和步骤 2 都方便很多。</p>
<p>对于步骤 1，由于预先按照 <code>end</code> 排了序，所以选择 x 是很容易的。关键在于，如何去除与 x 相交的区间，选择下一轮循环的 x 呢？</p>
<p><strong>由于事先排了序</strong>，不难发现所有与 x 相交的区间必然会与 x 的 <code>end</code> 相交；如果一个区间不想与 x 的 <code>end</code> 相交，它的 <code>start</code> 必须要大于（或等于）x 的 <code>end</code>：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> intervalSchedule(<span class="keyword">int</span>[][] intvs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (intvs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 按 end 升序排序</span></span><br><span class="line">    Arrays.<span class="keyword">sort</span>(intvs, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> compare(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 至少有一个区间不相交</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 排序后，第一个区间就是 x</span></span><br><span class="line">    <span class="keyword">int</span> x_end = intvs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intvs) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = interval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= x_end) &#123;</span><br><span class="line">            <span class="comment">// 找到下一个选择的区间了</span></span><br><span class="line">            <span class="keyword">count</span>++;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">count</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>四键键盘</title>
    <url>/2020/10/29/%E5%9B%9B%E9%94%AE%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/4-keys-keyboard" target="_blank" rel="noopener">651.四键键盘</a></p>
<h4 id="第一种思路"><a href="#第一种思路" class="headerlink" title="第一种思路"></a>第一种思路</h4><p>这种思路会很容易理解，但是效率并不高，直接走流程：<strong>对于动态规划问题，首先要明白有哪些「状态」，有哪些「选择」</strong>。</p>
<p>具体到这个问题，对于每次敲击按键，有哪些「选择」是很明显的：4 种，就是题目中提到的四个按键，分别是 <code>A</code>、<code>C-A</code>、<code>C-C</code>、<code>C-V</code>（<code>Ctrl</code> 简写为 <code>C</code>）。</p>
<p>接下来，思考一下对于这个问题有哪些「状态」？<strong>或者换句话说，需要知道什么信息，才能将原问题分解为规模更小的子问题</strong>？</p>
<p>第一个状态是剩余的按键次数，用 <code>n</code> 表示；</p>
<p>第二个状态是当前屏幕上字符 A 的数量，用 <code>a_num</code> 表示；</p>
<p>第三个状态是剪切板中字符 A 的数量，用 <code>copy</code> 表示。</p>
<p>如此定义「状态」，就可以知道 base case：当剩余次数 <code>n</code> 为 0 时，<code>a_num</code> 就是我们想要的答案。</p>
<p>结合刚才说的 4 种「选择」，可以把这几种选择通过状态转移表示出来：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">dp</span><span class="params">(n - <span class="number">1</span>, a_num + <span class="number">1</span>, copy)</span></span>,    <span class="comment">// A</span></span><br><span class="line">解释：按下 A 键，屏幕上加一个字符</span><br><span class="line">同时消耗 <span class="number">1</span> 个操作数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dp</span><span class="params">(n - <span class="number">1</span>, a_num + copy, copy)</span></span>, <span class="comment">// C-V</span></span><br><span class="line">解释：按下 C-V 粘贴，剪切板中的字符加入屏幕</span><br><span class="line">同时消耗 <span class="number">1</span> 个操作数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dp</span><span class="params">(n - <span class="number">2</span>, a_num, a_num)</span></span>        <span class="comment">// C-A C-C</span></span><br><span class="line">解释：全选和复制必然是联合使用的，</span><br><span class="line">剪切板中 A 的数量变为屏幕上 A 的数量</span><br><span class="line">同时消耗 <span class="number">2</span> 个操作数</span><br></pre></td></tr></table></figure>
<p>这样可以看到问题的规模 <code>n</code> 在不断减小，肯定可以到达 <code>n = 0</code> 的 base case，所以这个思路是正确的：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxA(<span class="keyword">int</span> N) &#123;</span><br><span class="line">       <span class="comment">// 可以按 N 次按键，屏幕和剪切板里都还没有 A</span></span><br><span class="line">       <span class="keyword">return</span> dp(N, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对于 (n, a_num, copy) 这个状态，</span></span><br><span class="line">   <span class="comment">// 屏幕上能最终最多能有 dp(n, a_num, copy) 个 A</span></span><br><span class="line">   <span class="keyword">int</span> dp(<span class="keyword">int</span> n, <span class="keyword">int</span> a_num, <span class="keyword">int</span> <span class="keyword">copy</span>) &#123;</span><br><span class="line">       <span class="comment">// base case</span></span><br><span class="line">       <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> a_num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 几种选择全试一遍，选择最大的结果</span></span><br><span class="line">       <span class="keyword">return</span> Math.max(</span><br><span class="line">               Math.max(dp(n - <span class="number">1</span>, a_num + <span class="number">1</span>, <span class="keyword">copy</span>),    <span class="comment">// A</span></span><br><span class="line">                       dp(n - <span class="number">1</span>, a_num + <span class="keyword">copy</span>, <span class="keyword">copy</span>)), <span class="comment">// C-V</span></span><br><span class="line">               dp(n - <span class="number">2</span>, a_num, a_num)        <span class="comment">// C-A C-C</span></span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面就继续走流程，用备忘录消除一下重叠子问题：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> maxA(<span class="built_in">int</span> N) &#123;</span><br><span class="line">       <span class="comment">// 可以按 N 次按键，屏幕和剪切板里都还没有 A</span></span><br><span class="line">       <span class="keyword">return</span> dp(N, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对于 (n, a_num, copy) 这个状态，</span></span><br><span class="line">   <span class="comment">// 屏幕上能最终最多能有 dp(n, a_num, copy) 个 A</span></span><br><span class="line">   <span class="built_in">int</span> dp(<span class="built_in">int</span> n, <span class="built_in">int</span> a_num, <span class="built_in">int</span> <span class="built_in">copy</span>) &#123;</span><br><span class="line">       <span class="comment">// base case</span></span><br><span class="line">       <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> a_num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 避免计算重叠子问题</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(n + <span class="string">"*"</span> + a_num + <span class="built_in">copy</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(n + <span class="string">"*"</span> + a_num + <span class="built_in">copy</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 几种选择全试一遍，选择最大的结果</span></span><br><span class="line">       <span class="built_in">map</span>.put(n + <span class="string">"*"</span> + a_num + <span class="built_in">copy</span>, Math.<span class="built_in">max</span>(</span><br><span class="line">               Math.<span class="built_in">max</span>(dp(n - <span class="number">1</span>, a_num + <span class="number">1</span>, <span class="built_in">copy</span>),    <span class="comment">// A</span></span><br><span class="line">                       dp(n - <span class="number">1</span>, a_num + <span class="built_in">copy</span>, <span class="built_in">copy</span>)), <span class="comment">// C-V</span></span><br><span class="line">               dp(n - <span class="number">2</span>, a_num, a_num)        <span class="comment">// C-A C-C</span></span><br><span class="line">       ));</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(n + <span class="string">"*"</span> + a_num + <span class="built_in">copy</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h4><p>这种思路稍微有点复杂，但是效率高。继续走流程，「选择」还是那 4 个，但是这次只定义一个「状态」，也就是剩余的敲击次数 <code>n</code>。</p>
<p>这个算法基于这样一个事实，<strong>最优按键序列一定只有两种情况</strong>：</p>
<p>要么一直按 <code>A</code>：A,A,…A（当 N 比较小时）。</p>
<p>要么是这么一个形式：A,A,…C-A,C-C,C-V,C-V,…C-V（当 N 比较大时）。</p>
<p>因为字符数量少（N 比较小）时，<code>C-A C-C C-V</code> 这一套操作的代价相对比较高，可能不如一个个按 <code>A</code>；而当 N 比较大时，后期 <code>C-V</code> 的收获肯定很大。这种情况下整个操作序列大致是：<strong>开头连按几个</strong> <strong><code>A</code>，然后</strong> <strong><code>C-A C-C</code></strong> <strong>组合再接若干</strong> <strong><code>C-V</code>，然后再</strong> <strong><code>C-A C-C</code></strong> <strong>接着若干</strong> <strong><code>C-V</code>，循环下去</strong>。</p>
<p>换句话说，最后一次按键要么是 <code>A</code> 要么是 <code>C-V</code>。明确了这一点，可以通过这两种情况来设计算法：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 定义：dp[i] 表示 i 次操作后最多能显示多少个 A</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    dp[i] = Math.<span class="built_in">max</span>(</span><br><span class="line">            这次按 A 键，</span><br><span class="line">            这次按 C-V</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于「按 <code>A</code> 键」这种情况，就是状态 <code>i - 1</code> 的屏幕上新增了一个 A 而已，很容易得到结果：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按 A 键，就比上次多一个 A 而已</span></span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>但是，如果要按 <code>C-V</code>，还要考虑之前是在哪里 <code>C-A C-C</code> 的。</p>
<p><strong>刚才说了，最优的操作序列一定是</strong> <strong><code>C-A C-C</code></strong> <strong>接着若干</strong> <strong><code>C-V</code>，所以用一个变量</strong> <strong><code>j</code></strong> <strong>作为若干</strong> <strong><code>C-V</code></strong> <strong>的起点</strong>。那么 <code>j</code> 之前的 2 个操作就应该是 <code>C-A C-C</code> 了：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxA(<span class="keyword">int</span> N) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="comment">// 按 A 键</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 全选 &amp; 复制 dp[j-2]，连续粘贴 i - j 次</span></span><br><span class="line">            <span class="comment">// 屏幕上共 dp[j - 2] * (i - j + 1) 个 A</span></span><br><span class="line">            dp[i] = Math.max(dp[i], dp[j - <span class="number">2</span>] * (i - j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// N 次按键之后最多有几个 A？</span></span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>j</code> 变量减 2 是给 <code>C-A C-C</code> 留下操作数</p>
<p><img src="/img/4key.png"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达</title>
    <url>/2020/10/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10.正则表达式匹配</a></p>
<p>正则表达式是一个非常强力的工具，这两个通配符是最常用的，其中点号「.」可以匹配任意一个字符，星号「*」可以让之前的那个字符重复任意次数（包括 0 次）。</p>
<p>比如说模式串 <code>&quot;.a*b&quot;</code> 就可以匹配文本 <code>&quot;zaaab&quot;</code>，也可以匹配 <code>&quot;cb&quot;</code>；模式串 <code>&quot;a..b&quot;</code> 可以匹配文本 <code>&quot;amnb&quot;</code>；而模式串 <code>&quot;.*&quot;</code> 就比较牛逼了，它可以匹配任何文本。</p>
<p>题目输入两个字符串 <code>s</code> 和 <code>p</code>，<code>s</code> 代表文本，<code>p</code> 代表模式串，判断模式串 <code>p</code> 是否可以匹配文本 <code>s</code>。可以假设模式串只包含小写字母和上述两种通配符且一定合法，不会出现 <code>*a</code> 或者 <code>b**</code> 这种不合法的模式串。</p>
<p>首先<code>s</code>和<code>p</code>相互匹配的过程大致是，两个指针<code>i, j</code>分别在<code>s</code>和<code>p</code>上移动，如果最后两个指针都能移动到字符串的末尾，那么久匹配成功，反之则匹配失败。</p>
<p><strong>正则表达算法问题只需要把住一个基本点：看两个字符是否匹配，一切逻辑围绕匹配/不匹配两种情况展开即可。</strong></p>
<a id="more"></a>
<p>如果不考虑<code>*</code>通配符，面对两个待匹配字符<code>s[i]</code>和<code>p[j]</code>，我们唯一能做的就是看他俩是否匹配：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">String</span> s, <span class="keyword">String</span> p)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; p.length()) &#123;</span><br><span class="line">          <span class="comment">// 「.」通配符就是万金油</span></span><br><span class="line">          <span class="keyword">if</span> (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'.'</span>) &#123;</span><br><span class="line">              <span class="comment">// 匹配，接着匹配 s[i+1..] 和 p[j+1..]</span></span><br><span class="line">              i++; j++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 不匹配</span></span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> i == j;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>那么考虑一下，如果加入<code>*</code>通配符，局面就会稍微复杂一些，不过只要分情况来分析，也不难理解。</p>
<p><strong>当<code>p[j + 1]</code>为<code>*</code>通配符时，我们分情况讨论下</strong>：</p>
<p><strong>1、</strong>如果匹配，即<code>s[i] == p[j]</code>，那么有两种情况：</p>
<blockquote>
<p><code>p[j]</code>有可能会匹配多个字符，比如<code>s = &quot;aaa&quot;, p = &quot;a*&quot;</code>，那么<code>p[0]</code>会通过<code>*</code>匹配 3 个字符<code>&quot;a&quot;</code>。</p>
</blockquote>
<blockquote>
<p><code>p[i]</code>也有可能匹配 0 个字符，比如<code>s = &quot;aa&quot;, p = &quot;a*aa&quot;</code>，由于后面的字符可以匹配<code>s</code>，所以<code>p[0]</code>只能匹配 0 次。</p>
</blockquote>
<p><strong>2、</strong>如果不匹配，即<code>s[i] != p[j]</code>，只有一种情况：</p>
<blockquote>
<p><code>p[j]</code>只能匹配 0 次，然后看下一个字符是否能和<code>s[i]</code>匹配。比如说<code>s = &quot;aa&quot;, p = &quot;b*aa&quot;</code>，此时<code>p[0]</code>只能匹配 0 次。</p>
</blockquote>
<p>综上，可以把之前的代码针对<code>*</code>通配符进行一下改造：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.charAt(i) == p.charAt(j) <span class="params">||</span> p.charAt(j) == <span class="string">'.'</span>) &#123;</span><br><span class="line">         /<span class="regexp">/ 匹配</span></span><br><span class="line"><span class="regexp">         if (j &lt; p.length() - 1 &amp;&amp; p.charAt(j + 1) == '*') &#123;</span></span><br><span class="line"><span class="regexp">             /</span><span class="regexp">/ 有 * 通配符，可以匹配 0 次或多次</span></span><br><span class="line"><span class="regexp">         &#125; else &#123;</span></span><br><span class="line"><span class="regexp">             /</span><span class="regexp">/ 无 * 通配符，老老实实匹配 1 次</span></span><br><span class="line"><span class="regexp">             i++;</span></span><br><span class="line"><span class="regexp">             j++;</span></span><br><span class="line"><span class="regexp">         &#125;</span></span><br><span class="line"><span class="regexp">     &#125; else &#123;</span></span><br><span class="line"><span class="regexp">         /</span><span class="regexp">/ 不匹配</span></span><br><span class="line"><span class="regexp">         if (j &lt; p.length() - 1 &amp;&amp; p.charAt(j + 1) == '*') &#123;</span></span><br><span class="line"><span class="regexp">             /</span><span class="regexp">/ 有 * 通配符，只能匹配 0 次</span></span><br><span class="line"><span class="regexp">         &#125; else &#123;</span></span><br><span class="line"><span class="regexp">             /</span><span class="regexp">/ 无 * 通配符，匹配无法进行下去了</span></span><br><span class="line"><span class="regexp">             return false;</span></span><br><span class="line"><span class="regexp">         &#125;</span></span><br><span class="line"><span class="regexp">     &#125;</span></span><br></pre></td></tr></table></figure>
<p>整体的思路已经很清晰了，但现在的问题是，遇到<code>*</code>通配符时，到底应该匹配 0 次还是匹配多次？多次是几次？</p>
<p>这就是一个做「选择」的问题，要把所有可能的选择都穷举一遍才能得出结果。动态规划算法的核心就是「状态」和「选择」，<strong>「状态」无非就是<code>i</code>和<code>j</code>两个指针的位置，「选择」就是<code>p[j]</code>选择匹配几个字符</strong>。</p>
<p>根据「状态」，可以定义一个<code>dp</code>函数：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dp</span><span class="params">(<span class="keyword">String</span> s, <span class="keyword">int</span> i, <span class="keyword">String</span> p, <span class="keyword">int</span> j)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>dp</code>函数的定义如下：</p>
<p><strong>若<code>dp(s,i,p,j) = true</code>，则表示<code>s[i..]</code>可以匹配<code>p[j..]</code>；若<code>dp(s,i,p,j) = false</code>，则表示<code>s[i..]</code>无法匹配<code>p[j..]</code></strong>。</p>
<p>根据这个定义，想要的答案就是<code>i = 0,j = 0</code>时<code>dp</code>函数的结果，所以可以这样使用这个<code>dp</code>函数：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 指针 i，j 从索引 0 开始移动</span></span><br><span class="line">   <span class="keyword">return</span> dp(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>可以根据之前的代码写出<code>dp</code>函数的主要逻辑：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dp</span><span class="params">(<span class="keyword">String</span> s, <span class="keyword">int</span> i, <span class="keyword">String</span> p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'.'</span>) &#123;</span><br><span class="line">           <span class="comment">// 匹配</span></span><br><span class="line">           <span class="keyword">if</span> (j &lt; p.length() - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">               <span class="comment">// 1.1 通配符匹配 0 次或多次</span></span><br><span class="line">               <span class="keyword">return</span> dp(s, i, p, j + <span class="number">2</span>)</span><br><span class="line">                       || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 1.2 常规匹配 1 次</span></span><br><span class="line">               <span class="keyword">return</span> dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 不匹配</span></span><br><span class="line">           <span class="keyword">if</span> (j &lt; p.length() - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">               <span class="comment">// 2.1 通配符匹配 0 次</span></span><br><span class="line">               <span class="keyword">return</span> dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 2.2 无法继续匹配</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>根据<code>dp</code>函数的定义</strong>，这几种情况都很好解释：</p>
<p><strong>1.1 通配符匹配 0 次或多次</strong></p>
<p>将<code>j</code>加 2，<code>i</code>不变，含义就是直接跳过<code>p[j]</code>和之后的通配符，即通配符匹配 0 次：</p>
<p><img src="/img/zhengzebiaoda.png"></p>
<p>将<code>i</code>加 1，<code>j</code>不变，含义就是<code>p[j]</code>匹配了<code>s[i]</code>，但<code>p[j]</code>还可以继续匹配，即通配符匹配多次的情况：</p>
<p><img src="/img/zhengzebiaoda2.png"></p>
<p>两种情况只要有一种可以完成匹配即可，所以对上面两种情况求或运算。</p>
<p><strong>1.2 常规匹配 1 次</strong></p>
<p>由于这个条件分支是无<code>*</code>的常规匹配，那么如果<code>s[i] == p[j]</code>，就是<code>i</code>和<code>j</code>分别加一：</p>
<p><img src="/img/zhengzebiaoda3.png"></p>
<p><strong>2.1 通配符匹配 0 次</strong></p>
<p>类似情况 1.1，将<code>j</code>加 2，<code>i</code>不变：</p>
<p><img src="/img/zhengzebiaoda4.png"></p>
<p><strong>2.2 如果没有<code>*</code>通配符，也无法匹配，那只能说明匹配失败了</strong>：</p>
<p><img src="/img/zhengzebiaoda5.png"></p>
<p>看图理解应该很容易了，现在可以思考一下<code>dp</code>函数的 base case：</p>
<p><strong>一个 base case 是<code>j == p.length()</code>时</strong>，按照<code>dp</code>函数的定义，这意味着模式串<code>p</code>已经被匹配完了，那么应该看看文本串<code>s</code>匹配到哪里了，如果<code>s</code>也恰好被匹配完，则说明匹配成功：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">j</span> == p.<span class="built_in">length</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">i</span> == s.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>另一个 base case 是<code>i == s.length()</code>时</strong>，按照<code>dp</code>函数的定义，这种情况意味着文本串<code>s</code>已经全部被匹配了，那么是不是只要简单地检查一下<code>p</code>是否也匹配完就行了呢？</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == s.<span class="built_in">length</span>()) &#123;</span><br><span class="line">    <span class="comment">// 这样行吗？</span></span><br><span class="line">    <span class="keyword">return</span> j == p.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这是不正确的，此时并不能根据<code>j</code>是否等于<code>p.length()</code>来判断是否完成匹配，只要<code>p[j..]</code>能够匹配空串，就可以算完成匹配</strong>。比如说<code>s = &quot;a&quot;, p = &quot;ab*c*&quot;</code>，当<code>i</code>走到<code>s</code>末尾的时候，<code>j</code>并没有走到<code>p</code>的末尾，但是<code>p</code>依然可以匹配<code>s</code>。</p>
<p>所以可以总结写出如下代码：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, Boolean&gt; memo = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 计算 p[j..] 是否匹配 s[i..] */</span></span><br><span class="line"> <span class="built_in">boolean</span> dp(<span class="keyword">String</span> s, <span class="built_in">int</span> i, <span class="keyword">String</span> p, <span class="built_in">int</span> j) &#123;</span><br><span class="line">     <span class="built_in">int</span> m = s.length(), n = p.length();</span><br><span class="line">     <span class="comment">// base case</span></span><br><span class="line">     <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">         <span class="keyword">return</span> i == m;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">         <span class="keyword">if</span> ((n - j) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (; j + <span class="number">1</span> &lt; n; j += <span class="number">2</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (p.charAt(j + <span class="number">1</span>) != <span class="string">'*'</span>) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 记录状态 (i, j)，消除重叠子问题</span></span><br><span class="line">     <span class="keyword">String</span> <span class="built_in">key</span> = i + <span class="string">","</span> + j;</span><br><span class="line">     <span class="keyword">if</span> (memo.containsKey(<span class="built_in">key</span>)) &#123;</span><br><span class="line">         <span class="keyword">return</span> memo.<span class="built_in">get</span>(<span class="built_in">key</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'.'</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">             res = dp(s, i, p, j + <span class="number">2</span>)</span><br><span class="line">                     || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             res = dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">             res = dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             res = <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 将当前结果记入备忘录</span></span><br><span class="line">     memo.put(<span class="built_in">key</span>, res);</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈问题</title>
    <url>/2020/10/02/%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/stone-game" target="_blank" rel="noopener">877.石子游戏</a></p>
<p>你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。</p>
<p>石头的堆数可以是任意正整数，石头的总数也可以是任意正整数，这样就能打破先手必胜的局面了。比如有三堆石头 <code>piles = [1, 100, 3]</code>，先手不管拿 1 还是 3，能够决定胜负的 100 都会被后手拿走，后手会获胜。</p>
<p><strong>假设两人都很聪明</strong>，请你设计一个算法，返回先手和后手的最后得分（石头总数）之差。比如上面那个例子，先手能获得 4 分，后手会获得 100 分，你的算法应该返回 -96。</p>
<p>这样推广之后，这个问题算是一道 Hard 的动态规划问题了。<strong>博弈问题的难点在于，两个人要轮流进行选择，而且都贼精明，应该如何编程表示这个过程呢？</strong></p>
<p>还是强调多次的套路，首先明确 dp 数组的含义，然后和股票买卖系列问题类似，只要找到「状态」和「选择」，一切就水到渠成了。</p>
<a id="more"></a>
<h4 id="一、定义-dp-数组的含义"><a href="#一、定义-dp-数组的含义" class="headerlink" title="一、定义 dp 数组的含义"></a>一、定义 dp 数组的含义</h4><p>先看一下 dp 数组最终的样子：</p>
<p><img src="/img/boyiwenti.png"></p>
<p><strong>以下是对 dp 数组含义的解释：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">dp[<span class="string">i</span>][<span class="symbol">j</span>].fir 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数。</span><br><span class="line">dp[<span class="string">i</span>][<span class="symbol">j</span>].sec 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数。</span><br><span class="line"></span><br><span class="line">举例理解一下，假设 piles = [3, 9, 1, 2]，索引从 0 开始</span><br><span class="line">dp[<span class="string">0</span>][<span class="symbol">1</span>].fir = 9 意味着：面对石头堆 [3, 9]，先手最终能够获得 9 分。</span><br><span class="line">dp[<span class="string">1</span>][<span class="symbol">3</span>].sec = 2 意味着：面对石头堆 [9, 1, 2]，后手最终能够获得 2 分。</span><br></pre></td></tr></table></figure>
<p>求的答案是先手和后手最终分数之差，按照这个定义也就是 <code>dp[0][n-1].fir - dp[0][n-1].sec</code>，即面对整个 piles，先手的最优得分和后手的最优得分之差。</p>
<h4 id="二、状态转移方程"><a href="#二、状态转移方程" class="headerlink" title="二、状态转移方程"></a>二、状态转移方程</h4><p>写状态转移方程很简单，首先要找到所有「状态」和每个状态可以做的「选择」，然后择优。</p>
<p>根据前面对 dp 数组的定义，<strong>状态显然有三个：开始的索引 i，结束的索引 j，当前轮到的人。</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">dp[<span class="string">i</span>][<span class="symbol">j</span>][<span class="string">fir or sec</span>]</span><br><span class="line">其中：</span><br><span class="line">0 <span class="xml"><span class="tag">&lt;<span class="name">=</span> <span class="attr">i</span> &lt; <span class="attr">piles.length</span></span></span></span><br><span class="line"><span class="xml">i <span class="tag">&lt;<span class="name">=</span> <span class="attr">j</span> &lt; <span class="attr">piles.length</span></span></span></span><br></pre></td></tr></table></figure>
<p>对于这个问题的每个状态，可以做的<strong>选择有两个：选择最左边的那堆石头，或者选择最右边的那堆石头。</strong> 可以这样穷举所有状态：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">n = piles.<span class="built_in">length</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt;= <span class="built_in">i</span> &lt; n:</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> &lt;= <span class="built_in">i</span> &lt; n:</span><br><span class="line">        <span class="keyword">for</span> who in &#123;fir, <span class="built_in">sec</span>&#125;:</span><br><span class="line">            dp[<span class="built_in">i</span>][<span class="built_in">j</span>][who] = <span class="built_in">max</span>(left, right)</span><br></pre></td></tr></table></figure>
<p>上面的伪码是动态规划的一个大致的框架，股票系列问题中也有类似的伪码。这道题的难点在于，两人是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？</p>
<p>根据对 dp 数组的定义，很容易解决这个难点，<strong>写出状态转移方程：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">dp[<span class="string">i</span>][<span class="symbol">j</span>].fir = max(piles[<span class="string">i</span>] + dp[<span class="string">i+1</span>][<span class="symbol">j</span>].sec, piles[<span class="string">j</span>] + dp[<span class="string">i</span>][<span class="symbol">j-1</span>].sec)</span><br><span class="line">dp[<span class="string">i</span>][<span class="symbol">j</span>].fir = max(    选择最左边的石头堆     ,     选择最右边的石头堆     )</span><br><span class="line"><span class="section"># 解释：我作为先手，面对 piles[i...j] 时，有两种选择：</span></span><br><span class="line"><span class="section"># 要么我选择最左边的那一堆石头，然后面对 piles[i+1...j]</span></span><br><span class="line"><span class="section"># 但是此时轮到对方，相当于我变成了后手；</span></span><br><span class="line"><span class="section"># 要么我选择最右边的那一堆石头，然后面对 piles[i...j-1]</span></span><br><span class="line"><span class="section"># 但是此时轮到对方，相当于我变成了后手。</span></span><br><span class="line"></span><br><span class="line">if 先手选择左边:</span><br><span class="line"><span class="code">    dp[i][j].sec = dp[i+1][j].fir</span></span><br><span class="line">if 先手选择右边:</span><br><span class="line"><span class="code">    dp[i][j].sec = dp[i][j-1].fir</span></span><br><span class="line"><span class="section"># 解释：我作为后手，要等先手先选择，有两种情况：</span></span><br><span class="line"><span class="section"># 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]</span></span><br><span class="line"><span class="section"># 此时轮到我，我变成了先手；</span></span><br><span class="line"><span class="section"># 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]</span></span><br><span class="line"><span class="section"># 此时轮到我，我变成了先手。</span></span><br></pre></td></tr></table></figure>
<p>根据 dp 数组的定义，也可以找出 <strong>base case</strong>，也就是最简单的情况：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">dp[<span class="string">i</span>][<span class="symbol">j</span>].fir = piles[i]</span><br><span class="line">dp[<span class="string">i</span>][<span class="symbol">j</span>].sec = 0</span><br><span class="line">其中 0 <span class="xml"><span class="tag">&lt;<span class="name">=</span> <span class="attr">i</span> == <span class="string">j</span> &lt; <span class="attr">n</span></span></span></span><br><span class="line"><span class="xml"># 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]</span></span><br><span class="line"><span class="xml"># 那么显然先手的得分为 piles[i]</span></span><br><span class="line"><span class="xml"># 后手没有石头拿了，得分为 0</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/boyiwenti2.png"></p>
<p>这里需要注意一点， base case 是斜着的，而且推算 <code>dp[i][j]</code> 时需要用到 <code>dp[i+1][j]</code> 和<code>dp[i][j-1]</code>：</p>
<p><img src="/img/boyiwenti3.png"></p>
<p>所以说算法不能简单的一行一行遍历 dp 数组，<strong>而要斜着遍历数组：</strong></p>
<p><img src="/img/boyiwenti4.png"></p>
<p>说实话，斜着遍历二维数组说起来容易，还真不一定能想出来怎么实现，不信思考一下？这么巧妙的状态转移方程都列出来了，要是不会写代码实现，那真的很尴尬了。</p>
<h4 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h4><p> fir 和 sec 元组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fir;</span><br><span class="line">    <span class="keyword">int</span> sec;</span><br><span class="line">    Pair(<span class="keyword">int</span> fir, <span class="keyword">int</span> sec) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fir = fir;</span><br><span class="line">        <span class="keyword">this</span>.sec = sec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后直接把状态转移方程翻译成代码即可，可以注意一下斜着遍历数组的技巧：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回游戏最后先手和后手的得分之差 */</span></span><br><span class="line">int stoneGame(int[] piles) &#123;</span><br><span class="line">    int n = piles.length;</span><br><span class="line">    // 初始化 dp 数组</span><br><span class="line">    <span class="symbol">Pair</span>[][] dp = new <span class="symbol">Pair</span>[n][n];</span><br><span class="line">    for (int i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">        for (int j = i; j &lt; n; j++)</span><br><span class="line">            dp[i][j] = new <span class="symbol">Pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    // 填入 base case</span><br><span class="line">    for (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i].fir = piles[i];</span><br><span class="line">        dp[i][i].sec = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    // 斜着遍历数组</span><br><span class="line">    for (int l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">        for (int i = <span class="number">0</span>; i &lt;= n - l; i++) &#123;</span><br><span class="line">            int j = l + i - <span class="number">1</span>;</span><br><span class="line">            // 先手选择最左边或最右边的分数</span><br><span class="line">            int left = piles[i] + dp[i+<span class="number">1</span>][j].sec;</span><br><span class="line">            int right = piles[j] + dp[i][j<span class="number">-1</span>].sec;</span><br><span class="line">            // 套用状态转移方程</span><br><span class="line">            if (left &gt; right) &#123;</span><br><span class="line">                dp[i][j].fir = left;</span><br><span class="line">                dp[i][j].sec = dp[i+<span class="number">1</span>][j].fir;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j].fir = right;</span><br><span class="line">                dp[i][j].sec = dp[i][j<span class="number">-1</span>].fir;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="symbol">Pair</span> res = dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">    return res.fir - res.sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到计算 <code>dp[i][j]</code> 只依赖其左边和下边的元素，所以说肯定有优化空间，转换成一维 dp，想象一下把二维平面压扁，也就是投影到一维。但是，一维 dp 比较复杂，可解释性很差，大家就不必浪费这个时间去理解了。</p>
<h4 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h4><p>本文给出了解决博弈问题的动态规划解法。博弈问题的前提一般都是在两个聪明人之间进行，编程描述这种游戏的一般方法是二维 dp 数组，数组中通过元组分别表示两人的最优决策。</p>
<p>之所以这样设计，是因为先手在做出选择之后，就成了后手，后手在对方做完选择后，就变成了先手。这种角色转换使得我们可以重用之前的结果，典型的动态规划标志。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>子序列问题</title>
    <url>/2020/09/29/%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>子序列问题是常见的算法问题，而且并不好解决。</p>
<p>首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举都不容易，更别说求解相关的算法问题了。</p>
<p>而且，子序列问题很可能涉及到两个字符串，比如让你求两个字符串的<strong>最长公共子序列</strong>，如果没有一定的处理经验，真的不容易想出来。针对子序列问题的套路，<strong>其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。</strong></p>
<p>一般来说，这类问题都是让你求一个<strong>最长</strong>子序列，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，<strong>考察的是动态规划技巧，时间复杂度一般都是 O(n^2)</strong>。</p>
<p>原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着呢？</p>
<p>既然要用动态规划，那就要定义 dp 数组，找状态转移关系。我们说的两种思路模板，就是 dp 数组的定义思路。不同的问题可能需要不同的 dp 数组定义来解决。</p>
<a id="more"></a>
<p><strong>1.第一种思路模板是一个一维的 dp 数组</strong>：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int n = array.<span class="built_in">length</span>();</span><br><span class="line">int[] dp = new int[n];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">1</span>; <span class="built_in">i</span> &lt; n; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; <span class="built_in">i</span>; <span class="built_in">j</span>++) &#123;</span><br><span class="line">        dp[<span class="built_in">i</span>] = 最值(dp[<span class="built_in">i</span>], dp[<span class="built_in">j</span>] + ...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子<strong>最长递增子序列</strong>，在这个思路中 dp 数组的定义是：</p>
<p><strong>在子数组<code>array[0..i]</code>中，以<em><code>array[i]</code></em>结尾的目标子序列（最长递增子序列）的长度是<code>dp[i]</code></strong>。</p>
<p><strong>2.第二种思路模板是一个二维的 dp 数组</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">int n = arr.length();</span><br><span class="line">int[<span class="string"></span>][<span class="symbol"></span>] dp = new dp[<span class="string">n</span>][<span class="symbol">n</span>];</span><br><span class="line"></span><br><span class="line">for (int i = 0; i <span class="xml"><span class="tag">&lt; <span class="attr">n</span>; <span class="attr">i</span>++) &#123;</span></span></span><br><span class="line"><span class="xml">    for (int j = 1; j <span class="tag">&lt; <span class="attr">n</span>; <span class="attr">j</span>++) &#123;</span></span></span><br><span class="line"><span class="xml">        if (arr[i] == arr[j]) </span></span><br><span class="line"><span class="xml">            dp[i][j] = dp[i][j] + ...</span></span><br><span class="line"><span class="xml">        else</span></span><br><span class="line"><span class="xml">            dp[i][j] = 最值(...)</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列。本思路中 dp 数组含义又分为「只涉及一个字符串」和「涉及两个字符串」两种情况。</p>
<p><strong>2.1</strong> <strong>涉及两个字符串/数组时</strong>（比如最长公共子序列），dp 数组的含义如下：</p>
<p><strong>在子数组<code>arr1[0..i]</code>和子数组<code>arr2[0..j]</code>中，我们要求的子序列（最长公共子序列）长度为<code>dp[i][j]</code></strong>。</p>
<p><strong>2.2</strong> <strong>只涉及一个字符串/数组时</strong>（比如本文要讲的最长回文子序列），dp 数组的含义如下：</p>
<p><strong>在子数组<code>array[i..j]</code>中，我们要求的子序列（最长回文子序列）的长度为<code>dp[i][j]</code></strong>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/2020/09/27/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/longest-common-subsequence" target="_blank" rel="noopener">1143.最长公共子序列</a></p>
<p><strong>第一步，一定要明确</strong> <strong><code>dp</code></strong> <strong>数组的含义</strong>。对于两个字符串的动态规划问题，套路是通用的。</p>
<p>比如说对于字符串 <code>s1</code> 和 <code>s2</code>，一般来说都要构造一个这样的 DP table：</p>
<p><img src="/img/zuichanggonggongzixulie.png"></p>
<p>为了方便理解此表，暂时认为索引是从 1 开始的，待会的代码中只要稍作调整即可。其中，<code>dp[i][j]</code> 的含义是：对于 <code>s1[1..i]</code> 和 <code>s2[1..j]</code>，它们的 LCS 长度是 <code>dp[i][j]</code>。</p>
<p>比如上图的例子，<code>d[2][4]</code> 的含义就是：对于 <code>&quot;ac&quot;</code> 和 <code>&quot;babc&quot;</code>，它们的 LCS 长度是 2。最终想得到的答案应该是 <code>dp[3][6]</code>。</p>
<p><strong>第二步，定义 base case。</strong></p>
<p>让索引为 0 的行和列表示空串，<code>dp[0][..]</code> 和 <code>dp[..][0]</code> 都应该初始化为 0，这就是 base case。</p>
<p>比如说，按照刚才 dp 数组的定义，<code>dp[0][3]=0</code> 的含义是：对于字符串 <code>&quot;&quot;</code> 和 <code>&quot;bab&quot;</code>，其 LCS 的长度为 0。因为有一个字符串是空串，它们的最长公共子序列的长度显然应该是 0。</p>
<p><strong>第三步，找状态转移方程。</strong></p>
<p>这是动态规划最难的一步</p>
<a id="more"></a>
<p>状态转移说简单些就是做选择，比如说这个问题，是求 <code>s1</code> 和 <code>s2</code> 的最长公共子序列，不妨称这个子序列为 <code>lcs</code>。那么对于 <code>s1</code> 和 <code>s2</code> 中的每个字符，有什么选择？很简单，两种选择，要么在 <code>lcs</code> 中，要么不在。</p>
<p><img src="/img/zuichanggonggongzixulie2.png"></p>
<p>这个「在」和「不在」就是选择，关键是，应该如何选择呢？这个需要动点脑筋：如果某个字符应该在 <code>lcs</code> 中，那么这个字符肯定同时存在于 <code>s1</code> 和 <code>s2</code> 中，因为 <code>lcs</code> 是最长<strong>公共</strong>子序列嘛。所以本题的思路是这样：</p>
<p>用两个指针 <code>i</code> 和 <code>j</code> 从后往前遍历 <code>s1</code> 和 <code>s2</code>，如果 <code>s1[i]==s2[j]</code>，那么这个字符<strong>一定在</strong> <strong><code>lcs</code></strong> <strong>中</strong>；否则的话，<code>s1[i]</code> 和 <code>s2[j]</code> 这两个字符<strong>至少有一个不在</strong> <strong><code>lcs</code></strong> <strong>中</strong>，需要丢弃一个。先看一下递归解法，比较容易理解：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">String</span> str1;</span><br><span class="line">  <span class="keyword">String</span> str2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="keyword">String</span> text1, <span class="keyword">String</span> text2)</span> </span>&#123;</span><br><span class="line">      str1 = text1;</span><br><span class="line">      str2 = text2;</span><br><span class="line">      <span class="keyword">return</span> dp(text1.length() - <span class="number">1</span>, text2.length() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 空串的 base case</span></span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">-1</span> || j == <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">          <span class="comment">// 这边找到一个 lcs 的元素，继续往前找</span></span><br><span class="line">          <span class="keyword">return</span> dp(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 谁能让 lcs 最长，就听谁的</span></span><br><span class="line">          <span class="keyword">return</span> Math.<span class="built_in">max</span>(dp(i - <span class="number">1</span>, j), dp(i, j - <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>对于第一种情况，找到一个 <code>lcs</code> 中的字符，同时将 <code>i</code> <code>j</code> 向前移动一位，并给 <code>lcs</code> 的长度加一；对于后者，则尝试两种情况，取更大的结果。</p>
<p>其实这段代码就是暴力解法，我们可以通过备忘录或者 DP table 来优化时间复杂度，比如通过 DP table 来解决：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">String</span> str1, <span class="keyword">String</span> str2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> m = str1.length();</span><br><span class="line">      <span class="keyword">int</span> n = str2.length();</span><br><span class="line">      <span class="comment">// 构建 DP table 和 base case</span></span><br><span class="line">      <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">      <span class="comment">//进行状态转移</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (str1.charAt(i - <span class="number">1</span>) == str2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                  <span class="comment">//找到一个 lcs 中的字符</span></span><br><span class="line">                  dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  dp[i][j] = Math.<span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[m][n];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>戳气球问题</title>
    <url>/2020/09/26/%E6%88%B3%E6%B0%94%E7%90%83%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/burst-balloons" target="_blank" rel="noopener">312.戳气球</a></p>
<p>遇到求最值的算法问题，首先要思考的就是：如何穷举出所有可能的结果？</p>
<p>穷举主要有两种算法，就是<strong>回溯算法</strong>和<strong>动态规划</strong>，前者就是暴力穷举，而后者是根据状态转移方程推导「状态」。</p>
<p>如何将戳气球问题转化成回溯算法呢？<strong>其实就是想穷举戳气球的顺序</strong>，不同的戳气球顺序可能得到不同的分数，把所有可能的分数中最高的那个找出来。</p>
<p><strong>回溯算法</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line"><span class="comment">/* 输入一组气球，返回戳破它们获得的最大分数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 回溯算法的伪码解法 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> socre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums 为空) &#123;</span><br><span class="line">        res = Math.<span class="built_in">max</span>(res, score);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">point</span> = nums[i<span class="number">-1</span>] * nums[i] * nums[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        在 nums 中删除元素 nums[i]</span><br><span class="line">        <span class="comment">// 递归回溯</span></span><br><span class="line">        backtrack(nums, score + <span class="built_in">point</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        将 temp 还原到 nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>动态规划</strong></p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> maxCoins(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">length</span>;</span><br><span class="line">    <span class="comment">// 添加两侧的虚拟气球</span></span><br><span class="line">    <span class="type">int</span>[] <span class="keyword">points</span> = new <span class="type">int</span>[n + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">points</span>[<span class="number">0</span>] = <span class="keyword">points</span>[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">points</span>[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case 已经都被初始化为 0</span></span><br><span class="line">    <span class="type">int</span>[][] dp = new <span class="type">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 开始状态转移</span></span><br><span class="line">    <span class="comment">// i 应该从下往上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// j 应该从左往右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n + <span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 最后戳破的气球是哪个？</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                <span class="comment">// 择优做选择</span></span><br><span class="line">                dp[i][j] = Math.<span class="built_in">max</span>(</span><br><span class="line">                    dp[i][j], </span><br><span class="line">                    dp[i][k] + dp[k][j] + <span class="keyword">points</span>[i]*<span class="keyword">points</span>[j]*<span class="keyword">points</span>[k]</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑距离</title>
    <url>/2020/09/24/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/edit-distance" target="_blank" rel="noopener">72.编辑距离</a></p>
<p><strong>解决两个字符串的动态规划问题，一般都是用两个指针</strong> <strong><code>i,j</code></strong> <strong>分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模</strong>。</p>
<p><strong>1.递归</strong></p>
<p>base case 是 <code>i</code> 走完 <code>s1</code> 或 <code>j</code> 走完 <code>s2</code>，可以直接返回另一个字符串剩下的长度。</p>
<p>对于每对字符 <code>s1[i]</code> 和 <code>s2[j]</code>，可以有四种操作：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> s1[<span class="built_in">i</span>] == s2[<span class="built_in">j</span>]:</span><br><span class="line">    啥都别做（skip）</span><br><span class="line">    <span class="built_in">i</span>, <span class="built_in">j</span> 同时向前移动</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    三选一：</span><br><span class="line">        插入（insert）</span><br><span class="line">        删除（delete）</span><br><span class="line">        替换（replace）</span><br></pre></td></tr></table></figure>
<p>⏬⏬⏬</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">String</span> word1, <span class="keyword">String</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp(word1, word2, word1.length() - <span class="number">1</span>, word2.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回 s1[0..i] 和 s2[0..j] 的最小编辑距离</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">String</span> s1, <span class="keyword">String</span> s2, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span>) <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">            <span class="comment">// 本来就相等，不需要任何操作</span></span><br><span class="line">            <span class="comment">// s1[0..i] 和 s2[0..j] 的最小编辑距离等于</span></span><br><span class="line">            <span class="comment">// s1[0..i-1] 和 s2[0..j-1] 的最小编辑距离</span></span><br><span class="line">            <span class="comment">// 也就是说 dp(i, j) 等于 dp(i-1, j-1)</span></span><br><span class="line">            <span class="keyword">return</span> dp(s1, s2, i - <span class="number">1</span>, j - <span class="number">1</span>);  <span class="comment">// 啥都不做</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 插入</span></span><br><span class="line">            <span class="comment">// 直接在 s1[i] 插入一个和 s2[j] 一样的字符</span></span><br><span class="line">            <span class="comment">// 那么 s2[j] 就被匹配了，前移 j，继续跟 i 对比</span></span><br><span class="line">            <span class="comment">// 操作数加一</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除</span></span><br><span class="line">            <span class="comment">// 直接把 s[i] 这个字符删掉</span></span><br><span class="line">            <span class="comment">// 前移 i，继续跟 j 对比</span></span><br><span class="line">            <span class="comment">// 操作数加一</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 替换</span></span><br><span class="line">            <span class="comment">// 直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了</span></span><br><span class="line">            <span class="comment">// 同时前移 i，j 继续对比</span></span><br><span class="line">            <span class="comment">// 操作数加一</span></span><br><span class="line">            <span class="keyword">return</span> Math.<span class="built_in">min</span>(</span><br><span class="line">                    Math.<span class="built_in">min</span>(dp(s1, s2, i, j - <span class="number">1</span>) + <span class="number">1</span>,    <span class="comment">// 插入</span></span><br><span class="line">                            dp(s1, s2, i - <span class="number">1</span>, j) + <span class="number">1</span>),    <span class="comment">// 删除</span></span><br><span class="line">                    dp(s1, s2, i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span> <span class="comment">// 替换</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码有点小问题就是，这个解法是暴力解法，存在重叠子问题，需要用动态规划技巧来优化。</p>
<p>对于子问题 <code>dp(i-1, j-1)</code>，如何通过原问题 <code>dp(i, j)</code> 得到呢？有不止一条路径，比如 <code>dp(i, j) -&gt; #1</code> 和 <code>dp(i, j) -&gt; #2 -&gt; #3</code>。一旦发现一条重复路径，就说明存在巨量重复路径，也就是重叠子问题。</p>
<a id="more"></a>
<p><strong>2.动态规划优化</strong></p>
<p>常用就是用<code>HashMap</code>来做备忘录，避免重叠路径：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">HashMap&lt;<span class="keyword">String</span>, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">String</span> word1, <span class="keyword">String</span> word2)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> dp(word1, word2, word1.length() - <span class="number">1</span>, word2.length() - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">String</span> s1, <span class="keyword">String</span> s2, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(i + <span class="string">"*"</span> + j)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(i + <span class="string">"*"</span> + j);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// base case</span></span><br><span class="line">     <span class="keyword">if</span> (i == <span class="number">-1</span>) <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">if</span> (j == <span class="number">-1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">         <span class="built_in">map</span>.<span class="built_in">put</span>(i + <span class="string">"*"</span> + j, dp(s1, s2, i - <span class="number">1</span>, j - <span class="number">1</span>));  <span class="comment">// 啥都不做</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">map</span>.<span class="built_in">put</span>(i + <span class="string">"*"</span> + j, Math.<span class="built_in">min</span>(</span><br><span class="line">                 Math.<span class="built_in">min</span>(dp(s1, s2, i, j - <span class="number">1</span>) + <span class="number">1</span>,    <span class="comment">// 插入</span></span><br><span class="line">                         dp(s1, s2, i - <span class="number">1</span>, j) + <span class="number">1</span>),    <span class="comment">// 删除</span></span><br><span class="line">                 dp(s1, s2, i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span> <span class="comment">// 替换</span></span><br><span class="line">         ));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(i + <span class="string">"*"</span> + j);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>或是用<code>dp</code>数组：</p>
<p><img src="/img/bianjijuli.png"></p>
<p><code>dp[..][0]</code> 和 <code>dp[0][..]</code> 对应 base case，<code>dp[i][j]</code> 的含义和之前的 dp 函数类似：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">int dp(i, j)</span><br><span class="line">// 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离</span><br><span class="line"></span><br><span class="line">dp[<span class="string">i-1</span>][<span class="symbol">j-1</span>]</span><br><span class="line">// 存储 s1[0..i] 和 s2[0..j] 的最小编辑距离</span><br></pre></td></tr></table></figure>
<p>dp 函数的 base case 是 <code>i,j</code> 等于 -1，而数组索引至少是 0，所以 dp 数组会偏移一位。</p>
<p>既然 dp 数组和递归 dp 函数含义一样，也就可以直接套用之前的思路写代码，<strong>唯一不同的是，DP table 是自底向上求解，递归解法是自顶向下求解</strong>：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">int minDistance(String s1, String s2) &#123;</span><br><span class="line">       int m = s1.length(), n = s2.length();</span><br><span class="line">       int<span class="comment">[]</span><span class="comment">[]</span> dp = new int<span class="comment">[m + 1]</span><span class="comment">[n + 1]</span>;</span><br><span class="line">       // base case</span><br><span class="line">       for (int i = 1; i &lt;= m; i++)</span><br><span class="line">           dp<span class="comment">[i]</span><span class="comment">[0]</span> = i;</span><br><span class="line">       for (int j = 1; j &lt;= n; j++)</span><br><span class="line">           dp<span class="comment">[0]</span><span class="comment">[j]</span> = j;</span><br><span class="line">       // 自底向上求解</span><br><span class="line">       for (int i = 1; i &lt;= m; i++)</span><br><span class="line">           for (int j = 1; j &lt;= n; j++)</span><br><span class="line">               if (s1.charAt(i - 1) == s2.charAt(j - 1))</span><br><span class="line">                   dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j - 1]</span>;</span><br><span class="line">               else</span><br><span class="line">                   dp<span class="comment">[i]</span><span class="comment">[j]</span> = Math.min(</span><br><span class="line">                           Math.min(dp<span class="comment">[i - 1]</span><span class="comment">[j]</span> + 1,</span><br><span class="line">                                   dp<span class="comment">[i]</span><span class="comment">[j - 1]</span> + 1),</span><br><span class="line">                           dp<span class="comment">[i - 1]</span><span class="comment">[j - 1]</span> + 1</span><br><span class="line">                   );</span><br><span class="line">       // 储存着整个 s1 和 s2 的最小编辑距离</span><br><span class="line">       return dp<span class="comment">[m]</span><span class="comment">[n]</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划状态压缩</title>
    <url>/2020/09/18/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>动态规划技巧对于算法效率的提升非常可观，一般来说都能把指数级和阶乘级时间复杂度的算法优化成 O(N^2)，但动态规划也是可以进行阶段性优化的，比如说常听说的「状态压缩」技巧，就能够把很多动态规划解法的空间复杂度进一步降低，由 O(N^2) 降低到 O(N)。</p>
<a id="more"></a>
<p>能够使用状态压缩技巧的动态规划都是二维 <code>dp</code> 问题，<strong>看它的状态转移方程，如果计算状态</strong> <strong><code>dp[i][j]</code></strong> <strong>需要的都是</strong> <strong><code>dp[i][j]</code></strong> <strong>相邻的状态，那么就可以使用状态压缩技巧</strong>，将二维的 <code>dp</code> 数组转化成一维，将空间复杂度从 O(N^2) 降低到 O(N)。</p>
<p>什么是「和 <code>dp[i][j]</code> 相邻的状态」呢，比如最长回文子序列中，代码如下：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">int longestPalindromeSubseq(string s) &#123;</span><br><span class="line">    int n = s.length();</span><br><span class="line">    // dp 数组全部初始化为 0</span><br><span class="line">    int<span class="comment">[]</span><span class="comment">[]</span> dp = new int<span class="comment">[]</span><span class="comment">[]</span>;</span><br><span class="line">    // base case</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        dp<span class="comment">[i]</span><span class="comment">[i]</span> = 1;</span><br><span class="line">    // 反着遍历保证正确的状态转移</span><br><span class="line">    for (int i = n - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">        for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">            // 状态转移方程</span><br><span class="line">            if (s<span class="comment">[i]</span> == s<span class="comment">[j]</span>)</span><br><span class="line">                dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i + 1]</span><span class="comment">[j - 1]</span> + 2;</span><br><span class="line">            else</span><br><span class="line">                dp<span class="comment">[i]</span><span class="comment">[j]</span> = Math.max(dp<span class="comment">[i + 1]</span><span class="comment">[j]</span>, dp<span class="comment">[i]</span><span class="comment">[j - 1]</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 整个 s 的最长回文子串长度</span><br><span class="line">    return dp<span class="comment">[0]</span><span class="comment">[n - 1]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看对 <code>dp[i][j]</code> 的更新，其实只依赖于 <code>dp[i+1][j-1], dp[i][j-1], dp[i+1][j]</code> 这三个状态：</p>
<p><img src="/img/zhuangtaiyasuo2.png"></p>
<p><img src="/img/zhuangtaiyasuo1.png"></p>
<p>这就叫和 <code>dp[i][j]</code> 相邻，反正你计算 <code>dp[i][j]</code> 只需要这三个相邻状态，其实根本不需要那么大一个二维的 dp table 对不对？<strong>状态压缩的核心思路就是，将二维数组「投影」到一维数组</strong>：</p>
<p><img src="/img/zhuangtaiyasuo3.png"></p>
<p>思路很直观，但是也有一个明显的问题，图中 <code>dp[i][j-1]</code> 和 <code>dp[i+1][j-1]</code> 这两个状态处在同一列，而一维数组中只能容下一个，那么当我计算 <code>dp[i][j]</code> 时，他俩必然有一个会被另一个覆盖掉，怎么办？</p>
<p>这就是状态压缩的难点，下面就来分析解决这个问题，还是拿「最长回文子序列」问题距离，它的状态转移方程主要逻辑就是如下这段代码：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for (int i = n - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">    for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">        // 状态转移方程</span><br><span class="line">        if (s<span class="comment">[i]</span> == s<span class="comment">[j]</span>)</span><br><span class="line">            dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i + 1]</span><span class="comment">[j - 1]</span> + 2;</span><br><span class="line">        else</span><br><span class="line">            dp<span class="comment">[i]</span><span class="comment">[j]</span> = Math.max(dp<span class="comment">[i + 1]</span><span class="comment">[j]</span>, dp<span class="comment">[i]</span><span class="comment">[j - 1]</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想把二维 <code>dp</code> 数组压缩成一维，一般来说是把第一个维度，也就是 <code>i</code> 这个维度去掉，只剩下 <code>j</code> 这个维度。<strong>压缩后的一维</strong> <strong><code>dp</code></strong> <strong>数组就是之前二维</strong> <strong><code>dp</code></strong> <strong>数组的</strong> <strong><code>dp[i][..]</code></strong> <strong>那一行</strong>。</p>
<p>先将上述代码进行改造，直接无脑去掉 <code>i</code> 这个维度，把 <code>dp</code> 数组变成一维：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for (int i = n - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">    for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">        // 在这里，一维 dp 数组中的数是什么？</span><br><span class="line">        if (s<span class="comment">[i]</span> == s<span class="comment">[j]</span>)</span><br><span class="line">            dp<span class="comment">[j]</span> = dp<span class="comment">[j - 1]</span> + 2;</span><br><span class="line">        else</span><br><span class="line">            dp<span class="comment">[j]</span> = Math.max(dp<span class="comment">[j]</span>, dp<span class="comment">[j - 1]</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码的一维 <code>dp</code> 数组只能表示二维 <code>dp</code> 数组的一行 <code>dp[i][..]</code>，那怎么才能得到 <code>dp[i+1][j-1], dp[i][j-1], dp[i+1][j]</code> 这几个必要的的值，进行状态转移呢？</p>
<p>在代码中注释的位置，将要进行状态转移，更新 <code>dp[j]</code>，那么要来思考两个问题：</p>
<p>1、在对 <code>dp[j]</code> 赋新值之前，<code>dp[j]</code> 对应着二维 <code>dp</code> 数组中的什么位置？</p>
<p>2、<code>dp[j-1]</code> 对应着二维 <code>dp</code> 数组中的什么位置？</p>
<p><strong>对于问题 1，在对 <code>dp[j]</code> 赋新值之前，<code>dp[j]</code> 的值就是外层 for 循环上一次迭代算出来的值，也就是对应二维</strong> <strong><code>dp</code></strong> <strong>数组中</strong> <strong><code>dp[i+1][j]</code></strong> <strong>的位置</strong>。</p>
<p><strong>对于问题 2，<code>dp[j-1]</code> 的值就是内层 for 循环上一次迭代算出来的值，也就是对应二维</strong> <strong><code>dp</code></strong> <strong>数组中</strong> <strong><code>dp[i][j-1]</code></strong> <strong>的位置</strong>。</p>
<p>那么问题已经解决了一大半了，只剩下二维 <code>dp</code> 数组中的 <code>dp[i+1][j-1]</code> 这个状态不能直接从一维 <code>dp</code> 数组中得到：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for (int i = n - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">    for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">        if (s<span class="comment">[i]</span> == s<span class="comment">[j]</span>)</span><br><span class="line">            // dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i+1]</span><span class="comment">[j-1]</span> + 2;</span><br><span class="line">            dp<span class="comment">[j]</span> = ?? + 2;</span><br><span class="line">        else</span><br><span class="line">            // dp<span class="comment">[i]</span><span class="comment">[j]</span> = Math.max(dp<span class="comment">[i+1]</span><span class="comment">[j]</span>, dp<span class="comment">[i]</span><span class="comment">[j-1]</span>);</span><br><span class="line">            dp<span class="comment">[j]</span> = Math.max(dp<span class="comment">[j]</span>, dp<span class="comment">[j - 1]</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 for 循环遍历 <code>i</code> 和 <code>j</code> 的顺序为从左向右，从下向上，所以可以发现，在更新一维 <code>dp</code> 数组的时候，<code>dp[i+1][j-1]</code> 会被 <code>dp[i][j-1]</code> 覆盖掉，图中标出了这四个位置被遍历到的次序：</p>
<p><img src="/img/zhuangtaiyasuo4.png"></p>
<p><strong>那么如果想得到 <code>dp[i+1][j-1]</code></strong>，<strong>就必须在它被覆盖之前用一个临时变量</strong> <strong><code>temp</code></strong> <strong>把它存起来，并把这个变量的值保留到计算</strong> <strong><code>dp[i][j]</code></strong> <strong>的时候</strong>。为了达到这个目的，结合上图，可以这样写代码：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for (int i = n - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">    // 存储 dp<span class="comment">[i+1]</span><span class="comment">[j-1]</span> 的变量</span><br><span class="line">    int pre = 0;</span><br><span class="line">    for (int j = i + 1; j &lt; n; j++) &#123;</span><br><span class="line">        int temp = dp<span class="comment">[j]</span>;</span><br><span class="line">        if (s<span class="comment">[i]</span> == s<span class="comment">[j]</span>)</span><br><span class="line">            // dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i+1]</span><span class="comment">[j-1]</span> + 2;</span><br><span class="line">            dp<span class="comment">[j]</span> = pre + 2;</span><br><span class="line">        else</span><br><span class="line">            dp<span class="comment">[j]</span> = Math.max(dp<span class="comment">[j]</span>, dp<span class="comment">[j - 1]</span>);</span><br><span class="line">        // 到下一轮循环，pre 就是 dp<span class="comment">[i+1]</span><span class="comment">[j-1]</span> 了</span><br><span class="line">        pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别小看这段代码，这是一维 <code>dp</code> 最精妙的地方，会者不难，难者不会。为了清晰起见，用具体的数值来拆解这个逻辑：</p>
<p>假设现在 <code>i = 5, j = 7</code> 且 <code>s[5] == s[7]</code>，那么现在会进入下面这个逻辑对吧：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">if (s<span class="comment">[5]</span> == s<span class="comment">[7]</span>)</span><br><span class="line">    // dp<span class="comment">[5]</span><span class="comment">[7]</span> = dp<span class="comment">[i+1]</span><span class="comment">[j-1]</span> + 2;</span><br><span class="line">    dp<span class="comment">[7]</span> = pre + 2;</span><br></pre></td></tr></table></figure>
<p>问你这个 <code>pre</code> 变量是什么？是内层 for 循环上一次迭代的 <code>temp</code> 值。</p>
<p>那再问你内层 for 循环上一次迭代的 <code>temp</code> 值是什么？是 <code>dp[j-1]</code> 也就是 <code>dp[6]</code>，但这是外层 for 循环上一次迭代对应的 <code>dp[6]</code>，也就是二维 <code>dp</code> 数组中的 <code>dp[i+1][6] = dp[6][6]</code>。</p>
<p>也就是说，<code>pre</code> 变量就是 <code>dp[i+1][j-1] = dp[6][6]</code>，也就是想要的结果。</p>
<p>那么现在成功对状态转移方程进行了降维打击，算是最硬的的骨头啃掉了，但注意到还有 base case 要处理：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">// dp 数组全部初始化为 0</span><br><span class="line">int[<span class="string"></span>][<span class="symbol"></span>] dp = new int[][];</span><br><span class="line">// base case</span><br><span class="line">for (int i = 0; i <span class="xml"><span class="tag">&lt; <span class="attr">n</span>; <span class="attr">i</span>++)</span></span></span><br><span class="line"><span class="xml">    dp[i][i] = 1;</span></span><br></pre></td></tr></table></figure>
<p>如何把 base case 也打成一维呢？很简单，记住状态压缩就是投影，把 base case 投影到一维看看：</p>
<p><img src="/img/zhuangtaiyasuo5.png"></p>
<p>二维 <code>dp</code> 数组中的 base case 全都落入了一维 <code>dp</code> 数组，不存在冲突和覆盖，所以说直接这样写代码就行了：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一维 dp 数组全部初始化为 1</span></span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[];</span><br><span class="line">Arrays.<span class="built_in">fill</span>(dp, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>至此，把 base case 和状态转移方程都进行了降维，实际上已经写出完整代码了：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="comment">// base case：一维 dp 数组全部初始化为 0</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[];</span><br><span class="line">		Arrays.<span class="built_in">fill</span>(dp, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = dp[j];</span><br><span class="line">            <span class="comment">// 状态转移方程</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                dp[j] = pre + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[j] = Math.<span class="built_in">max</span>(dp[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">            pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>使用状态压缩技巧对二维 <code>dp</code> 数组进行降维打击之后，解法代码的可读性变得非常差了，如果直接看这种解法，任何人都是一脸懵逼的。算法的优化就是这么一个过程，先写出可读性很好的暴力递归算法，然后尝试运用动态规划技巧优化重叠子问题，最后尝试用状态压缩技巧优化空间复杂度。</p>
<p>也就是说，最起码能够熟练找出状态转移方程，写出一个正确的动态规划解法，然后才有可能观察状态转移的情况，分析是否可能使用状态压缩技巧来优化。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>dp 数组的遍历方向</title>
    <url>/2020/09/17/dp-%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>做动态规划问题时，肯定会对<code>dp</code>数组的遍历顺序有些头疼，拿二维<code>dp</code>数组来举例</p>
<p>有时候是正向遍历：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">int[<span class="string"></span>][<span class="symbol"></span>] dp = new int[<span class="string">m</span>][<span class="symbol">n</span>];</span><br><span class="line">for (int i = 0; i <span class="xml"><span class="tag">&lt; <span class="attr">m</span>; <span class="attr">i</span>++)</span></span></span><br><span class="line"><span class="xml">    for (int j = 0; j <span class="tag">&lt; <span class="attr">n</span>; <span class="attr">j</span>++)</span></span></span><br><span class="line"><span class="xml">        // 计算 dp[i][j]</span></span><br></pre></td></tr></table></figure>
<p>有时候反向遍历：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">for (int i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    for (int j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br></pre></td></tr></table></figure>
<p>有时候可能会斜向遍历：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 斜着遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n - l; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = l + i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算 dp[i][j]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>甚至更让人迷惑的是，有时候发现正向反向遍历都可以得到正确答案。</p>
<p>仔细观察的话，只要把住两点就行了：</p>
<p><strong>1、遍历的过程中，所需的状态必须是已经计算出来的</strong>。</p>
<p><strong>2、遍历的终点必须是存储结果的那个位置</strong>。</p>
<p>比如编辑距离这个经典的问题，我们通过对<code>dp</code>数组的定义，确定了 base case 是<code>dp[..][0]</code>和<code>dp[0][..]</code>，最终答案是<code>dp[m][n]</code>；而且我们通过状态转移方程知道<code>dp[i][j]</code>需要从<code>dp[i-1][j]</code>,<code>dp[i][j-1]</code>,<code>dp[i-1][j-1]</code>转移而来，如下图：</p>
<p><img src="/img/dpshuzu.png"></p>
<p>那么，参考刚才说的两条原则，该怎么遍历<code>dp</code>数组？肯定是正向遍历：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">for (int i = 1; i &lt; m; i++)</span><br><span class="line">    for (int j = 1; j &lt; n; j++)</span><br><span class="line">        // 通过 dp<span class="comment">[i-1]</span><span class="comment">[j]</span>, dp<span class="comment">[i]</span><span class="comment">[j - 1]</span>, dp<span class="comment">[i-1]</span><span class="comment">[j-1]</span></span><br><span class="line">        // 计算 dp<span class="comment">[i]</span><span class="comment">[j]</span></span><br></pre></td></tr></table></figure>
<p><strong>因为，这样每一步迭代的左边、上边、左上边的位置都是 base case 或者之前计算过的，而且最终结束在我们想要的答案<code>dp[m][n]</code>。</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最优子结构</title>
    <url>/2020/09/17/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>「最优子结构」是某些问题的一种特定性质，并不是动态规划问题专有的。也就是说，很多问题其实都具有最优子结构，只是其中大部分不具有重叠子问题，所以我们不把它们归为动态规划系列问题而已。</p>
<p>先举个很容易理解的例子：假设学校有 10 个班，已经计算出了每个班的最高考试成绩。那么现在要求计算全校最高的成绩，会不会算？当然会，而且不用重新遍历全校学生的分数进行比较，而是只要在这 10 个最高成绩中取最大的就是全校的最高成绩。</p>
<p>提出的这个问题就<strong>符合最优子结构</strong>：可以从子问题的最优结果推出更大规模问题的最优结果。算<strong>每个班</strong>的最优成绩就是子问题，知道所有子问题的答案后，就可以借此推出<strong>全校</strong>学生的最优成绩这个规模更大的问题的答案。</p>
<p>所以看，这么简单的问题都有最优子结构性质，只是因为显然没有重叠子问题，所以我们简单地求最值肯定用不出动态规划。</p>
<a id="more"></a>
<p>再举个例子：假设学校有 10 个班，已知每个班的最大分数差（最高分和最低分的差值）。那么现在计算全校学生中的最大分数差，会不会算？可以想办法算，但是肯定不能通过已知的这 10 个班的最大分数差推到出来。因为这 10 个班的最大分数差不一定就包含全校学生的最大分数差，比如全校的最大分数差可能是 3 班的最高分和 6 班的最低分之差。</p>
<p>这次提出的问题就<strong>不符合最优子结构</strong>，因为没办通过每个班的最优值推出全校的最优值，没办法通过子问题的最优值推出规模更大的问题的最优值。想满足最优子结，子问题之间必须互相独立。全校的最大分数差可能出现在两个班之间，显然子问题不独立，所以这个问题本身不符合最优子结构。</p>
<p><strong>那么遇到这种最优子结构失效情况，怎么办？策略是：改造问题</strong>。对于最大分数差这个问题，我们不是没办法利用已知的每个班的分数差吗，那只能这样写一段暴力代码：</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">Student</span> a : school) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Student</span> b : school) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">is</span> b) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="literal">result</span> = max(<span class="literal">result</span>, |a.score - b.score|);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">result</span>;</span><br></pre></td></tr></table></figure>
<p>改造问题，也就是把问题等价转化：最大分数差，不就等价于最高分数和最低分数的差么，那不就是要求最高和最低分数么，不就是我们讨论的第一个问题么，不就具有最优子结构了么？那现在改变思路，借助最优子结构解决最值问题，再回过头解决最大分数差问题，是不是就高效多了？</p>
<p>再举个常见但也十分简单的例子，求一棵二叉树的最大值，不难吧（简单起见，假设节点中的值都是非负数）：</p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> maxVal(TreeNode root) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        return <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">left</span> = maxVal(root.<span class="built_in">left</span>);</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">right</span> = maxVal(root.<span class="built_in">right</span>);</span><br><span class="line">    return max(root.val, <span class="built_in">left</span>, <span class="built_in">right</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题也符合最优子结构，以<code>root</code>为根的树的最大值，可以通过两边子树（子问题）的最大值推导出来，结合刚才学校和班级的例子，很容易理解吧。</p>
<p>当然这也不是动态规划问题，旨在说明，最优子结构并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；<strong>但反过来，最优子结构性质作为动态规划问题的必要条件，一定是求最值的</strong>。</p>
<p>动态规划就是从最简单的 base case 往后推导，可以想象成一个链式反应，不断以小博大。但只有符合最优子结构的问题，才有发生这种链式反应的性质。</p>
<p>找最优子结构的过程，其实就是证明状态转移方程正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有重叠子问题了，有则优化，无则 OK。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>表达式求值算法</title>
    <url>/2020/09/15/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/basic-calculator" target="_blank" rel="noopener">224.基本计算器</a></p>
<p><a href="https://leetcode.com/problems/basic-calculator-ii" target="_blank" rel="noopener">227.基本计算器II</a></p>
<blockquote>
<p><strong><em>1、</em></strong>输入一个字符串，可以包含<code>+ - * / ()</code>、数字、空格，你的算法返回运算结果。</p>
<p><strong><em>2、</em></strong>要符合运算法则，括号的优先级最高，先乘除后加减。</p>
<p><strong><em>3、</em></strong>除号是整数除法，无论正负都向 0 取整（5/2=2，-5/2=-2）。</p>
<p><strong><em>4、</em></strong>可以假定输入的算式一定合法，且计算过程不会出现整型溢出，不会出现除数为 0 的意外情况。</p>
<p>比如输入如下字符串，算法会返回 9：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">&gt;<span class="number">3</span> * (<span class="number">2</span><span class="number">-6</span> /(<span class="number">3</span> <span class="number">-7</span>))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>可以看到，这就已经非常接近我们实际生活中使用的计算器了，虽然我们以前肯定都用过计算器，但是如果简单思考一下其算法实现，就会大惊失色：</p>
<p><strong><em>1、</em></strong>按照常理处理括号，要先计算最内层的括号，然后向外慢慢化简。这个过程我们手算都容易出错，何况写成算法呢！</p>
<p><strong><em>2、</em></strong>要做到先乘除，后加减，这一点教会小朋友还不算难，但教给计算机恐怕有点困难。</p>
<p><strong><em>3、</em></strong>要处理空格。我们为了美观，习惯性在数字和运算符之间打个空格，但是计算之中得想办法忽略这些空格。</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">         将 减法、乘法、除法 转换为 加法</span></span><br><span class="line"><span class="comment">         某个数 num, 如果前面的对应的运算符是 -，那么 将 -num 压入栈中</span></span><br><span class="line"><span class="comment">         这样，我们只需在最后将栈的元素全部弹出，完成加法操作，即可得到最终结果</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         对于括号，它存在递归性质</span></span><br><span class="line"><span class="comment">         即</span></span><br><span class="line"><span class="comment">         3 * (2 + 4 * 3) + 2</span></span><br><span class="line"><span class="comment">       = 3 * calculate(2 + 4 * 3) + 2</span></span><br><span class="line"><span class="comment">       = 3 * 14 + 2</span></span><br><span class="line"><span class="comment">       即我们可以将括号内的字符串当作一个运算式，再递归调用本函数，最终返回一个数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">return</span> dfs(s);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">     Deque&lt;Integer&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//记录某个连续的数，比如 "42"，那么我们首先 num = 4，然后遇到 2 ,num = num * 10 + 2 = 42</span></span><br><span class="line">     <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">char</span> op = <span class="string">'+'</span>;</span><br><span class="line">     <span class="keyword">for</span> (; i &lt; s.length(); i++) &#123;</span><br><span class="line">         <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//遇到左括号，递归运算内部子式</span></span><br><span class="line">         <span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line">             ++i;</span><br><span class="line">             num = dfs(s);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (Character.isDigit(ch)) &#123;</span><br><span class="line">             num = num * <span class="number">10</span> + (ch - <span class="string">'0'</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//不是数字，不是空格（运算符 或 '(' 或 ')' ） 或者 到了最后一个字符，那么根据前面记录的 op 操作符 将数字压栈，然后将新的运算符 ch 赋值给 op</span></span><br><span class="line">         <span class="keyword">if</span> (!Character.isDigit(ch) &amp;&amp; ch != <span class="string">' '</span> || i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                     <span class="built_in">stack</span>.push(num);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                     <span class="built_in">stack</span>.push(-num);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                     <span class="keyword">int</span> pre = <span class="built_in">stack</span>.pop();</span><br><span class="line">                     <span class="built_in">stack</span>.push(pre * num);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                     pre = <span class="built_in">stack</span>.pop();</span><br><span class="line">                     <span class="built_in">stack</span>.push(pre / num);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             num = <span class="number">0</span>;</span><br><span class="line">             op = ch;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">         遇到右括号，退出循环，然后计算结果， 返回上一层 dfs</span></span><br><span class="line"><span class="comment">         这一步写在最后是因为，当 ch 为 右括号 时，那么我们需要先将前面已经得到的 num 压入栈中，再退出循环</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="keyword">if</span> (ch == <span class="string">')'</span>) &#123;</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (!<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line">         res += <span class="built_in">stack</span>.pop();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>完全背包问题</title>
    <url>/2020/09/14/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/coin-change-2/" target="_blank" rel="noopener">518.零钱兑换II</a></p>
<p><strong>这个问题转化为背包问题的描述形式</strong>：</p>
<blockquote>
<p>有一个背包，最大容量为 <code>amount</code>，有一系列物品 <code>coins</code>，每个物品的重量为 <code>coins[i]</code>，<strong>每个物品的数量无限</strong>。请问有多少种方法，能够把背包恰好装满？</p>
<p><strong>若只使用</strong> <strong><code>coins</code></strong> <strong>中的前</strong> <strong><code>i</code></strong> <strong>个硬币的面值，若想凑出金额</strong> <strong><code>j</code></strong>，有 <strong><code>dp[i][j]</code></strong> <strong>种凑法</strong>。</p>
<p><strong>如果你不把这第</strong> <strong><code>i</code></strong> <strong>个物品装入背包</strong>，也就是说你不使用 <code>coins[i]</code> 这个面值的硬币，那么凑出面额 <code>j</code> 的方法数 <code>dp[i][j]</code> 应该等于 <code>dp[i-1][j]</code>，继承之前的结果。</p>
<p><strong>如果你把这第</strong> <strong><code>i</code></strong> <strong>个物品装入了背包</strong>，也就是说你使用 <code>coins[i]</code> 这个面值的硬币，那么 <code>dp[i][j]</code> 应该等于 <code>dp[i][j-coins[i-1]]</code>。</p>
</blockquote>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">public int change(int amount, int<span class="comment">[]</span> coins) &#123;</span><br><span class="line">       int n = coins.length;</span><br><span class="line">       int<span class="comment">[]</span><span class="comment">[]</span> dp = new int<span class="comment">[n + 1]</span><span class="comment">[amount + 1]</span>;</span><br><span class="line">       // base case</span><br><span class="line">       for (int i = 0; i &lt;= n; i++)</span><br><span class="line">           dp<span class="comment">[i]</span><span class="comment">[0]</span> = 1;</span><br><span class="line"></span><br><span class="line">       for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">           for (int j = 1; j &lt;= amount; j++)</span><br><span class="line">               if (j - coins<span class="comment">[i - 1]</span> &gt;= 0)</span><br><span class="line">                   dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j]</span></span><br><span class="line">                           + dp<span class="comment">[i]</span><span class="comment">[j - coins<span class="comment">[i - 1]</span>]</span>;</span><br><span class="line">               else</span><br><span class="line">                   dp<span class="comment">[i]</span><span class="comment">[j]</span> = dp<span class="comment">[i - 1]</span><span class="comment">[j]</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       return dp<span class="comment">[n]</span><span class="comment">[amount]</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>子集背包问题</title>
    <url>/2020/09/14/%E5%AD%90%E9%9B%86%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener">416.分割等和子集</a></p>
<blockquote>
<p>背包问题大致的描述是什么：</p>
<p>给你一个可装载重量为 <code>W</code> 的背包和 <code>N</code> 个物品，每个物品有重量和价值两个属性。其中第 <code>i</code> 个物品的重量为 <code>wt[i]</code>，价值为 <code>val[i]</code>，现在让你用这个背包装物品，最多能装的价值是多少？</p>
<p>那么对于这个问题，我们可以先对集合求和，得出 <code>sum</code>，把问题转化为背包问题：</p>
<p>给一个可装载重量为 <code>sum / 2</code> 的背包和 <code>N</code> 个物品，每个物品的重量为** <code>nums[i]</code>。现在让你装物品，是否存在一种装法，能够恰好将背包装满？</p>
</blockquote>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> canPartition(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) <span class="keyword">sum</span> += num;</span><br><span class="line">        <span class="comment">// 和为奇数时，不可能划分成两个和相等的集合</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">sum</span> % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">sum</span> = <span class="keyword">sum</span> / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>][<span class="keyword">sum</span> + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="keyword">sum</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - nums[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 背包容量不足，不能装入第 i 个物品</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 装入或不装入背包</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="keyword">sum</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>高楼扔鸡蛋问题</title>
    <url>/2020/09/14/%E9%AB%98%E6%A5%BC%E6%89%94%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/super-egg-drop/" target="_blank" rel="noopener">887.鸡蛋掉落</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">// 当前状态为 (K 个鸡蛋，<span class="keyword">N</span> 层楼)</span><br><span class="line">// 返回这个状态下的最优结果</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">dp</span>(K, <span class="keyword">N</span>):</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">res</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">1</span> &lt;= i &lt;= <span class="keyword">N</span>:</span><br><span class="line">        <span class="keyword">res</span> = <span class="built_in">min</span>(<span class="keyword">res</span>, 这次在第 i 层楼扔鸡蛋)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">res</span></span><br><span class="line">    </span><br><span class="line">base case:</span><br><span class="line">    <span class="keyword">if</span> K == <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">N</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">N</span> == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果鸡蛋碎了，那么鸡蛋的个数K应该减一，搜索的楼层区间应该从[1..N]变为[1..i-1]共i-1层楼</p>
<p>如果鸡蛋没碎，那么鸡蛋的个数K不变，搜索的楼层区间应该从 [1..N]变为[i+1..N]共N-i层楼</p>
<p>最坏情况下扔鸡蛋的次数，所以鸡蛋在第i层楼碎没碎，取决于哪种情况的结果更大</p>
<p>🔽🔽🔽</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">Map&lt;<span class="keyword">String</span>, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(K + <span class="string">"*"</span> + N)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(K + <span class="string">"*"</span> + N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 最坏情况下的最少扔鸡蛋次数</span></span><br><span class="line">            res = Math.<span class="built_in">min</span>(res,</span><br><span class="line">                    <span class="comment">//最坏情况下</span></span><br><span class="line">                    Math.<span class="built_in">max</span>(dp(K, N - i), <span class="comment">// 没碎</span></span><br><span class="line">                            dp(K - <span class="number">1</span>, i - <span class="number">1</span>)) <span class="comment">//碎</span></span><br><span class="line">                            + <span class="number">1</span> <span class="comment">//在第 i 楼扔了一次</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">put</span>(K + <span class="string">"*"</span> + N, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>结果超时了，可以将for循环改成二分搜索</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">Map&lt;<span class="keyword">String</span>, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp2</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">map</span>.containsKey(K+<span class="string">"*"</span>+N)) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans;</span><br><span class="line">            <span class="keyword">if</span> (N == <span class="number">0</span>)</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (K == <span class="number">1</span>)</span><br><span class="line">                ans = N;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> lo = <span class="number">1</span>, hi = N;</span><br><span class="line">                <span class="keyword">while</span> (lo + <span class="number">1</span> &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> t1 = dp(K - <span class="number">1</span>, x - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">int</span> t2 = dp(K, N - x);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (t1 &lt; t2)</span><br><span class="line">                        lo = x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2)</span><br><span class="line">                        hi = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        lo = hi = x;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ans = <span class="number">1</span> + Math.<span class="built_in">min</span>(Math.<span class="built_in">max</span>(dp(K - <span class="number">1</span>, lo - <span class="number">1</span>), dp(K, N - lo)),</span><br><span class="line">                        Math.<span class="built_in">max</span>(dp(K - <span class="number">1</span>, hi - <span class="number">1</span>), dp(K, N - hi)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">map</span>.<span class="built_in">put</span>(K+<span class="string">"*"</span>+N, ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(K+<span class="string">"*"</span>+N);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>nSum 问题</title>
    <url>/2020/09/14/nSum-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1.两数之和</a></p>
<p><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">15.三数之和</a></p>
<p><a href="https://leetcode.com/problems/4sum/" target="_blank" rel="noopener">18.四数之和</a></p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">     * <span class="number">100</span><span class="built_in">sum</span></span><br><span class="line">     * 调用前 先给数组排序  Arrays.sort(nums);</span><br><span class="line">     */</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; nSumTarget(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> <span class="built_in">n</span>, <span class="built_in">int</span> start, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="built_in">int</span> sz = nums.length;</span><br><span class="line">        //至少<span class="number">2</span><span class="built_in">sum</span></span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">n</span> &lt; <span class="number">2</span> || sz &lt; <span class="built_in">n</span>) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        //从<span class="number">2</span><span class="built_in">sum</span>开始</span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">n</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            //双指针</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">left</span> = start;</span><br><span class="line">            <span class="built_in">int</span> <span class="built_in">right</span> = sz - <span class="number">1</span>;</span><br><span class="line">            while (<span class="built_in">left</span> &lt; <span class="built_in">right</span>) &#123;</span><br><span class="line">                <span class="built_in">int</span> <span class="built_in">sum</span> = nums[<span class="built_in">left</span>] + nums[<span class="built_in">right</span>];</span><br><span class="line">                <span class="built_in">int</span> lv = nums[<span class="built_in">left</span>];</span><br><span class="line">                <span class="built_in">int</span> rv = nums[<span class="built_in">right</span>];</span><br><span class="line">                <span class="built_in">if</span> (<span class="built_in">sum</span> &lt; target) &#123;</span><br><span class="line">                    while (<span class="built_in">left</span> &lt; <span class="built_in">right</span> &amp;&amp; nums[<span class="built_in">left</span>] == lv) &#123;</span><br><span class="line">                        <span class="built_in">left</span>++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else <span class="built_in">if</span> (<span class="built_in">sum</span> &gt; target) &#123;</span><br><span class="line">                    while (<span class="built_in">left</span> &lt; <span class="built_in">right</span> &amp;&amp; nums[<span class="built_in">right</span>] == rv) &#123;</span><br><span class="line">                        <span class="built_in">right</span>--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    List&lt;Integer&gt; l = new ArrayList&lt;&gt;();</span><br><span class="line">                    l.add(lv);</span><br><span class="line">                    l.add(rv);</span><br><span class="line">                    res.add(l);</span><br><span class="line">                    while (<span class="built_in">left</span> &lt; <span class="built_in">right</span> &amp;&amp; nums[<span class="built_in">left</span>] == lv) &#123;</span><br><span class="line">                        <span class="built_in">left</span>++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    while (<span class="built_in">left</span> &lt; <span class="built_in">right</span> &amp;&amp; nums[<span class="built_in">right</span>] == rv) &#123;</span><br><span class="line">                        <span class="built_in">right</span>--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // <span class="built_in">n</span> &gt; <span class="number">2</span>时 递归计算（<span class="built_in">n</span> - <span class="number">1</span>）<span class="built_in">sum</span> 的结果</span><br><span class="line">            for (<span class="built_in">int</span> i = start; i &lt; sz; i++) &#123;</span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; sub = nSumTarget(nums, <span class="built_in">n</span> - <span class="number">1</span>, i + <span class="number">1</span>, target - nums[i]);</span><br><span class="line">                for (List&lt;Integer&gt; arr <span class="symbol">:</span> sub) &#123;</span><br><span class="line">                    //（<span class="built_in">n</span> - <span class="number">1</span>）<span class="built_in">sum</span> + num[i] = nsum</span><br><span class="line">                    arr.add(nums[i]);</span><br><span class="line">                    res.add(arr);</span><br><span class="line">                &#125;</span><br><span class="line">                while (i &lt; sz - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>tips:</p>
<p>调用前先给数组排序</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line">nsum调用</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">nSumTarget(arr, n, <span class="number">0</span>, <span class="keyword">target</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍问题</title>
    <url>/2020/09/14/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/house-robber" target="_blank" rel="noopener">198.打家劫舍</a></p>
<p><a href="https://leetcode.com/problems/house-robber-ii" target="_blank" rel="noopener">213.打家劫舍II</a></p>
<p><a href="https://leetcode.com/problems/house-robber-iii" target="_blank" rel="noopener">337.打家劫舍III</a></p>
<p>还是动态规划</p>
<p>假想你就是这个专业强盗，从左到右走过这一排房子，在每间房子前都有两种<strong>选择</strong>：抢或者不抢。</p>
<p>如果你抢了这间房子，那么你肯定不能抢相邻的下一间房子了，只能从<strong>下下间</strong>房子开始做选择。</p>
<p>如果你不抢这间房子，那么你可以走到<strong>下一间</strong>房子前，继续做选择。</p>
<p>当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（<strong>base case</strong>）。</p>
<p>以上的逻辑很简单吧，其实已经明确了「状态」和「选择」：<strong>你面前房子的索引就是状态，抢和不抢就是选择</strong>。</p>
<p>「状态」：面前房子的索引</p>
<p>「选择」：抢或不抢</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//自顶向下</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = Math.<span class="built_in">max</span>(dp(nums, start + <span class="number">1</span>), nums[start] + dp(nums, start + <span class="number">2</span>));</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//自底向上</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = nums.length;</span><br><span class="line">      <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          dp[i] = Math.<span class="built_in">max</span>(dp[i + <span class="number">1</span>], nums[i] + dp[i + <span class="number">2</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//当前状态转移只和dp[i]后两间相关 优化空间O(1)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n = nums.length;</span><br><span class="line">      <span class="keyword">int</span> dp_i_1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> dp_i_2 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> dp_i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          dp_i = Math.<span class="built_in">max</span>(dp_i_1, nums[i] + dp_i_2);</span><br><span class="line">          dp_i_2 = dp_i_1;</span><br><span class="line">          dp_i_1 = dp_i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dp_i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//二叉树题</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * [0]:不抢root</span></span><br><span class="line"><span class="comment">   * [1]:抢root</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span>[] dp(TreeNode root) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root == null) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span>[] left = dp(root.left);</span><br><span class="line">      <span class="keyword">int</span>[] right = dp(root.right);</span><br><span class="line">      <span class="comment">//抢root 下家就不能抢</span></span><br><span class="line">      <span class="keyword">int</span> rob = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">//不抢root 下家可以抢</span></span><br><span class="line">      <span class="keyword">int</span> not_rob = Math.<span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.<span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;not_rob, rob&#125;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>股票买卖</title>
    <url>/2020/09/14/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solution/" target="_blank" rel="noopener">121.买卖股票的最佳时机</a></p>
<p>一、穷举框架</p>
<blockquote>
<p>具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态</p>
</blockquote>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">for 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    for 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 择优(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>「选择」：买入、卖出、无操作<br>「状态」：天数、允许交易的最大次数、当前的持有状态(1持有，0未持有)</p>
<p><code>dp[3][2][1]</code> ：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易</p>
<p>求<code>dp[n - 1][K][0]</code></p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">dp[<span class="string">i</span>][<span class="symbol">k</span>][<span class="string">0 or 1</span>]</span><br><span class="line">0 <span class="xml"><span class="tag">&lt;<span class="name">=</span> <span class="attr">i</span> &lt;= <span class="string">n-1,</span> <span class="attr">1</span> &lt;= <span class="string">k</span> &lt;= <span class="string">K</span></span></span></span><br><span class="line"><span class="xml">n 为天数，大 K 为最多交易数</span></span><br><span class="line"><span class="xml">此问题共 n × K × 2 种状态，全部穷举就能搞定。</span></span><br><span class="line"></span><br><span class="line"><span class="xml">for 0 <span class="tag">&lt;<span class="name">=</span> <span class="attr">i</span> &lt; <span class="attr">n:</span></span></span></span><br><span class="line"><span class="xml">    for 1 <span class="tag">&lt;<span class="name">=</span> <span class="attr">k</span> &lt;= <span class="string">K:</span></span></span></span><br><span class="line"><span class="xml">        for s in &#123;0, 1&#125;:</span></span><br><span class="line"><span class="xml">            dp[i][k][s] = max(buy, sell, rest)</span></span><br></pre></td></tr></table></figure>
<p>二、状态转移框架</p>
<p><img src="/img/gupiaowenti.png"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">dp[<span class="string">i</span>][<span class="symbol">k</span>][<span class="string">0</span>] = max(dp[<span class="string">i-1</span>][<span class="symbol">k</span>][<span class="string">0</span>], dp[<span class="string">i-1</span>][<span class="symbol">k</span>][<span class="string">1</span>] + prices[i])</span><br><span class="line"><span class="code">             	max(选择 rest,      选择 sell)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>今天我没有持有股票，有两种可能：<br>要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；<br>要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">dp[<span class="string">i</span>][<span class="symbol">k</span>][<span class="string">1</span>] = max(dp[<span class="string">i-1</span>][<span class="symbol">k</span>][<span class="string">1</span>], dp[<span class="string">i-1</span>][<span class="symbol">k-1</span>][<span class="string">0</span>] - prices[i])</span><br><span class="line"><span class="code">              max(选择 rest,      选择 buy)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>今天我持有着股票，有两种可能：<br>要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；<br>要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">dp[<span class="string">-1</span>][<span class="symbol">k</span>][<span class="string">0</span>] = 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">dp[<span class="string">-1</span>][<span class="symbol">k</span>][<span class="string">1</span>] = -infinity</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">dp[<span class="string">i</span>][<span class="symbol">0</span>][<span class="string">0</span>] = 0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">dp[<span class="string">i</span>][<span class="symbol">0</span>][<span class="string">1</span>] = -infinity</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">base case：</span><br><span class="line">dp[<span class="string">-1</span>][<span class="symbol">k</span>][<span class="string">0</span>] = dp[<span class="string">i</span>][<span class="symbol">0</span>][<span class="string">0</span>] = 0</span><br><span class="line">dp[<span class="string">-1</span>][<span class="symbol">k</span>][<span class="string">1</span>] = dp[<span class="string">i</span>][<span class="symbol">0</span>][<span class="string">1</span>] = -infinity</span><br><span class="line"></span><br><span class="line">状态转移方程：</span><br><span class="line">dp[<span class="string">i</span>][<span class="symbol">k</span>][<span class="string">0</span>] = max(dp[<span class="string">i-1</span>][<span class="symbol">k</span>][<span class="string">0</span>], dp[<span class="string">i-1</span>][<span class="symbol">k</span>][<span class="string">1</span>] + prices[i])</span><br><span class="line">dp[<span class="string">i</span>][<span class="symbol">k</span>][<span class="string">1</span>] = max(dp[<span class="string">i-1</span>][<span class="symbol">k</span>][<span class="string">1</span>], dp[<span class="string">i-1</span>][<span class="symbol">k-1</span>][<span class="string">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>
<p>⏬⏬⏬<br><figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">public int maxProfit(int<span class="comment">[]</span> prices) &#123;</span><br><span class="line">       if (prices == null || prices.length == 0) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       int n = prices.length;</span><br><span class="line">       int<span class="comment">[]</span><span class="comment">[]</span> dp = new int<span class="comment">[n]</span><span class="comment">[2]</span>;</span><br><span class="line">       for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">           if (i - 1 == -1) &#123;</span><br><span class="line">               dp<span class="comment">[i]</span><span class="comment">[0]</span> = 0;</span><br><span class="line">               //   dp<span class="comment">[i]</span><span class="comment">[0]</span></span><br><span class="line">               // = max(dp<span class="comment">[-1]</span><span class="comment">[0]</span>, dp<span class="comment">[-1]</span><span class="comment">[1]</span> + prices<span class="comment">[i]</span>)</span><br><span class="line">               // = max(0, -infinity + prices<span class="comment">[i]</span>) = 0</span><br><span class="line">               dp<span class="comment">[i]</span><span class="comment">[1]</span> = -prices<span class="comment">[i]</span>;</span><br><span class="line">               //   dp<span class="comment">[i]</span><span class="comment">[1]</span></span><br><span class="line">               // = max(dp<span class="comment">[-1]</span><span class="comment">[1]</span>, dp<span class="comment">[-1]</span><span class="comment">[0]</span> - prices<span class="comment">[i]</span>)</span><br><span class="line">               // = max(-infinity, 0 - prices<span class="comment">[i]</span>)</span><br><span class="line">               // = -prices<span class="comment">[i]</span></span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           dp<span class="comment">[i]</span><span class="comment">[0]</span> = Math.max(dp<span class="comment">[i - 1]</span><span class="comment">[0]</span>, dp<span class="comment">[i - 1]</span><span class="comment">[1]</span> + prices<span class="comment">[i]</span>);</span><br><span class="line">           dp<span class="comment">[i]</span><span class="comment">[1]</span> = Math.max(dp<span class="comment">[i - 1]</span><span class="comment">[1]</span>, -prices<span class="comment">[i]</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       return dp<span class="comment">[n - 1]</span><span class="comment">[0]</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>tips:</p>
<p>如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，当然你也可以在 sell 的时候减 1，一样的。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口算法</title>
    <url>/2020/09/14/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/minimum-window-substring" target="_blank" rel="noopener">76.最小覆盖子串</a></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗口算法框架 */</span></span><br><span class="line">  void slidingWindow(<span class="type">String</span> s, <span class="type">String</span> t) &#123;</span><br><span class="line">      <span class="type">HashMap</span>&lt;<span class="type">Character</span>, <span class="type">Integer</span>&gt; need, window;</span><br><span class="line">      <span class="keyword">for</span> (char <span class="built_in">c</span> : t.toCharArray()) &#123;</span><br><span class="line">          need.put(<span class="built_in">c</span>, need.getOrDefault(<span class="built_in">c</span>, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = <span class="number">0</span>;</span><br><span class="line">      int valid = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">right</span> &lt; s.length()) &#123;</span><br><span class="line">          <span class="comment">// c 是将移入窗口的字符</span></span><br><span class="line">          char <span class="built_in">c</span> = s.charAt(<span class="keyword">right</span>);</span><br><span class="line">          <span class="comment">// 右移窗口</span></span><br><span class="line">          <span class="keyword">right</span>++;</span><br><span class="line">          <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">      		...</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">          <span class="type">System</span>.out.printf(<span class="string">"window: [%d, %d)\n"</span>, <span class="keyword">left</span>, <span class="keyword">right</span>);</span><br><span class="line">          <span class="comment">/********************/</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">          <span class="keyword">while</span> (window needs shrink)&#123;</span><br><span class="line">              <span class="comment">// d 是将移出窗口的字符</span></span><br><span class="line">              char d = s.charAt(<span class="keyword">left</span>);</span><br><span class="line">              <span class="comment">// 左移窗口</span></span><br><span class="line">              <span class="keyword">left</span>++;</span><br><span class="line">              <span class="comment">// 进行窗口内数据的一系列更新</span></span><br><span class="line">        		  ...</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>⏬⏬⏬</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">String</span> minWindow(<span class="type">String</span> s, <span class="type">String</span> t) &#123;</span><br><span class="line">       <span class="type">HashMap</span>&lt;<span class="type">Character</span>, <span class="type">Integer</span>&gt; need = new <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="type">HashMap</span>&lt;<span class="type">Character</span>, <span class="type">Integer</span>&gt; window = new <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">Character</span> <span class="built_in">c</span> : t.toCharArray()) &#123;</span><br><span class="line">           need.put(<span class="built_in">c</span>, need.getOrDefault(<span class="built_in">c</span>, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       int <span class="keyword">left</span> = <span class="number">0</span>;</span><br><span class="line">       int <span class="keyword">right</span> = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//满足need条件的字符个数</span></span><br><span class="line">       int vaild = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//记录最小覆盖子串的其实索引和长度</span></span><br><span class="line">       int start = <span class="number">0</span>;</span><br><span class="line">       int len = <span class="type">Integer</span>.<span class="type">MAX_VALUE</span>;</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">right</span> &lt; s.length()) &#123;</span><br><span class="line">           <span class="comment">//c是即将移入窗口的字符</span></span><br><span class="line">           char <span class="built_in">c</span> = s.charAt(<span class="keyword">right</span>);</span><br><span class="line">           <span class="comment">//右移窗口</span></span><br><span class="line">           <span class="keyword">right</span>++;</span><br><span class="line">           <span class="comment">//进行窗口内数据更新</span></span><br><span class="line">           <span class="keyword">if</span> (need.containsKey(<span class="built_in">c</span>)) &#123;</span><br><span class="line">               window.put(<span class="built_in">c</span>, window.getOrDefault(<span class="built_in">c</span>, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">               <span class="keyword">if</span> (window.<span class="keyword">get</span>(<span class="built_in">c</span>).equals(need.<span class="keyword">get</span>(<span class="built_in">c</span>))) &#123;</span><br><span class="line">                   vaild++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//判断左侧窗口是否需要收缩</span></span><br><span class="line">           <span class="keyword">while</span> (vaild == need.size()) &#123;</span><br><span class="line">               <span class="comment">//更新最小覆盖子串</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">right</span> - <span class="keyword">left</span> &lt; len) &#123;</span><br><span class="line">                   start = <span class="keyword">left</span>;</span><br><span class="line">                   len = <span class="keyword">right</span> - <span class="keyword">left</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//d是即将移除的字符</span></span><br><span class="line">               char d = s.charAt(<span class="keyword">left</span>);</span><br><span class="line">               <span class="comment">//左移窗口</span></span><br><span class="line">               <span class="keyword">left</span>++;</span><br><span class="line">               <span class="comment">//进行窗口内数据更新</span></span><br><span class="line">               <span class="keyword">if</span> (need.containsKey(d)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (window.<span class="keyword">get</span>(d).equals(need.<span class="keyword">get</span>(d))) &#123;</span><br><span class="line">                       vaild--;</span><br><span class="line">                   &#125;</span><br><span class="line">                   window.put(d, window.<span class="keyword">get</span>(d) - <span class="number">1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//返回最小覆盖子串</span></span><br><span class="line">       <span class="keyword">return</span> len == <span class="type">Integer</span>.<span class="type">MAX_VALUE</span> ? <span class="string">""</span> : s.substring(start, start + len);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索套路框架</title>
    <url>/2020/09/14/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> binarySearch(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + (<span class="built_in">right</span> - <span class="built_in">left</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="built_in">mid</span>] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="built_in">mid</span>] &lt; target) &#123;</span><br><span class="line">            <span class="built_in">left</span> = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="built_in">mid</span>] &gt; target) &#123;</span><br><span class="line">            <span class="built_in">right</span> = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⏬⏬⏬<br><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> binarySearch(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">right</span> = nums.length - <span class="number">1</span>; // 注意</span><br><span class="line"></span><br><span class="line">    while(<span class="built_in">left</span> &lt;= <span class="built_in">right</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + (<span class="built_in">right</span> - <span class="built_in">left</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">if</span>(nums[<span class="built_in">mid</span>] == target)</span><br><span class="line">            return <span class="built_in">mid</span>; </span><br><span class="line">        else <span class="built_in">if</span> (nums[<span class="built_in">mid</span>] &lt; target)</span><br><span class="line">            <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>; // 注意</span><br><span class="line">        else <span class="built_in">if</span> (nums[<span class="built_in">mid</span>] &gt; target)</span><br><span class="line">            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>; // 注意</span><br><span class="line">    &#125;</span><br><span class="line">    return -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>tips:</p>
<p>分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。计算 mid 时需要防止溢出，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大直接相加导致溢出。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS算法解题套路框架</title>
    <url>/2020/09/14/BFS-%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree" target="_blank" rel="noopener">111.二叉树的最小深度</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算从起点 start 到终点 target 的最近距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node start, Node target)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line"></span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            Node cur = q.poll();</span><br><span class="line">            <span class="comment">/* 划重点：这里判断是否到达终点 */</span></span><br><span class="line">            <span class="keyword">if</span> (cur is target)</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj())</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 划重点：更新步数在这里 */</span></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tips:</p>
<p>BFS 的核心思想就是把一些问题抽象成图，从一个点开始，向四周开始扩散。<strong>问题的本质就是让你在一幅「图」中找到从起点</strong> <strong><code>start</code></strong> <strong>到终点</strong> <strong><code>target</code></strong> <strong>的最近距离</strong>。一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。</p>
<p>BFS 相对 DFS 的最主要的区别是：<strong>BFS 找到的路径一定是最短的，但代价就是空间复杂度比 DFS 大很多</strong></p>
<p>双向 BFS 优化，传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法解题套路框架</title>
    <url>/2020/09/14/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E5%A5%97%E8%B7%AF%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">if</span> 满足结束条件:</span></span><br><span class="line"><span class="function">        result.<span class="title">add</span><span class="params">(路径)</span></span></span><br><span class="line"><span class="function">        return</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> 选择 in 选择列表:</span></span><br><span class="line"><span class="function">        做选择</span></span><br><span class="line"><span class="function">        <span class="title">backtrack</span><span class="params">(路径, 选择列表)</span></span></span><br><span class="line"><span class="function">        撤销选择</span></span><br></pre></td></tr></table></figure>
<p>tips:</p>
<p>解决一个回溯问题，实际上就是一个决策树的遍历过程</p>
<p>需要思考 3 个问题：</p>
<p>1、路径：也就是已经做出的选择。</p>
<p>2、选择列表：也就是你当前可以做的选择。</p>
<p>3、结束条件：也就是到达决策树底层，无法再做选择的条件。</p>
<p><strong>其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Integer用==还是equals</title>
    <url>/2020/09/03/Integer%E7%94%A8-%E8%BF%98%E6%98%AFequals/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天刷minimum-window-substring问题时，写的代码跑通了267/268的测试用例，最后一个没跑通，最后发现是</p>
<p><code>window.get(d) == need.get(d)</code>出的问题，两个值都是371但是结果是false，然后才想起来Interger底部是有缓存的，关系如下：</p>
<p>Integer与int类型的关系，可以简单的回答，Integer是int的包装类，int的默认值是0，而Integer的默认值是null（jdk1.5的新特性 自动装箱和拆箱，Integer.valueOf（） 和xx.intValue（） ）,需要注意的是Integer里面默认的缓存数字是<code>-128-127</code>。</p>
<p>1、Integer与Integer相互比较，数据在<code>-128-127</code>范围内，就会从缓存中拿去数据，比较就相等；如果不在这个范围，就会直接新创建一个Integer对象，使用 == 判断的是两个内存的应用地址，所以自然不相等，应该用equals来判断值是否想等</p>
<p>2、Integer和int类型相比，在jdk1.5,会自动拆箱，然后比较栈内存中的数据，所以没有不想等的情况</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划解题套路框架</title>
    <url>/2020/08/31/%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 初始化 base case</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"># 进行状态转移</span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> in 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> in 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2</span>...)</span><br></pre></td></tr></table></figure>
<p>tips:</p>
<p>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</p>
<p>通过「备忘录」或者「dp table」的方法来优化递归树</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历</title>
    <url>/2020/08/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>二叉树的先序、中序、后序遍历</p>
<a id="more"></a>
<p><strong>树节点：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">//左子树</span></span><br><span class="line">    TreeNode left;</span><br><span class="line">    <span class="comment">//右子树</span></span><br><span class="line">    TreeNode right;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/treeNode.png"></p>
<blockquote>
<p>先序：1 2 4 6 7 8 3 5<br>中序：4 7 6 8 2 1 3 5<br>后序：7 8 6 4 2 5 3 1</p>
</blockquote>
<p><strong>先序：</strong>考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)</p>
<p><strong>中序：</strong>考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)</p>
<p><strong>后序：</strong>考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)</p>
<h4 id="递归先序遍历"><a href="#递归先序遍历" class="headerlink" title="递归先序遍历"></a>递归先序遍历</h4><p>递归先序遍历很容易理解，先输出节点的值，再递归遍历左右子树。中序和后序的递归类似，改变根节点输出位置即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursionPreorderTraversal</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.print(root.val + <span class="string">" "</span>);</span><br><span class="line">        recursionPreorderTraversal(root.left);</span><br><span class="line">        recursionPreorderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h4><p>因为要在遍历完节点的左子树后接着遍历节点的右子树，为了能找到该节点，需要使用<strong>栈</strong>来进行暂存。中序和后序也都涉及到回溯，所以都需要用到<strong>栈</strong>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 用来暂存节点的栈</span></span><br><span class="line">    Stack&lt;TreeNode&gt; treeNodeStack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    <span class="comment">// 新建一个游标节点为根节点</span></span><br><span class="line">    TreeNode node = root;</span><br><span class="line">    <span class="comment">// 当遍历到最后一个节点的时候，无论它的左右子树都为空，并且栈也为空</span></span><br><span class="line">    <span class="comment">// 所以，只要不同时满足这两点，都需要进入循环</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span> || !treeNodeStack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 若当前考查节点非空，则输出该节点的值</span></span><br><span class="line">        <span class="comment">// 由考查顺序得知，需要一直往左走</span></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.print(node.val + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">// 为了之后能找到该节点的右子树，暂存该节点</span></span><br><span class="line">            treeNodeStack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一直到左子树为空，则开始考虑右子树</span></span><br><span class="line">        <span class="comment">// 如果栈已空，就不需要再考虑</span></span><br><span class="line">        <span class="comment">// 弹出栈顶元素，将游标等于该节点的右子树</span></span><br><span class="line">        <span class="keyword">if</span> (!treeNodeStack.isEmpty()) &#123;</span><br><span class="line">            node = treeNodeStack.pop();</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归先序遍历： 1 2 4 6 7 8 3 5<br>非递归先序遍历：1 2 4 6 7 8 3 5</p>
</blockquote>
<h4 id="递归中序遍历"><a href="#递归中序遍历" class="headerlink" title="递归中序遍历"></a>递归中序遍历</h4><p>过程和递归先序遍历类似</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursionMiddleorderTraversal</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        recursionMiddleorderTraversal(root.left);</span><br><span class="line">        System.<span class="keyword">out</span>.print(root.val + <span class="string">" "</span>);</span><br><span class="line">        recursionMiddleorderTraversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h4><p>和非递归先序遍历类似，唯一区别是考查到当前节点时，并不直接输出该节点。</p>
<p>而是当考查节点为空时，从栈中弹出的时候再进行输出(永远先考虑左子树，直到左子树为空才访问根节点)。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">middleorderTraversal</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; treeNodeStack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode node = root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span> || !treeNodeStack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            treeNodeStack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!treeNodeStack.isEmpty()) &#123;</span><br><span class="line">            node = treeNodeStack.pop();</span><br><span class="line">            System.<span class="keyword">out</span>.print(node.val + <span class="string">" "</span>);</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归中序遍历： 4 7 6 8 2 1 3 5<br>非递归中序遍历：4 7 6 8 2 1 3 5</p>
</blockquote>
<h4 id="递归后序遍历"><a href="#递归后序遍历" class="headerlink" title="递归后序遍历"></a>递归后序遍历</h4><p>过程和递归先序遍历类似</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursionPostorderTraversal</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        recursionPostorderTraversal(root.left);</span><br><span class="line">        recursionPostorderTraversal(root.right);</span><br><span class="line">        System.<span class="keyword">out</span>.print(root.val + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h4><p>后续遍历和先序、中序遍历不太一样。</p>
<p>后序遍历在决定是否可以输出当前节点的值的时候，需要考虑其左右子树是否都已经遍历完成。</p>
<p>所以需要设置一个<strong>lastVisit游标</strong>。</p>
<p>若lastVisit等于当前考查节点的右子树，表示该节点的左右子树都已经遍历完成，则可以输出当前节点。</p>
<p>并把lastVisit节点设置成当前节点，将当前游标节点node设置为空，下一轮就可以访问栈顶元素。</p>
<p><strong>否者，需要接着考虑右子树，node = node.right。</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postorderTraversal</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; treeNodeStack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode node = root;</span><br><span class="line">    TreeNode lastVisit = root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span> || !treeNodeStack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            treeNodeStack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看当前栈顶元素</span></span><br><span class="line">        node = treeNodeStack.peek();</span><br><span class="line">        <span class="comment">//如果其右子树也为空，或者右子树已经访问</span></span><br><span class="line">        <span class="comment">//则可以直接输出当前节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="literal">null</span> || node.right == lastVisit) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.print(node.val + <span class="string">" "</span>);</span><br><span class="line">            treeNodeStack.pop();</span><br><span class="line">            lastVisit = node;</span><br><span class="line">            node = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则，继续遍历右子树</span></span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归后序遍历： 7 8 6 4 2 5 3 1<br>非递归后序遍历：7 8 6 4 2 5 3 1</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo g 生成空白文件问题</title>
    <url>/2020/08/16/hexo-g-%E7%94%9F%E6%88%90%E7%A9%BA%E7%99%BD%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>最近换了新电脑，重新整环境的时候图快，下载<code>node</code>的时候下载的是最新版：node当前版14.0.0。然后安装<code>hexo</code>，从github拉取hexo博客项目，然后跑<code>npm install</code>，都没啥问题。但是在项目下面执行任何<code>hexo</code>的命令的时候，就会出现一个错误：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">node</span><span class="title">:62227</span>) Warning: Accessing non-existent <span class="keyword">property</span><span class="title"> </span>'lineno' of module exports inside circular dependency</span><br><span class="line">(Use `<span class="keyword">node</span> <span class="title">--trace-warnings</span> ...` to show where the warning was created)</span><br><span class="line">(<span class="keyword">node</span><span class="title">:62227</span>) Warning: Accessing non-existent <span class="keyword">property</span><span class="title"> </span>'column' of module exports inside circular dependency</span><br><span class="line">(<span class="keyword">node</span><span class="title">:62227</span>) Warning: Accessing non-existent <span class="keyword">property</span><span class="title"> </span>'filename' of module exports inside circular dependency</span><br><span class="line">(<span class="keyword">node</span><span class="title">:62227</span>) Warning: Accessing non-existent <span class="keyword">property</span><span class="title"> </span>'lineno' of module exports inside circular dependency</span><br><span class="line">(<span class="keyword">node</span><span class="title">:62227</span>) Warning: Accessing non-existent <span class="keyword">property</span><span class="title"> </span>'column' of module exports inside circular dependency</span><br><span class="line">(<span class="keyword">node</span><span class="title">:62227</span>) Warning: Accessing non-existent <span class="keyword">property</span><span class="title"> </span>'filename' of module exports inside circular dependency</span><br><span class="line">(<span class="keyword">node</span><span class="title">:62227</span>) Warning: Accessing non-existent <span class="keyword">property</span><span class="title"> </span>'lineno' of module exports inside circular dependency</span><br><span class="line">(<span class="keyword">node</span><span class="title">:62227</span>) Warning: Accessing non-existent <span class="keyword">property</span><span class="title"> </span>'column' of module exports inside circular dependency</span><br><span class="line">(<span class="keyword">node</span><span class="title">:62227</span>) Warning: Accessing non-existent <span class="keyword">property</span><span class="title"> </span>'filename' of module exports inside circular dependency</span><br><span class="line">(<span class="keyword">node</span><span class="title">:62227</span>) Warning: Accessing non-existent <span class="keyword">property</span><span class="title"> </span>'lineno' of module exports inside circular dependency</span><br><span class="line">(<span class="keyword">node</span><span class="title">:62227</span>) Warning: Accessing non-existent <span class="keyword">property</span><span class="title"> </span>'column' of module exports inside circular dependency</span><br><span class="line">(<span class="keyword">node</span><span class="title">:62227</span>) Warning: Accessing non-existent <span class="keyword">property</span><span class="title"> </span>'filename' of module exports inside circular dependency</span><br></pre></td></tr></table></figure>
<p>继续跑<code>hexo s</code>、<code>hexo clean</code>、<code>hexo g</code>都是可以的，也没报错。</p>
<p>当我跑<code>hexo s</code>的时候是可以正常预览的。</p>
<p>但是当我跑<code>hexo g</code>的时候，命令可以跑而且没报错，但是生成的文件是<code>0kb</code>的，<code>/public/index.html</code>里面没有任何内容。</p>
<p>找了好久原因，发现是node版本的问题。</p>
<p>下<code>n</code>来管理node的版本。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">npm</span> i -g n</span><br></pre></td></tr></table></figure>
<p>然后将node替换为稳定版：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo n stable</span><br></pre></td></tr></table></figure>
<p>然后查看node的版本：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">-v</span></span><br><span class="line">v12.<span class="number">18.3</span></span><br></pre></td></tr></table></figure>
<p>先清理，然后再生成：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo clean</span><br><span class="line"><span class="variable">$ </span>hexo g</span><br></pre></td></tr></table></figure>
<p>然后产看生成的<code>public</code>文件夹中<code>index.html</code>的大小，是有内容的。正常生成了 -。-</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex页面刷新数据丢失的解决办法</title>
    <url>/2020/08/15/vuex%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>在vue项目中用vuex来做全局的状态管理， 发现当刷新网页后，保存在vuex实例store里的数据会丢失。</p>
<p><strong>原因：</strong></p>
<p>因为store里的数据是保存在运行内存中的,当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化</p>
<a id="more"></a>
<p><strong>解决思路：</strong></p>
<p>将state的数据保存在localstorage、sessionstorage或cookie中，这样即可保证页面刷新数据不丢失且易于读取。</p>
<ol>
<li>localStorage: localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。</li>
<li>sessionStorage:sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。</li>
<li>cookie:cookie生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 存放数据大小为4K左右,有个数限制（各浏览器不同），一般不能超过20个。缺点是不能储存大数据且不易读取。</li>
</ol>
<p>由于vue是单页面应用，操作都是在一个页面跳转路由，因此sessionStorage较为合适,原因如下：</p>
<ol>
<li>sessionStorage可以保证打开页面时sessionStorage的数据为空；</li>
<li>每次打开页面localStorage存储着上一次打开页面的数据，因此需要清空之前的数据。</li>
</ol>
<p>vuex中state数据的修改必须通过mutation方法进行修改，因此mutation修改state的同时需要修改sessionstorage,问题倒是可以解决但是感觉很麻烦，state中有很多数据，很多mutation修改state就要很多次sessionstorage进行修改，既然如此直接用sessionstorage解决不就行了，为何还要用vuex多此一举呢？ vuex的数据在每次页面刷新时丢失，是否可以在页面刷新前再将数据存储到sessionstorage中呢，是可以的，<a href="https://www.w3cschool.cn/fetch_api/fetch_api-9vhu2oq0.html" target="_blank" rel="noopener">beforeunload</a>事件可以在页面刷新前触发，但是在每个页面中监听beforeunload事件感觉也不太合适，那么最好的监听该事件的地方就在app.vue中。</p>
<ol>
<li>在app.vue的created方法中读取sessionstorage中的数据存储在store中，此时用vuex.store的<a href="https://vuex.vuejs.org/zh/api/#replacestate" target="_blank" rel="noopener">replaceState</a>方法，替换store的根状态</li>
<li>在beforeunload方法中将store.state存储到sessionstorage中。</li>
</ol>
<p><strong>代码如下：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'App'</span>,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="comment">//在页面加载时读取sessionStorage里的状态信息</span></span><br><span class="line">    <span class="keyword">if</span> (sessionStorage.getItem(<span class="string">"store"</span>) ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$store.replaceState(<span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.$store.state,<span class="built_in">JSON</span>.parse(sessionStorage.getItem(<span class="string">"store"</span>))))</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//在页面刷新时将vuex里的信息保存到sessionStorage里</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">"beforeunload"</span>,()=&gt;&#123;</span><br><span class="line">        sessionStorage.setItem(<span class="string">"store"</span>,<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.$store.state))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex防抖节流</title>
    <url>/2020/08/15/vuex%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>在一个电影项目中，我想在电影的列表中，保存下拉的当前位置，防止你切换页面后，再切换回当前的电影列表页，他就又回到电影的第一条数据。<br>这时候，我不想每次只要滑动一点，就保存当前位置，我想隔一段时间，保存一次，这时候，就可以使用防抖和节流。</p>
<a id="more"></a>
<p>说白了，<strong>防抖节流就是使用定时器</strong>来实现我们的目的。</p>
<p><strong>防抖(debounce)：</strong></p>
<p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p>
<blockquote>
<p>典型的案例就是输入框搜索：输入结束后n秒才进行搜索请求，n秒内又输入的内容，则重新计时。</p>
</blockquote>
<p><strong>节流(throttle)：</strong></p>
<p>规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。</p>
<blockquote>
<p>典型的案例就是鼠标不断点击触发，规定在n秒内多次点击只生效一次。</p>
</blockquote>
<h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖(debounce)"></a>防抖(debounce)</h2><p><strong>下拉列表，隔一段时间保存当前下拉位置。</strong></p>
<p>我们可以在<code>mounted</code>钩子中实现我们的防抖：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防抖  定时器</span></span><br><span class="line"><span class="keyword">let</span> timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//list就是电影列表	ref="list"	$el获取DOM元素</span></span><br><span class="line"><span class="keyword">this</span>.$refs.list.$el.addEventListener(<span class="string">"scroll"</span>, e =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"----&gt;"</span>,e.target.scrollTop)	<span class="comment">//不使用防抖</span></span><br><span class="line">	<span class="keyword">if</span> (timer) &#123;</span><br><span class="line">		<span class="comment">//清空timer</span></span><br><span class="line">		clearTimeout(timer);</span><br><span class="line">	&#125;</span><br><span class="line">	timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(e.target.scrollTop)	<span class="comment">//使用防抖</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//在sessionStorage中保存当前下拉位置</span></span><br><span class="line">		<span class="comment">// sessionStorage.setItem("position", e.target.scrollTop);</span></span><br><span class="line">	&#125;, <span class="number">75</span>);		<span class="comment">//75ms为最佳</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>输入框搜索隔段时间进行搜索请求：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> @<span class="attr">keyup</span>=<span class="string">"debounce"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">//定义 timer</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> timer;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="actionscript">    debounce: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      if (timer) &#123;</span><br><span class="line">        clearTimeout(timer);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"防抖..."</span>);</span></span><br><span class="line"><span class="actionscript">        timer = <span class="literal">undefined</span>;</span></span><br><span class="line">      &#125;, 2000);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流(throttle)"></a>节流(throttle)</h2><p><strong>在n秒内点击多次，只有一次生效。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"throttle"</span>&gt;按钮&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/定义</span></span><br><span class="line"><span class="regexp">let timer, lastTime;</span></span><br><span class="line"><span class="regexp">let now = +new Date();</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    throttle: () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      if (lastTime &amp;&amp; now - lastTime &lt; 200) &#123;</span></span><br><span class="line"><span class="regexp">        clearTimeout(timer);</span></span><br><span class="line"><span class="regexp">        console.log("....");</span></span><br><span class="line"><span class="regexp">        timer = setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          console.log("点击...");</span></span><br><span class="line"><span class="regexp">          lastTime = +new Date();</span></span><br><span class="line"><span class="regexp">        &#125;, 2000);</span></span><br><span class="line"><span class="regexp">      &#125; else &#123;</span></span><br><span class="line"><span class="regexp">        lastTime = now;</span></span><br><span class="line"><span class="regexp">        timer = setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          console.log("点击...");</span></span><br><span class="line"><span class="regexp">          lastTime = +new Date();</span></span><br><span class="line"><span class="regexp">        &#125;, 200);</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>当然，也可以对这两个方法进行封装，以便在多处使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 函数防抖 (只执行最后一次点击)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Debounce = <span class="function">(<span class="params">fn, t</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> delay = t || <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(timer)&#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数节流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Throttle = <span class="function">(<span class="params">fn, t</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> last;</span><br><span class="line">    <span class="keyword">let</span> timer;</span><br><span class="line">    <span class="keyword">let</span> interval = t || <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">if</span> (last &amp;&amp; now - last &lt; interval) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                last = now;</span><br><span class="line">                fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;, interval);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = now;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习笔记</title>
    <url>/2020/03/02/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>​                动词            形容词1            形容词2                名词</p>
<p>一般现在时        ます            い                です                です</p>
<p>过去时            ました            かった            でした                でした</p>
<p>否定            ません            くないです        くありません            では　ありません</p>
<p>过去否定            ませんでした        くなかったです    くありませんでした    では　ありませんでした</p>
<a id="more"></a>
<p>ます　是基本，过去就变ました　否定就变ません　过去否定就合起来ませんでした</p>
<p>い　是基本，过去就把い变成かったです　　否定就变ないです　过去否定就合起来，なかったです</p>
<p>です是基本，过去就把です变でした、 否定就变では　ありません　过去否定就合起来では　ありませんでした</p>
<p>现在        た型        ない型        なかった型</p>
<p>字典型        いく</p>
<p>过去        いった</p>
<p>否定        いかない</p>
<p>过去否定        いかなかった</p>
<p>形容词和名词的简体变型，有です的去掉です，ありません变成ない ました变た型</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务通讯</title>
    <url>/2020/01/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h4 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a><strong>什么是微服务</strong></h4><ul>
<li>微服务架构是一个分布式系统, 按照业务进行划分成为不同的服务单元, 解决单体系统性能等不足。</li>
<li>微服务是一种架构风格，一个大型软件应用由多个服务单元组成。系统中的服务单元可以单独部署，各个服务单元之间是松耦合的。</li>
</ul>
<a id="more"></a>
<h4 id="REST-HTTP-协议"><a href="#REST-HTTP-协议" class="headerlink" title="REST HTTP 协议"></a><strong>REST HTTP 协议</strong></h4><p>REST 请求在微服务中是最为常用的一种通讯方式, 它依赖于 HTTP\HTTPS 协议。RESTFUL 的特点是：</p>
<ol>
<li>每一个 URI 代表 1 种资源</li>
<li>客户端使用 GET、POST、PUT、DELETE 4 个表示操作方式的动词对服务端资源进行操作: GET 用来获取资源, POST 用来新建资源(也可以用于更新资源), PUT 用来更新资源, DELETE 用来删除资源</li>
<li>通过操作资源的表现形式来操作资源</li>
<li>资源的表现形式是 XML 或者 HTML</li>
<li>客户端与服务端之间的交互在请求之间是无状态的,从客户端到服务端的每个请求都必须包含理解请求所必需的信息</li>
</ol>
<p>举个例子，有一个服务方提供了如下接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/communication"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestControllerDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">s</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一个服务需要去调用该接口，调用方只需要根据 API 文档发送请求即可获取返回结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/demo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestDemo</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">s2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String forObject = restTemplate.getForObject(<span class="string">"http://localhost:8080/communication/hello"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> forObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这样的方式可以实现服务之间的通讯。</p>
<h4 id="RPC-TCP协议"><a href="#RPC-TCP协议" class="headerlink" title="RPC TCP协议"></a>RPC TCP协议</h4><p>RPC(Remote Procedure Call)远程过程调用，简单的理解是一个节点请求另一个节点提供的服务。它的工作流程是这样的：</p>
<ol>
<li>执行客户端调用语句，传送参数</li>
<li>调用本地系统发送网络消息</li>
<li>消息传送到远程主机</li>
<li>服务器得到消息并取得参数</li>
<li>根据调用请求以及参数执行远程过程（服务）</li>
<li>执行过程完毕，将结果返回服务器句柄</li>
<li>服务器句柄返回结果，调用远程主机的系统网络服务发送结果</li>
<li>消息传回本地主机</li>
<li>客户端句柄由本地主机的网络服务接收消息</li>
<li>客户端接收到调用语句返回的结果数据</li>
</ol>
<p>举个例子。</p>
<p>首先需要一个服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC 服务端用来注册远程方法的接口和实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Class&gt; serviceRegister = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> impl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class service, Class impl)</span> </span>&#123;</span><br><span class="line">        serviceRegister.put(service.getSimpleName(), impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">            socket.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">            System.out.println(<span class="string">"服务启动"</span>);</span><br><span class="line">            System.out.println(serviceRegister);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                executor.execute(<span class="keyword">new</span> Task(socket.accept()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Socket client = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(Socket client)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.client = client;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectInputStream input = <span class="keyword">null</span>;</span><br><span class="line">            ObjectOutputStream output = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                input = <span class="keyword">new</span> ObjectInputStream(client.getInputStream());</span><br><span class="line">                <span class="comment">// 按照顺序读取对方写过来的内容</span></span><br><span class="line">                String serviceName = input.readUTF();</span><br><span class="line">                String methodName = input.readUTF();</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject();</span><br><span class="line">                Object[] arguments = (Object[]) input.readObject();</span><br><span class="line">                Class serviceClass = serviceRegister.get(serviceName);</span><br><span class="line">                <span class="keyword">if</span> (serviceClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(serviceName + <span class="string">" 没有找到!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Method method = serviceClass.getMethod(methodName, parameterTypes);</span><br><span class="line">                Object result = method.invoke(serviceClass.newInstance(), arguments);</span><br><span class="line"></span><br><span class="line">                output = <span class="keyword">new</span> ObjectOutputStream(client.getOutputStream());</span><br><span class="line">                output.writeObject(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这里就不写 output!=null才关闭这个逻辑了</span></span><br><span class="line">                    output.close();</span><br><span class="line">                    input.close();</span><br><span class="line">                    client.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次需要一个客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCclient</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过动态代理将参数发送过去到 RPCServer ,RPCserver 返回结果这个方法处理成为正确的实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getRemoteProxyObj</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service, <span class="keyword">final</span> InetSocketAddress addr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;service&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">                Socket socket = <span class="keyword">null</span>;</span><br><span class="line">                ObjectOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">                ObjectInputStream input = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket = <span class="keyword">new</span> Socket();</span><br><span class="line">                    socket.connect(addr);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将实体类,参数,发送给远程调用方</span></span><br><span class="line">                    out = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">                    out.writeUTF(service.getSimpleName());</span><br><span class="line">                    out.writeUTF(method.getName());</span><br><span class="line">                    out.writeObject(method.getParameterTypes());</span><br><span class="line">                    out.writeObject(args);</span><br><span class="line"></span><br><span class="line">                    input = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">                    <span class="keyword">return</span> input.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    out.close();</span><br><span class="line">                    input.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来一个测试的远程方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tinterface</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TinterfaceImpl</span> <span class="keyword">implements</span> <span class="title">Tinterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"send message "</span> + msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.huifer.admin.rpc.Tinterface;</span><br><span class="line"><span class="keyword">import</span> com.huifer.admin.rpc.TinterfaceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                RPCServer rpcServer = <span class="keyword">new</span> RPCServer();</span><br><span class="line">                rpcServer.register(Tinterface<span class="class">.<span class="keyword">class</span>, <span class="title">TinterfaceImpl</span>.<span class="title">class</span>)</span>;</span><br><span class="line">                rpcServer.start(<span class="number">9090</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        Tinterface tinterface = RPCclient.getRemoteProxyObj(Tinterface.class, new InetSocketAddress("localhost", 9090));</span><br><span class="line">        System.out.println(tinterface.send(<span class="string">"rpc 测试用例"</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出 send message rpc 测试用例。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>@Async异步调用实践</title>
    <url>/2020/01/02/Async%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>异步调用对应的是同步调用，同步调用可以理解为按照定义的顺序依次执行，有序性；异步调用在执行的时候不需要等待上一个指令调用结束就可以继续执行。</p>
<p>我们将在创建一个 Spring Boot 工程来说明。具体工程可以参考github代码 <a href="https://github.com/JustDoItLee/demo/tree/master/demo/async" target="_blank" rel="noopener">github</a></p>
<a id="more"></a>
<p>pom 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.demo.async<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- logback --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-access<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>启动类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AsyncApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.async.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@classname</span>: AsyncExecutorConfig</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Ricardo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-01-02 15:22</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncExecutorConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the ThreadPoolExecutor's core pool size.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> corePoolSize = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the ThreadPoolExecutor's maximum pool size.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPoolSize = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the capacity for the ThreadPoolExecutor's BlockingQueue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queueCapacity = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String threadNamePrefix = <span class="string">"AsyncExecutor-"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        executor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rejection-policy：当pool已经达到max size的时候，如何处理新任务</span></span><br><span class="line">        <span class="comment">// CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中我们通过 ThreadPoolTaskExecutor 创建了一个线程池。参数含义如下所示：</p>
<ul>
<li>corePoolSize：线程池创建的核心线程数</li>
<li>maxPoolSize：线程池最大线程池数量，当任务数超过corePoolSize以及缓冲队列也满了以后才会申请的线程数量。</li>
<li>setKeepAliveSeconds： 允许线程空闲时间60秒，当maxPoolSize的线程在空闲时间到达的时候销毁。</li>
<li>ThreadNamePrefix：线程的前缀任务名字。</li>
<li>RejectedExecutionHandler：当线程池没有处理能力的时候，该策略会直接在 execute 方法的调用线程中运行被拒绝的任务；如果执行程序已关闭，则会丢弃该任务</li>
</ul>
<p> 使用实战</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.async.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.async.task.AsyncTask;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@classname</span>: OrderService</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Ricardo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-01-02 15:24</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncTask asyncTask;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doShop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            createOrder();</span><br><span class="line">            <span class="comment">// 调用有结果返回的异步任务</span></span><br><span class="line">            Future&lt;String&gt; pay = asyncTask.pay();</span><br><span class="line">            <span class="keyword">if</span> (pay.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String result = pay.get();</span><br><span class="line">                    log.info(<span class="string">"异步任务返回结果&#123;&#125;"</span>, result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                asyncTask.vip();</span><br><span class="line">                asyncTask.sendSms();</span><br><span class="line">            &#125;</span><br><span class="line">            otherJob();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">"异常"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"开始做任务1：下单成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误使用，不会异步执行：调用方与被调方不能在同一个类。主要是使用了动态代理，同一个类的时候直接调用，不是通过生成的动态代理类调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">otherJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"开始做任务4：物流"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">"完成任务4，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步任务服务类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.async.task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@classname</span>: AsyncTask</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Ricardo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-01-02 15:25</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"开始做任务2：发送短信"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">"完成任务1，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">pay</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"开始做异步返回结果任务2：支付"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">"完成任务2，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"会员服务完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回结果的异步调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vip</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"开始做任务5：会员"</span>);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Thread.sleep(random.nextInt(<span class="number">10000</span>));</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        log.info(<span class="string">"开始做异步返回结果任务5，耗时："</span> + (end - start) + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单元测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.async;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.demo.async.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= AsyncApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AsyncApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        orderService.doShop();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">2020<span class="selector-tag">-01-02</span> 15<span class="selector-pseudo">:28</span><span class="selector-pseudo">:52.392</span>  <span class="selector-tag">INFO</span> 35807 <span class="selector-tag">---</span> <span class="selector-attr">[           main]</span> <span class="selector-tag">com</span><span class="selector-class">.demo</span><span class="selector-class">.async</span><span class="selector-class">.service</span><span class="selector-class">.OrderService</span>      : 开始做任务1：下单成功</span><br><span class="line">2020<span class="selector-tag">-01-02</span> 15<span class="selector-pseudo">:28</span><span class="selector-pseudo">:52.399</span>  <span class="selector-tag">INFO</span> 35807 <span class="selector-tag">---</span> <span class="selector-attr">[           main]</span> <span class="selector-tag">com</span><span class="selector-class">.demo</span><span class="selector-class">.async</span><span class="selector-class">.service</span><span class="selector-class">.OrderService</span>      : 开始做任务4：物流</span><br><span class="line">2020<span class="selector-tag">-01-02</span> 15<span class="selector-pseudo">:28</span><span class="selector-pseudo">:52.404</span>  <span class="selector-tag">INFO</span> 35807 <span class="selector-tag">---</span> <span class="selector-attr">[AsyncExecutor-1]</span> <span class="selector-tag">com</span><span class="selector-class">.demo</span><span class="selector-class">.async</span><span class="selector-class">.task</span><span class="selector-class">.AsyncTask</span>            : 开始做异步返回结果任务2：支付</span><br><span class="line">2020<span class="selector-tag">-01-02</span> 15<span class="selector-pseudo">:28</span><span class="selector-pseudo">:53.420</span>  <span class="selector-tag">INFO</span> 35807 <span class="selector-tag">---</span> <span class="selector-attr">[           main]</span> <span class="selector-tag">com</span><span class="selector-class">.demo</span><span class="selector-class">.async</span><span class="selector-class">.service</span><span class="selector-class">.OrderService</span>      : 完成任务4，耗时：1020毫秒</span><br><span class="line">2020<span class="selector-tag">-01-02</span> 15<span class="selector-pseudo">:28</span><span class="selector-pseudo">:55.495</span>  <span class="selector-tag">INFO</span> 35807 <span class="selector-tag">---</span> <span class="selector-attr">[AsyncExecutor-1]</span> <span class="selector-tag">com</span><span class="selector-class">.demo</span><span class="selector-class">.async</span><span class="selector-class">.task</span><span class="selector-class">.AsyncTask</span>            : 完成任务2，耗时：3091毫秒</span><br></pre></td></tr></table></figure>
<p>可以看到有的线程的名字就是我们线程池定义的前缀，说明使用了线程池异步执行。其中我们示范了一个错误的使用案例 <strong>otherJob()</strong>，并没有异步执行。</p>
<p>原因：</p>
<p><strong>spring 在扫描bean的时候会扫描方法上是否包含@Async注解，如果包含，spring会为这个bean动态地生成一个子类（即代理类，proxy），代理类是继承原来那个bean的。此时，当这个有注解的方法被调用的时候，实际上是由代理类来调用的，代理类在调用时增加异步作用。然而，如果这个有注解的方法是被同一个类中的其他方法调用的，那么该方法的调用并没有通过代理类，而是直接通过原来的那个 bean 也就是 this. method，所以就没有增加异步作用，我们看到的现象就是@Async注解无效。</strong></p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL集群及读写分离实践</title>
    <url>/2019/12/29/PostgreSQL%E9%9B%86%E7%BE%A4%E5%8F%8A%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>为了方便，只搭建一主一从。首先准备两台服务器，信息如下：</p>
<table>
<thead>
<tr>
<th>IP</th>
<th>角色</th>
<th>端口</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.0.31</td>
<td>master</td>
<td>5432</td>
</tr>
<tr>
<td></td>
<td>pgpool-II</td>
<td>9999</td>
</tr>
<tr>
<td>192.168.0.32</td>
<td>slave</td>
<td>5432</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h2 id="一、基础环境配置"><a href="#一、基础环境配置" class="headerlink" title="一、基础环境配置"></a>一、基础环境配置</h2><ol>
<li><p>host设置</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"># 修改vi /etc/hosts, 增加以下内容</span><br><span class="line"><span class="number">192.168.0.31</span> master</span><br><span class="line"><span class="number">192.168.0.32</span> slave</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<p>PostgreSQL</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 添加源</span></span><br><span class="line">rpm -Uvh https:<span class="comment">//yum.postgresql.org/10/redhat/rhel-7-x86_64/pgdg-centos10-10-2.noarch.rpm</span></span><br><span class="line"><span class="meta"># 下载</span></span><br><span class="line">yum install postgresql10-server postgresql10</span><br><span class="line"><span class="meta"># 安装</span></span><br><span class="line">/usr/pgsql<span class="number">-10</span>/bin/postgresql<span class="number">-10</span>-setup initdb</span><br><span class="line"></span><br><span class="line"><span class="meta"># 启动</span></span><br><span class="line">systemctl enable postgresql<span class="number">-10.</span>service</span><br><span class="line">systemctl start postgresql<span class="number">-10.</span>service</span><br><span class="line"></span><br><span class="line"><span class="meta"># 验证</span></span><br><span class="line">su - postgres -c <span class="string">"psql"</span></span><br><span class="line"><span class="meta"># 出现以下信息则成功</span></span><br><span class="line">psql (<span class="number">10.0</span>)</span><br><span class="line">Type <span class="string">"help"</span> <span class="keyword">for</span> help.</span><br><span class="line">postgres=#</span><br><span class="line"></span><br><span class="line"><span class="meta"># 创建密码</span></span><br><span class="line">postgres=# \password postgres</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看路径（/var/lib/pgsql/10/data）</span></span><br><span class="line">postgres=# show data_directory;</span><br><span class="line"></span><br><span class="line"><span class="meta"># 编辑文件 (vi /var/lib/pgsql/10/data/pg_hba.conf)</span></span><br><span class="line"><span class="meta"># host all all 127.0.0.1/32 ident 修改为允许所有网络登录，并使用md5方式进行认证：</span></span><br><span class="line"><span class="meta"># host all all 0.0.0.0/0 md5</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 编辑文件 (vi /var/lib/pgsql/10/data/postgresql.conf)</span></span><br><span class="line">listen_addresses = <span class="string">'*'</span> # 表示开放外网访问</span><br><span class="line"></span><br><span class="line"><span class="meta"># 打开防火墙</span></span><br><span class="line">sudo firewall-cmd --add-service=postgresql --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br><span class="line"><span class="meta"># 重启</span></span><br><span class="line">systemctl restart postgresql<span class="number">-10.</span>service</span><br></pre></td></tr></table></figure>
<p>pgpool-II</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum <span class="keyword">install</span> <span class="keyword">http</span>://www.pgpool.net/yum/rpms/<span class="number">3.7</span>/redhat/rhel<span class="number">-7</span>-x86_64/pgpool-II-<span class="keyword">release</span><span class="number">-3.7</span><span class="number">-1.</span>noarch.rpm</span><br><span class="line">yum <span class="keyword">install</span> pgpool-II-pg10</span><br><span class="line"><span class="comment"># 可选</span></span><br><span class="line">yum <span class="keyword">install</span> pgpool-II-pg10-debuginfo</span><br><span class="line">yum <span class="keyword">install</span> pgpool-II-pg10-devel</span><br><span class="line">yum <span class="keyword">install</span> pgpool-II-pg10-extensions</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">systemctl <span class="keyword">enable</span> pgpool.service</span><br><span class="line">systemctl <span class="keyword">start</span> pgpool.service</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="二、流复制"><a href="#二、流复制" class="headerlink" title="二、流复制"></a>二、流复制</h2><ol>
<li><p>Master</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用于复制的用户</span></span><br><span class="line">su - postgres</span><br><span class="line">psql</span><br><span class="line">postgres=<span class="comment"># CREATE ROLE pgrepuser REPLICATION LOGIN PASSWORD 'pgreppass';</span></span><br><span class="line"><span class="comment"># 编辑文件 (vi /var/lib/pgsql/10/data/pg_hba.conf)</span></span><br><span class="line"><span class="comment"># host replication pgrepuser 0.0.0.0/0 md5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑文件 (vi /var/lib/pgsql/10/data/postgresql.conf),修改配置(根据实际情况填写)</span></span><br><span class="line">wal_level = hot_standby</span><br><span class="line">archive_mode = on</span><br><span class="line">max_wal_sender = 4</span><br><span class="line">wal_keep_segments = 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启数据库</span></span><br><span class="line">systemctl restart postgresql-10.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>Slave</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止服务</span></span><br><span class="line">systemctl stop postgresql-<span class="number">10</span>.service</span><br><span class="line"></span><br><span class="line">su - postgres</span><br><span class="line"><span class="comment"># 使用 pg_basebackup 生成备库</span></span><br><span class="line"><span class="comment">#1. 清空 $PGDATA 目录</span></span><br><span class="line">rm -rf /var/<span class="class"><span class="keyword">lib</span>/<span class="title">pgsql</span>/10/<span class="title">data</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pg_basebackup 命令生成备库</span></span><br><span class="line">pg_basebackup -D /var/<span class="class"><span class="keyword">lib</span>/<span class="title">pgsql</span>/10/<span class="title">data</span> -<span class="title">Fp</span> -<span class="title">Xs</span> -<span class="title">v</span> -<span class="title">P</span> -<span class="title">h</span> <span class="title">master</span> -<span class="title">U</span> <span class="title">pgrepuser</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑文件 (vi /var/lib/pgsql/10/data/postgresql.conf)</span></span><br><span class="line">hot_standby = on</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建文件 (vi /var/lib/pgsql/10/data/recovery.conf)</span></span><br><span class="line">standby_mode = <span class="string">'on'</span></span><br><span class="line">primary_conninfo = <span class="string">'host=master port=5432 user=pgrepuser password=pgreppass'</span></span><br><span class="line">trigger_file = <span class="string">'failover.now'</span></span><br><span class="line">recovery_target_timeline = <span class="string">'latest'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启数据库</span></span><br><span class="line">systemctl restart postgresql-<span class="number">10</span>.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#验证：在master新增数据slave节点可以看到数据。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="三、读写分离"><a href="#三、读写分离" class="headerlink" title="三、读写分离"></a>三、读写分离</h2><ol>
<li><p>pgpool配置</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">cd /etc/pgpool-II</span><br><span class="line">cp -pv pgpool.conf.sample-stream pgpool.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 vi pgpool.conf</span></span><br><span class="line">listen_addresses = '*'<span class="comment"># 外网访问</span></span><br><span class="line"><span class="comment"># 0为主库</span></span><br><span class="line">backend_hostname0 = '<span class="literal">master</span></span><br><span class="line">backend_port0 = <span class="number">5432</span></span><br><span class="line">backend_weight0 = <span class="number">0</span> <span class="comment"># 分配比例</span></span><br><span class="line">backend_data_directory0 = '/var/lib/pgsql/<span class="number">10</span>/data'</span><br><span class="line">backend_flag0 = 'ALLOW_TO_FAILOVER'</span><br><span class="line">backend_hostname1 = '<span class="literal">slave</span>'</span><br><span class="line">backend_port1 = <span class="number">5432</span></span><br><span class="line">backend_weight1 = <span class="number">1</span></span><br><span class="line">backend_data_directory1 = '/var/lib/pgsql/<span class="number">10</span>/data'</span><br><span class="line">backend_flag1 = 'ALLOW_TO_FAILOVER'</span><br><span class="line"><span class="comment">#hba认证</span></span><br><span class="line">enable_pool_hba = on</span><br><span class="line"><span class="comment"># 执行log</span></span><br><span class="line">log_statement = on</span><br><span class="line">log_per_node_statement = on</span><br><span class="line"><span class="comment"># 流复制</span></span><br><span class="line">sr_check_user = 'replicator' <span class="comment"># 流复制账号</span></span><br><span class="line">sr_check_password = '<span class="number">123456</span>'  <span class="comment"># 流复制密码</span></span><br><span class="line"><span class="comment"># 函数默认分发到从节点，过滤如下</span></span><br><span class="line">black_function_list = 'currval,lastval,nextval,setval,funcw_.*'</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 vi pool_hba.conf</span></span><br><span class="line">host    all         all         <span class="number">0.0</span>.<span class="number">0.0</span>/<span class="number">0</span>          md5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 vi pcp.conf</span></span><br><span class="line">pcp:e10adc3949ba59abbe56e057f20f883e <span class="comment"># 密码为123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成pool_passwd</span></span><br><span class="line">pg_md5  <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与 postgresql 用户密码一致</span></span><br><span class="line">pg_md5 -m -u postges postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动pgpool</span></span><br><span class="line"><span class="comment"># systemctl restart pgpool.service </span></span><br><span class="line">pgpool -n -d &gt; /etc/pgpool-II/pgpool.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接</span></span><br><span class="line">su - postgres</span><br><span class="line">psql postgres -h <span class="keyword">master</span> <span class="title">-p</span> <span class="number">9999</span> -U postgres</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点信息</span></span><br><span class="line"><span class="attr">postgres=</span><span class="comment"># show pool_nodes;</span></span><br><span class="line">node_id | hostname | port | status | lb_weight |  <span class="keyword">role</span>   <span class="title">| select_cnt</span> | load_balance_node | replication_delay </span><br><span class="line">---------+----------+------+--------+-----------+---------+------------+-------------------+-------------------</span><br><span class="line"><span class="number">0</span>       | <span class="keyword">master</span>   <span class="title">| 5432</span> | up     | <span class="number">0.000000</span>  | primary | <span class="number">28</span>         | <span class="literal">false</span>             | <span class="number">0</span></span><br><span class="line"><span class="number">1</span>       | <span class="literal">slave</span>    | <span class="number">5432</span> | up     | <span class="number">1.000000</span>  | standby | <span class="number">6</span>          | <span class="literal">true</span>              | <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line">tail -f /etc/pgpool-II/pgpool.log </span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是测试情况：</span></span><br><span class="line"><span class="comment"># select 1;</span></span><br><span class="line"><span class="number">2017</span>-<span class="number">10</span>-<span class="number">30</span> <span class="number">06</span>:<span class="number">38</span>:<span class="number">25</span>: pid <span class="number">3637</span>: LOG:  DB <span class="keyword">node</span> id:<span class="title"> 1</span> backend pid: <span class="number">3658</span> statement: select * from test where id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># update test set name = 'test' where id = 2;</span></span><br><span class="line">DB <span class="keyword">node</span> id:<span class="title"> 0</span> backend pid: <span class="number">8032</span> statement: update test set name = 'test' where id = <span class="number">2</span>;</span><br><span class="line"><span class="comment">#/*REPLICATION*/select 1; # 强制master节点执行</span></span><br><span class="line">DB <span class="keyword">node</span> id:<span class="title"> 0</span> backend pid: <span class="number">8032</span> statement: 	/*REPLICATION*/select <span class="number">1</span>;</span><br><span class="line"><span class="comment"># DB node id,0表示主节点执行，1表示从节点</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="四、错误解决"><a href="#四、错误解决" class="headerlink" title="四、错误解决"></a>四、错误解决</h2><ol>
<li><p>端口占用</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-10</span><span class="number">-30</span> <span class="number">01</span>:<span class="number">50</span>:<span class="number">21</span>: pid <span class="number">3790</span>: FATAL:  failed <span class="built_in">to</span> bind <span class="keyword">a</span> <span class="built_in">socket</span>: <span class="string">"/tmp/.s.PGSQL.9998"</span></span><br><span class="line"><span class="number">2017</span><span class="number">-10</span><span class="number">-30</span> <span class="number">01</span>:<span class="number">50</span>:<span class="number">21</span>: pid <span class="number">3790</span>: DETAIL:  bind <span class="built_in">socket</span> failed <span class="keyword">with</span> error: <span class="string">"Address already in use"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非正常结束导致的，删除以下目录即可</span></span><br><span class="line">rm -f /tmp/.s.PGSQL<span class="number">.9999</span></span><br><span class="line">rm -f /tmp/.s.PGSQL<span class="number">.9898</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="五、后续优化"><a href="#五、后续优化" class="headerlink" title="五、后续优化"></a>五、后续优化</h2><ol>
<li><p>宕机主从切换</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 vi pgpool.conf</span></span><br><span class="line"><span class="attr">follow_master_command</span> = <span class="string">'/etc/pgpool-II/failover_stream.sh'</span></span><br></pre></td></tr></table></figure>
<p>新建切换脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh </span></span><br><span class="line"><span class="comment"># Failover command for streaming replication. </span></span><br><span class="line"><span class="comment"># Arguments: $1: new master hostname. </span></span><br><span class="line"></span><br><span class="line">new_master=<span class="variable">$1</span> </span><br><span class="line">trigger_command=<span class="string">"<span class="variable">$PGHOME</span>/bin/pg_ctl promote -D <span class="variable">$PGDATA</span>"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Prompte standby database. </span></span><br><span class="line">/usr/bin/ssh -T <span class="variable">$new_master</span> <span class="variable">$trigger_command</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0;</span><br></pre></td></tr></table></figure>
</li>
<li><p>pgpool集群</p>
<p>配置虚拟ip(delegate_IP)，使用WATCHDOG监控，服务A宕机时，服务B自动接管虚拟IP对外提供服务。</p>
</li>
</ol>
<h2 id="六、基于ShardingJDBC实现读写分离"><a href="#六、基于ShardingJDBC实现读写分离" class="headerlink" title="六、基于ShardingJDBC实现读写分离"></a>六、基于ShardingJDBC实现读写分离</h2><ol>
<li><p>新建一个Spring Boot工程，添加必要的依赖，其pom.xml定义如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.demo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shardingjdbcdemo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;shardingjdbcdemo&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for ShardingJDBC Demo&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.5.7.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">        &lt;sharding-jdbc.version&gt;1.5.4.1&lt;/sharding-jdbc.version&gt;</span><br><span class="line">        &lt;mybatis-spring-boot-starter.version&gt;1.1.1&lt;/mybatis-spring-boot-starter.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--支持面向方面的编程即AOP，包括spring-aop和AspectJ--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;mybatis-spring-boot-starter.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.postgresql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 引入sharding-jdbc核心模块 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.dangdang&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;sharding-jdbc-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;sharding-jdbc.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.4&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义DataSource</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.shardingjdbc.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dangdang.ddframe.rdb.sharding.api.MasterSlaveDataSourceFactory;</span><br><span class="line"><span class="keyword">import</span> com.dangdang.ddframe.rdb.sharding.api.strategy.slave.MasterSlaveLoadBalanceStrategyType;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp.BasicDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Driver;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"shardingDataSource"</span>)</span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"spring.datasource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DataSource <span class="title">buildDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        BasicDataSource masterDataSource0 = createDataSource(<span class="string">"jdbc:postgresql://192.168.0.31:5432/master"</span>);</span><br><span class="line">        <span class="comment">// 构建读写分离数据源, 读写分离数据源实现了DataSource接口, 可直接当做数据源处理. masterDataSource0, slaveDataSource00, slaveDataSource01等为使用DBCP等连接池配置的真实数据源</span></span><br><span class="line">        Map&lt;String, DataSource&gt; slaveDataSourceMap0 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        BasicDataSource slaveDataSource00 = createDataSource(<span class="string">"jdbc:postgresql://192.168.0.31:5432/slave"</span>);</span><br><span class="line">        slaveDataSourceMap0.put(<span class="string">"slaveDataSource00"</span>, slaveDataSource00);</span><br><span class="line">        <span class="comment">// 可选择主从库负载均衡策略, 默认是ROUND_ROBIN, 还有RANDOM可以选择, 或者自定义负载策略</span></span><br><span class="line">        DataSource masterSlaveDs0 = MasterSlaveDataSourceFactory.createDataSource(<span class="string">"ms_0"</span>, <span class="string">"masterDataSource0"</span>, masterDataSource0, slaveDataSourceMap0, MasterSlaveLoadBalanceStrategyType.ROUND_ROBIN);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> masterSlaveDs0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BasicDataSource <span class="title">createDataSource</span><span class="params">(<span class="keyword">final</span> String dataSourceUrl)</span> </span>&#123;</span><br><span class="line">        BasicDataSource result = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">        result.setDriverClassName(Driver<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        result.setUrl(dataSourceUrl);</span><br><span class="line">        result.setUsername(<span class="string">"postgres"</span>);</span><br><span class="line">        result.setPassword(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>PostgreSql</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode双指针总结</title>
    <url>/2019/12/26/leetcode%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><ul>
<li><p><a href="#1-有序数组的-two-sum">1. 有序数组的 Two Sum</a></p>
</li>
<li><p><a href="#2-两数平方和">2. 两数平方和</a></p>
</li>
<li><p><a href="#3-反转字符串中的元音字符">3. 反转字符串中的元音字符</a></p>
</li>
<li><p><a href="#4-回文字符串">4. 回文字符串</a></p>
</li>
<li><p><a href="#5-归并两个有序数组">5. 归并两个有序数组</a></p>
</li>
<li><p><a href="#6-判断链表是否存在环">6. 判断链表是否存在环</a></p>
</li>
<li><p><a href="#7-最长子序列">7. 最长子序列</a></p>
</li>
</ul>
<p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。</p>
<h1 id="1-有序数组的-Two-Sum"><a href="#1-有序数组的-Two-Sum" class="headerlink" title="1. 有序数组的 Two Sum"></a>1. 有序数组的 Two Sum</h1><p>167. Two Sum II - Input array is sorted (Easy)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: numbers=&#123;2, 7, 11, 15&#125;, target=9</span><br><span class="line">Output: index1=1, index2=2</span><br></pre></td></tr></table></figure>
<p>题目描述：在有序数组中找出两个数，使它们的和为 target。</p>
<p>使用双指针，一个指针指向值较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p>
<ul>
<li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li>
<li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li>
<li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li>
</ul>
<p>数组中的元素最多遍历一次，时间复杂度为 O(N)。只使用了两个额外变量，空间复杂度为  O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numbers == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="2-两数平方和"><a href="#2-两数平方和" class="headerlink" title="2. 两数平方和"></a>2. 两数平方和</h1><p>633. Sum of Square Numbers (Easy)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: True</span><br><span class="line">Explanation: 1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure>
<p>题目描述：判断一个非负整数是否为两个整数的平方和。</p>
<p>可以看成是在元素为 0~target 的有序数组中查找两个数，使得这两个数的平方和为 target，如果能找到，则返回 true，表示 target 是两个整数的平方和。</p>
<p>本题和 167. Two Sum II - Input array is sorted 类似，只有一个明显区别：一个是和为 target，一个是平方和为 target。本题同样可以使用双指针得到两个数，使其平方和为 target。</p>
<p>本题的关键是右指针的初始化，实现剪枝，从而降低时间复杂度。设右指针为 x，左指针固定为 0，为了使 0<sup>2</sup> + x<sup>2</sup> 的值尽可能接近 target，我们可以将 x 取为 sqrt(target)。</p>
<p>因为最多只需要遍历一次 0~sqrt(target)，所以时间复杂度为 O(sqrt(target))。又因为只使用了两个额外的变量，因此空间复杂度为 O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = (<span class="keyword">int</span>) Math.sqrt(target);</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">int</span> powSum = i * i + j * j;</span><br><span class="line">        <span class="keyword">if</span> (powSum == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (powSum &gt; target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-反转字符串中的元音字符"><a href="#3-反转字符串中的元音字符" class="headerlink" title="3. 反转字符串中的元音字符"></a>3. 反转字符串中的元音字符</h1><p>345. Reverse Vowels of a String (Easy)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Given s = "leetcode", return "leotcede".</span><br></pre></td></tr></table></figure>
<p>使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。</p>
<p>为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。</p>
<ul>
<li>时间复杂度为 O(N)：只需要遍历所有元素一次</li>
<li>空间复杂度 O(1)：只需要使用两个额外变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HashSet&lt;Character&gt; vowels = <span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">        Arrays.asList(<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">char</span> ci = s.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> cj = s.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (!vowels.contains(ci)) &#123;</span><br><span class="line">            result[i++] = ci;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vowels.contains(cj)) &#123;</span><br><span class="line">            result[j--] = cj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i++] = cj;</span><br><span class="line">            result[j--] = ci;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-回文字符串"><a href="#4-回文字符串" class="headerlink" title="4. 回文字符串"></a>4. 回文字符串</h1><p>680. Valid Palindrome II (Easy)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input: "abca"</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could delete the character 'c'.</span><br></pre></td></tr></table></figure>
<p>题目描述：可以删除一个字符，判断是否能构成回文字符串。</p>
<p>所谓的回文字符串，是指具有左右对称特点的字符串，例如 “abcba” 就是一个回文字符串。</p>
<p>使用双指针可以很容易判断一个字符串是否是回文字符串：令一个指针从左到右遍历，一个指针从右到左遍历，这两个指针同时移动一个位置，每次都判断两个指针指向的字符是否相同，如果都相同，字符串才是具有左右对称性质的回文字符串。</p>
<p>本题的关键是处理删除一个字符。在使用双指针遍历字符串时，如果出现两个指针指向的字符不相等的情况，我们就试着删除一个字符，再判断删除完之后的字符串是否是回文字符串。</p>
<p>在判断是否为回文字符串时，我们不需要判断整个字符串，因为左指针左边和右指针右边的字符之前已经判断过具有对称性质，所以只需要判断中间的子字符串即可。</p>
<p>在试着删除字符时，我们既可以删除左指针指向的字符，也可以删除右指针指向的字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> isPalindrome(s, i, j - <span class="number">1</span>) || isPalindrome(s, i + <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i++) != s.charAt(j--)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-归并两个有序数组"><a href="#5-归并两个有序数组" class="headerlink" title="5. 归并两个有序数组"></a>5. 归并两个有序数组</h1><p>88. Merge Sorted Array (Easy)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<p>题目描述：把归并结果存到第一个数组上。</p>
<p>需要从尾开始遍历，否则在 nums1 上归并得到的值会覆盖还未进行归并比较的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1 = m - <span class="number">1</span>, index2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> indexMerge = m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> || index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums2[index2--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums1[index1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums1[index1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[indexMerge--] = nums2[index2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-判断链表是否存在环"><a href="#6-判断链表是否存在环" class="headerlink" title="6. 判断链表是否存在环"></a>6. 判断链表是否存在环</h1><p>141. Linked List Cycle (Easy)</p>
<p>使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode l1 = head, l2 = head.next;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span> &amp;&amp; l2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == l2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-最长子序列"><a href="#7-最长子序列" class="headerlink" title="7. 最长子序列"></a>7. 最长子序列</h1><p>524. Longest Word in Dictionary through Deleting (Medium)</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">Input:</span></span><br><span class="line">s = <span class="string">"abpcplea"</span>, d = [<span class="string">"ale"</span>,<span class="string">"apple"</span>,<span class="string">"monkey"</span>,<span class="string">"plea"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">Output:</span></span><br><span class="line"><span class="string">"apple"</span></span><br></pre></td></tr></table></figure>
<p>题目描述：删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。</p>
<p>通过删除字符串 s 中的一个字符能得到字符串 t，可以认为 t 是 s 的子序列，我们可以使用双指针来判断一个字符串是否为另一个字符串的子序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">    String longestWord = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (String target : d) &#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = longestWord.length(), l2 = target.length();</span><br><span class="line">        <span class="keyword">if</span> (l1 &gt; l2 || (l1 == l2 &amp;&amp; longestWord.compareTo(target) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isSubstr(s, target)) &#123;</span><br><span class="line">            longestWord = target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longestWord;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubstr</span><span class="params">(String s, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; target.length()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == target.charAt(j)) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j == target.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础整理</title>
    <url>/2019/12/26/Java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h4 id="1-0-JAVA中的几种基本数据类型是什么，各自占用多少字节。"><a href="#1-0-JAVA中的几种基本数据类型是什么，各自占用多少字节。" class="headerlink" title="1.0 JAVA中的几种基本数据类型是什么，各自占用多少字节。"></a>1.0 JAVA中的几种基本数据类型是什么，各自占用多少字节。</h4><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<h5 id="byte："><a href="#byte：" class="headerlink" title="byte："></a><strong>byte：</strong></h5><p>byte 数据类型是8位、有符号的，以二进制补码表示的整数；最小值是 -128（-2^7）；最大值是 127（2^7-1）；默认值是 0；byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；例子：<code>byte a = 100，byte b = -50</code>。</p>
<h5 id="short："><a href="#short：" class="headerlink" title="short："></a><strong>short：</strong></h5><p>short 数据类型是 16 位、有符号的以二进制补码表示的整数最小值是 -32768（-2^15）；最大值是 32767（2^15 - 1）；Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；默认值是 0；例子：<code>short s = 1000，short r = -20000</code>。</p>
<h5 id="int："><a href="#int：" class="headerlink" title="int："></a><strong>int：</strong></h5><p>int 数据类型是32位、有符号的以二进制补码表示的整数；最小值是 -2,147,483,648（-2^31）；最大值是 2,147,483,647（2^31 - 1）；一般地整型变量默认为 int 类型；默认值是 0 ；例子：<code>int a = 100000, int b = -200000</code>。</p>
<h5 id="long："><a href="#long：" class="headerlink" title="long："></a><strong>long：</strong></h5><p>long 数据类型是 64 位、有符号的以二进制补码表示的整数；最小值是 -9,223,372,036,854,775,808（-2^63）；最大值是 9,223,372,036,854,775,807（2^63 -1）；这种类型主要使用在需要比较大整数的系统上；默认值是 0L；例子：<code>long a = 100000L，Long b = -200000L</code>。”L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</p>
<h5 id="float："><a href="#float：" class="headerlink" title="float："></a><strong>float：</strong></h5><p>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；float 在储存大型浮点数组的时候可节省内存空间；默认值是 0.0f；浮点数不能用来表示精确的值，如货币；例子：<code>float f1 = 234.5f</code>。</p>
<h5 id="double："><a href="#double：" class="headerlink" title="double："></a><strong>double：</strong></h5><p>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；浮点数的默认类型为double类型；double类型同样不能表示精确的值，如货币；默认值是 0.0d；例子：<code>double d1 = 123.4</code>。</p>
<h5 id="boolean："><a href="#boolean：" class="headerlink" title="boolean："></a><strong>boolean：</strong></h5><p>boolean数据类型表示一位的信息；只有两个取值：true 和 false；这种类型只作为一种标志来记录 true/false 情况；默认值是 false；例子：<code>boolean one = true</code>。</p>
<h5 id="char："><a href="#char：" class="headerlink" title="char："></a><strong>char：</strong></h5><p>char类型是一个单一的 16 位 Unicode 字符；最小值是 \u0000（即为0）；最大值是 \uffff（即为65,535）；char 数据类型可以储存任何字符；例子：<code>char letter = &#39;A&#39;;</code>。</p>
<a id="more"></a>
<h4 id="1-1-String类能被继承吗，为什么。"><a href="#1-1-String类能被继承吗，为什么。" class="headerlink" title="1.1 String类能被继承吗，为什么。"></a>1.1 String类能被继承吗，为什么。</h4><p>不能</p>
<p>大白话解释就是：String很多实用的特性，比如说“不可变性”，是工程师精心设计的艺术品！艺术品易碎！用final就是拒绝继承，防止世界被熊孩子破坏，维护世界和平！</p>
<p>PS：String基本约定中最重要的一条是immutable，声明String为final 和immutable虽然没有必然关系，但是假如String没有声明为final, 那么StringChilld就有可能是被复写为mutable的，这样就打破了成为共识的基本约定。要知道，String是几乎每个类都会使用的类，特别是作为Hashmap之类的集合的key值时候，mutable的String有非常大的风险。而且一旦发生，非常难发现。声明String为final一劳永逸。</p>
<p><a href="https://javarevisited.blogspot.com/2010/10/why-string-is-immutable-or-final-in-java.html" target="_blank" rel="noopener">Why String is Immutable or Final in Java</a></p>
<h4 id="1-2-String，Stringbuffer，StringBuilder的区别。"><a href="#1-2-String，Stringbuffer，StringBuilder的区别。" class="headerlink" title="1.2 String，Stringbuffer，StringBuilder的区别。"></a>1.2 String，Stringbuffer，StringBuilder的区别。</h4><h5 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a><strong>可变性</strong></h5><p>String是不可变的，它使用final关键词修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">...................</span><br></pre></td></tr></table></figure>
<p>StringBuffer和StringBuilder两者都是继承自AbstractStringBuilder,AbstractStringBuilder也是用字符数组保存char value[]，但是没有用final修饰，所以这两种对象是可变的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">abstract</span> <span class="title">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure>
<h5 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h5><p>String的对象不可变，也就是常量，所以线程安全</p>
<p>StringBuffer重写了AbstractStringBuilder的方法，比如append、insert等并且加了同步锁，所以是线程安全的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.ensureCapacity(minimumCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>而StringBuilder就没加同步锁，所以是非线程安全的</p>
<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a><strong>性能</strong></h5><p>每次修改String的值都会重新生成一个新的String对象，然后再将指针指向新的String对象，StringBuffer和StringBuilder每次都是对象本身进行操作，而不是生成新的对象。StringBuilder的性能会比StringBuffer好一点，不过却要冒多线程不安全的风险</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><ul>
<li>数据量少多用String</li>
<li>单线程操作大量数据用StringBuilder</li>
<li>多线程操作大量数据用StringBuffer</li>
</ul>
<h4 id="1-3-ArrayList和LinkedList有什么区别。"><a href="#1-3-ArrayList和LinkedList有什么区别。" class="headerlink" title="1.3 ArrayList和LinkedList有什么区别。"></a>1.3 ArrayList和LinkedList有什么区别。</h4><p>ArrayList的实现用的是数组，LinkedList是基于链表，ArrayList适合查找，LinkedList适合增删</p>
<h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>ArrayList：内部使用数组的形式实现了存储，实现了RandomAccess接口，利用数组的下标进行元素的访问，因此对元素的随机访问速度非常快。</p>
<p>因为是数组，所以ArrayList在初始化的时候，有初始大小10，插入新元素的时候，会判断是否需要扩容，扩容的步长是0.5倍原容量，扩容方式是利用数组的复制，因此有一定的开销；</p>
<p>另外，ArrayList在进行元素插入的时候，需要移动插入位置之后的所有元素，位置越靠前，需要位移的元素越多，开销越大，相反，插入位置越靠后的话，开销就越小了，如果在最后面进行插入，那就不需要进行位移；</p>
<h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>LinkedList：内部使用双向链表的结构实现存储，LinkedList有一个内部类作为存放元素的单元，里面有三个属性，用来存放元素本身以及前后2个单元的引用，另外LinkedList内部还有一个header属性，用来标识起始位置，LinkedList的第一个单元和最后一个单元都会指向header，因此形成了一个双向的链表结构。</p>
<p>LinkedList是采用双向链表实现的。所以它也具有链表的特点，每一个元素（结点）的地址不连续，通过引用找到当前结点的上一个结点和下一个结点，即插入和删除效率较高，只需要常数时间，而get和set则较为低效。</p>
<p> LinkedList的方法和使用和ArrayList大致相同，由于LinkedList是链表实现的，所以额外提供了在头部和尾部添加/删除元素的方法，也没有ArrayList扩容的问题了。另外，ArrayList和LinkedList都可以实现栈、队列等数据结构，但LinkedList本身实现了队列的接口，所以更推荐用LinkedList来实现队列和栈。</p>
<p>综上所述，在需要频繁读取集合中的元素时，使用ArrayList效率较高，而在插入和删除操作较多时，使用LinkedList效率较高。</p>
<h4 id="1-4-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"><a href="#1-4-讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。" class="headerlink" title="1.4 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。"></a>1.4 讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序。</h4><p>初始化顺序：父类static静态变量 &gt; 父类static代码块 &gt; 子类static静态变量 &gt; 子类static代码块 &gt; 父类变量 &gt; 父类实例代码块 &gt; 父类构造函数 &gt; 子类变量 &gt; 子类实例代码块 &gt; 子类构造函数</p>
<h4 id="1-5-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。"><a href="#1-5-用过哪些Map类，都有什么区别，HashMap是线程安全的吗-并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。" class="headerlink" title="1.5 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。"></a>1.5 用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。</h4><p>最常用的Map实现类有:HashMap，ConcurrentHashMap（jdk1.8），LinkedHashMap，TreeMap,HashTable；</p>
<p>其中最频繁的是HashMap和ConcurrentHashMap，他们的主要区别是HashMap是非线程安全的。ConcurrentHashMap是线程安全的。并发下可以使用ConcurrentHashMap和HashTable</p>
<p><strong>1.HashMap</strong></p>
<ul>
<li><p>存储原理就是散列表</p>
<p>散列函数的设计不能太复杂，生成的值要尽可能随机并且均匀分布</p>
<p>HashMap使用高低16位异或对数组长度取余符合这个规则：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>散列冲突<br>HashMap使用链表解决Hash冲突，相较开放寻址法更加节约内存，而且方便通过其它数据结构进行优化，比如JDK1.8就是使用红黑树优化，防止Hash攻击。</li>
<li>动态扩容<br>HashMap的默认阈值是0.75，数组长度默认是16，以2的倍数增长，方便取余，美中不足的是，HashMap的扩容是一步到位的，虽然均摊时间复杂度不高，但是可能扩容的那次put会比较慢，可以考虑高效扩容（装载因子触达阈值时，只申请新空间，不搬运数据，之后每插入一个新数据我们从旧散列表拿一个旧数据放到新散列表，可以在新散列表到达阈值前搬运完毕，利用了扩容后装载因子减半的特性。）；</li>
</ul>
<p><strong>2.ConcurrentHashMap和hashtable的区别</strong></p>
<ul>
<li><p>ConcurrentHashMap的hash计算公式：(key.hascode()^ (key.hascode()&gt;&gt;&gt; 16)) &amp; 0x7FFFFFFF</p>
<p>HashTable的hash计算公式：key.hascode()&amp; 0x7FFFFFFF</p>
</li>
<li><p>HashTable存储方式都是链表+数组，数组里面放的是当前hash的第一个数据，链表里面放的是hash冲突的数据</p>
<p>ConcurrentHashMap是数组+链表+红黑树</p>
</li>
<li><p>默认容量都是16，负载因子是0.75。就是当hashmap填充了75%的busket是就会扩容，最小的可能性是（16*0.75），一般为原内存的2倍</p>
</li>
<li><p>线程安全的保证：HashTable是在每个操作方法上面加了synchronized来达到线程安全，ConcurrentHashMap线程是使用CAS(compore and swap)来保证线程安全的</p>
</li>
<li><p>ConcurrentHashMap内部原理</p>
<p><strong>1.7：</strong> put 加锁</p>
<p>通过分段加锁 segment，put 数据时通过 hash(key) 得到该元素要添加到的 segment，对 segment 进行加锁，进行再 hash 得到该元素要添加到的桶，遍历桶中的链表，替换或新增节点到桶中。</p>
<p><strong>1.8：</strong> put CAS 加锁</p>
<p>1.8 中仍然有 segment 的定义，但不再有任何结构上的用处，segment 数量与桶数量一致，不依赖于 segment 加锁。</p>
<p>首先，判断容器是否为空，如果为空则进行初始化，否则重试对 hash(key) 计算得到该 key 存放的桶位置，判断该桶是否为空，为空则利用 CAS 设置新节点，否则使用 synchronized 加锁，遍历桶中数据，替换或新增加节点到桶中，最后判断是否需要转为红黑树，转换之前判断是否需要扩容。</p>
</li>
</ul>
<p><strong>3.HashMap细节</strong></p>
<p>构造参数传进的初始化容量是怎么“向上取整”的？<br>通过 n |= n &gt;&gt;&gt; (1,2,4,8,16)的方式，使得低位全部填满1，最后再+1就是我们说的数组长度是2的幂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>JDK1.8，并发编程不再死循环<br>旧的HashMap扩容的时候链是反过来的，比如说本来是a-&gt;b-&gt;c，先取a放到新的数组，再取b放过去就成了b-&gt;a，加上c就是c-&gt;b-&gt;a，可以看见引用反过来了，并发编程的时候，容易造成循环引用，也就是老生常谈的死循环。<br>到了1.8就不这么干了，通过<code>(e.hash &amp; oldCap) == 0</code>去区分扩容后新节点位置可以说是非常精妙了，我是愣了一下才想明白，然后分两条链，顺序的，比如说原来时a-&gt;b-&gt;c-d，分开之后可能就变成a-&gt;c和a-&gt;d，这样依赖就不存在循环引用了，而且还最大程度维护了原来的顺序。<br>不过这个死循环BUG是因为会强占太多CPU资源被重视，而后又被妖魔化，HashMap本来就不是并发编程的容器，用在并发编程上总会有各种各样的问题，所以在这点上研究价值大于实用价值，毕竟没谁会直接在并发编程下怼一个HashMap上去吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>put()操作的伪代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>尝试用伪代码表达它的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (第一次添加元素)</span><br><span class="line">              扩容成默认的初始大小</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (如果对应坑位是<span class="keyword">null</span>)</span><br><span class="line">            直接怼上去;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (坑位上的key跟我要加进去的key相同)</span><br><span class="line">                e=那个节点;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (如果下面挂着的是一个课红黑树)</span><br><span class="line">                e = 一顿操作把修改节点返回来，如果是新插入就返回<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (循环遍历链上的节点) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (找到最后的空位<span class="keyword">null</span>) &#123;</span><br><span class="line">                        怼上去;</span><br><span class="line">                        <span class="keyword">if</span> (如果达到红黑树节点数的临界值) </span><br><span class="line">                            转换成红黑树;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (没到<span class="keyword">null</span>之前的某个节点key相同)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (如果插入节点是本来就存在的（e!=<span class="keyword">null</span>）) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                换新值</span><br><span class="line">                把旧值返回去</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        操作数+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (扩容检测)</span><br><span class="line">           扩容;</span><br><span class="line">        没有旧值返回<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"><a href="#1-6-JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。" class="headerlink" title="1.6 JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。"></a>1.6 JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。</h4><h5 id="弃用原因"><a href="#弃用原因" class="headerlink" title="弃用原因"></a><strong>弃用原因</strong></h5><p>通过  JDK 的源码和官方文档看来， 他们认为的弃用分段锁的原因由以下几点：</p>
<ol>
<li>加入多个分段锁浪费内存空间。</li>
<li>生产环境中， map 在放入时竞争同一个锁的概率非常小，分段锁反而会造成更新等操作的长时间等待。</li>
<li>为了提高 GC 的效率</li>
</ol>
<p><strong>PS：关于Segment</strong></p>
<p>ConcurrentHashMap有3个参数：</p>
<ol>
<li>initialCapacity：初始总容量，默认16</li>
<li>loadFactor：加载因子，默认0.75</li>
<li>concurrencyLevel：并发级别，默认16</li>
</ol>
<p>其中并发级别控制了Segment的个数，在一个ConcurrentHashMap创建后Segment的个数是不能变的，扩容过程过改变的是每个Segment的大小。</p>
<p><strong>PS:关于分段锁</strong></p>
<p>段Segment继承了重入锁ReentrantLock，有了锁的功能，每个锁控制的是一段，当每个Segment越来越大时，锁的粒度就变得有些大了。</p>
<ul>
<li>分段锁的优势在于保证在操作不同段 map 的时候可以并发执行，操作同段 map 的时候，进行锁的竞争和等待。这相对于直接对整个map同步synchronized是有优势的。</li>
<li>缺点在于分成很多段时会比较浪费内存空间(不连续，碎片化); 操作map时竞争同一个分段锁的概率非常小时，分段锁反而会造成更新等操作的长时间等待; 当某个段很大时，分段锁的性能会下降。</li>
</ul>
<h5 id="新的同步方案"><a href="#新的同步方案" class="headerlink" title="新的同步方案"></a><strong>新的同步方案</strong></h5><p>既然弃用了分段锁， 那么一定由新的线程安全方案， 我们来看看源码是怎么解决线程安全的呢？（源码保留了segment 代码， 但并没有使用，只是为了兼容旧版本）</p>
<p>和hashmap一样,jdk 1.8中ConcurrentHashmap采用的底层数据结构为数组+链表+红黑树的形式。数组可以扩容，链表可以转化为红黑树。</p>
<p><strong>什么时候扩容？</strong></p>
<ul>
<li>当前容量超过阈值</li>
<li>当链表中元素个数超过默认设定（8个），当数组的大小还未超过64的时候，此时进行数组的扩容，如果超过则将链表转化成红黑树</li>
</ul>
<p><strong>什么时候链表转化为红黑树？</strong></p>
<p>当数组大小已经超过64并且链表中的元素个数超过默认设定（8个）时，将链表转化为红黑树</p>
<p><strong>put</strong></p>
<p>首先通过 hash 找到对应链表过后， 查看是否是第一个object， 如果是， 直接用cas原则插入，无需加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh; K fk; V fv;</span><br><span class="line"><span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    tab = initTable(); <span class="comment">// 这里在整个map第一次操作时，初始化hash桶， 也就是一个table</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//如果是第一个object， 则直接cas放入， 不用锁</span></span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value)))</span><br><span class="line">        <span class="keyword">break</span>;                   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后， 如果不是链表第一个object， 则直接用链表第一个object加锁，这里加的锁是synchronized，虽然效率不如 ReentrantLock， 但节约了空间，这里会一直用第一个object为锁， 直到重新计算map大小， 比如扩容或者操作了第一个object为止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (f) &#123;<span class="comment">// 这里的f即为第一个链表的object</span></span><br><span class="line">    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            binCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key ||</span><br><span class="line">                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                    oldVal = e.val;</span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                        e.val = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123; <span class="comment">// 太长会用红黑树</span></span><br><span class="line">            Node&lt;K,V&gt; p;</span><br><span class="line">            binCount = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldVal = p.val;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                    p.val = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive update"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么不用ReentrantLock而用synchronized ?</strong></p>
<ul>
<li>减少内存开销:如果使用ReentrantLock则需要节点继承AQS来获得同步支持，增加内存开销，而1.8中只有头节点需要进行同步。</li>
<li>内部优化:synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。</li>
</ul>
<h4 id="1-7-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。"><a href="#1-7-有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。" class="headerlink" title="1.7 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。"></a>1.7 有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。</h4><p>TreeMap和LinkedHashMap是有序的（TreeMap默认升序，LinkedHashMap则记录了插入顺序）。</p>
<p><strong>HashMap</strong>:</p>
<p>​        put -&gt; addEntry(新建一个Entry)</p>
<p>​        get</p>
<p>​        getEntry</p>
<p><strong>LinkedHashMap</strong>:</p>
<p>​       put -&gt; addEntry(重写)</p>
<p>​                新建一个Entry,然后将其加入header前</p>
<p>​                e.addBefore(header)</p>
<p>​       get -&gt; 调用HashMap的getEntry - recordAccess(重写)</p>
<p><strong>HashMap的get与getEntry</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>LinkedHashMap概述：</li>
</ol>
<p>LinkedHashMap是HashMap的一个子类，它<strong>保留插入的顺序</strong>，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap。</p>
<p>LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并<strong>允许使用null值和null键</strong>。此类不保证映射的顺序，特别是它<strong>不保证该顺序恒久不变</strong>。<br>LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。<br>注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</p>
<p>根据链表中元素的顺序可以分为：<strong>按插入顺序的链表，和按访问顺序(调用get方法)的链表。</strong>  </p>
<p>默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。  可以重写removeEldestEntry方法返回true值指定插入元素时移除最老的元素。 </p>
<ol start="2">
<li>LinkedHashMap的实现：</li>
</ol>
<p>对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。下面我们来分析LinkedHashMap的源代码：</p>
<p><strong>类结构：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 1) 成员变量：</p>
<p>LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了数组中保存的元素Entry，该Entry除了保存当前对象的引用外，还保存了其上一个元素before和下一个元素after的引用，从而在哈希表的基础上又构成了双向链接列表。看源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//true表示按照访问顺序迭代，false时表示按照插入顺序</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 双向链表的表头元素。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; header;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * LinkedHashMap的Entry元素。 </span></span><br><span class="line"><span class="comment"> * 继承HashMap的Entry元素，又保存了其上一个元素before和下一个元素after的引用。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">    Entry&lt;K,V&gt; before, after;  </span><br><span class="line">    ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HashMap.Entry:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 2) 初始化：</p>
<p>通过源代码可以看出，在LinkedHashMap的构造方法中，实际调用了父类HashMap的相关构造方法来构造一个底层存放的table数组。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);  </span><br><span class="line">    accessOrder = <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> HashMap中的相关构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +  </span><br><span class="line">                                           initialCapacity);  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)  </span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;  </span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +  </span><br><span class="line">                                           loadFactor);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= initialCapacity  </span></span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)  </span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;  </span><br><span class="line">    threshold = (<span class="keyword">int</span>)(capacity * loadFactor);  </span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];  </span><br><span class="line">    init();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经知道LinkedHashMap的Entry元素继承HashMap的Entry，提供了双向链表的功能。在上述HashMap的构造器中，最后会调用init()方法，进行相关的初始化，这个方法在HashMap的实现中并无意义，只是提供给子类实现相关的初始化调用。   </p>
<p>LinkedHashMap重写了init()方法，在调用父类的构造方法完成构造后，进一步实现了对其元素Entry的初始化操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    header = <span class="keyword">new</span> Entry&lt;K,V&gt;(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">    header.before = header.after = header;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3) 存储：</p>
<p>LinkedHashMap并未重写父类HashMap的put方法，而是重写了父类HashMap的put方法调用的子方法void recordAccess(HashMap m)  ，void addEntry(int hash, K key, V value, int bucketIndex) 和void createEntry(int hash, K key, V value, int bucketIndex)，提供了自己特有的双向链接列表的实现。</p>
<p><strong>HashMap.put:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 重写方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">            LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;</span><br><span class="line">            <span class="keyword">if</span> (lm.accessOrder) &#123;</span><br><span class="line">                lm.modCount++;</span><br><span class="line">                remove();</span><br><span class="line">                addBefore(lm.header);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 调用create方法，将新元素以双向链表的的形式加入到映射中。  </span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 删除最近最少使用元素的策略定义  </span></span><br><span class="line">    Entry&lt;K,V&gt; eldest = header.after;  </span><br><span class="line">    <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;  </span><br><span class="line">        removeEntryForKey(eldest.key);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (size &gt;= threshold)  </span><br><span class="line">            resize(<span class="number">2</span> * table.length);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;  </span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];  </span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, old);  </span><br><span class="line">    table[bucketIndex] = e;  </span><br><span class="line">    <span class="comment">// 调用元素的addBrefore方法，将元素加入到哈希、双向链接列表。  </span></span><br><span class="line">    e.addBefore(header);  </span><br><span class="line">    size++;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;  </span><br><span class="line">    after  = existingEntry;  </span><br><span class="line">    before = existingEntry.before;  </span><br><span class="line">    before.after = <span class="keyword">this</span>;  </span><br><span class="line">    after.before = <span class="keyword">this</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4) 读取：</p>
<p>LinkedHashMap重写了父类HashMap的get方法，实际在调用父类getEntry()方法取得查找的元素后，再判断当排序模式accessOrder为true时，记录访问顺序，将最新访问的元素添加到双向链表的表头，并从原来的位置删除。由于的链表的增加、删除操作是常量级的，故并不会带来性能的损失。</p>
<p><strong>HashMap.containsValue:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> containsNullValue();  </span><br><span class="line">  </span><br><span class="line">    Entry[] tab = table;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)  </span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)  </span><br><span class="line">                <span class="keyword">if</span> (value.equals(e.value))  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"> <span class="comment">/*查找Map中是否包含给定的value，还是考虑到，LinkedHashMap拥有的双链表，在这里Override是为了提高迭代的效率。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// Overridden to take advantage of faster iterator  </span></span><br><span class="line">        <span class="keyword">if</span> (value==<span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (Entry e = header.after; e != header; e = e.after)  </span><br><span class="line">                <span class="keyword">if</span> (e.value==<span class="keyword">null</span>)  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (Entry e = header.after; e != header; e = e.after)  </span><br><span class="line">                <span class="keyword">if</span> (value.equals(e.value))  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">/*该transfer()是HashMap中的实现：遍历整个表的各个桶位，然后对桶进行遍历得到每一个Entry，重新hash到newTable中， </span></span><br><span class="line"><span class="comment"> //放在这里是为了和下面LinkedHashMap重写该法的比较， </span></span><br><span class="line"><span class="comment"> void transfer(Entry[] newTable) &#123; </span></span><br><span class="line"><span class="comment">        Entry[] src = table; </span></span><br><span class="line"><span class="comment">        int newCapacity = newTable.length; </span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; src.length; j++) &#123; </span></span><br><span class="line"><span class="comment">            Entry&lt;K,V&gt; e = src[j]; </span></span><br><span class="line"><span class="comment">            if (e != null) &#123; </span></span><br><span class="line"><span class="comment">                src[j] = null; </span></span><br><span class="line"><span class="comment">                do &#123; </span></span><br><span class="line"><span class="comment">                    Entry&lt;K,V&gt; next = e.next; </span></span><br><span class="line"><span class="comment">                    int i = indexFor(e.hash, newCapacity); </span></span><br><span class="line"><span class="comment">                    e.next = newTable[i]; </span></span><br><span class="line"><span class="comment">                    newTable[i] = e; </span></span><br><span class="line"><span class="comment">                    e = next; </span></span><br><span class="line"><span class="comment">                &#125; while (e != null); </span></span><br><span class="line"><span class="comment">            &#125; </span></span><br><span class="line"><span class="comment">        &#125; </span></span><br><span class="line"><span class="comment">    &#125; </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">  </span><br><span class="line"> <span class="comment">/** </span></span><br><span class="line"><span class="comment"> *transfer()方法是其父类HashMap调用resize()的时候调用的方法，它的作用是表扩容后，把旧表中的key重新hash到新的表中。 </span></span><br><span class="line"><span class="comment"> *这里从写了父类HashMap中的该方法，是因为考虑到，LinkedHashMap拥有的双链表，在这里Override是为了提高迭代的效率。 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(HashMap.Entry[] newTable)</span> </span>&#123;  </span><br><span class="line">   <span class="keyword">int</span> newCapacity = newTable.length;  </span><br><span class="line">   <span class="keyword">for</span> (Entry&lt;K, V&gt; e = header.after; e != header; e = e.after) &#123;  </span><br><span class="line">     <span class="keyword">int</span> index = indexFor(e.hash, newCapacity);  </span><br><span class="line">     e.next = newTable[index];  </span><br><span class="line">     newTable[index] = e;  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 调用父类HashMap的getEntry()方法，取得要查找的元素。  </span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key);  </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    <span class="comment">// 记录访问顺序。  </span></span><br><span class="line">    e.recordAccess(<span class="keyword">this</span>);  </span><br><span class="line">    <span class="keyword">return</span> e.value;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;  </span><br><span class="line">    LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m;  </span><br><span class="line">    <span class="comment">// 如果定义了LinkedHashMap的迭代顺序为访问顺序，  </span></span><br><span class="line">    <span class="comment">// 则删除以前位置上的元素，并将最新访问的元素添加到链表表头。  </span></span><br><span class="line">    <span class="keyword">if</span> (lm.accessOrder) &#123;  </span><br><span class="line">        lm.modCount++;  </span><br><span class="line">        remove();  </span><br><span class="line">        addBefore(lm.header);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Removes this entry from the linked list. </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     before.after = after;  </span><br><span class="line">     after.before = before;  </span><br><span class="line"> &#125;  </span><br><span class="line"><span class="comment">/**clear链表，设置header为初始状态*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">super</span>.clear();  </span><br><span class="line"> header.before = header.after = header;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 5) 排序模式：</p>
<p>LinkedHashMap定义了排序模式accessOrder，该属性为boolean型变量，对于访问顺序，为true；对于插入顺序，则为false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure>
<p> 一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。看LinkedHashMap的构造方法，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);  </span><br><span class="line">    accessOrder = <span class="keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些构造方法都会默认指定排序模式为插入顺序。如果你想构造一个LinkedHashMap，并打算按从近期访问最少到近期访问最多的顺序（即访问顺序）来保存元素，那么请使用下面的构造方法构造LinkedHashMap：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,  </span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">float</span> loadFactor,  </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);  </span><br><span class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该哈希映射的迭代顺序就是最后访问其条目的顺序，这种映射很适合构建LRU缓存。LinkedHashMap提供了removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)方法。该方法可以提供在每次添加新条目时移除最旧条目的实现程序，默认返回false，这样，此映射的行为将类似于正常映射，即永远不能移除最旧的元素。</p>
<p>当有新元素加入Map的时候会调用Entry的addEntry方法，会调用removeEldestEntry方法，这里就是实现LRU元素过期机制的地方，默认的情况下removeEldestEntry方法只返回false表示元素永远不过期。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">    * This override alters behavior of superclass put method. It causes newly </span></span><br><span class="line"><span class="comment">    * allocated entry to get inserted at the end of the linked list and </span></span><br><span class="line"><span class="comment">    * removes the eldest entry if appropriate. </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;  </span><br><span class="line">       createEntry(hash, key, value, bucketIndex);  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">// Remove eldest entry if instructed, else grow capacity if appropriate  </span></span><br><span class="line">       Entry&lt;K,V&gt; eldest = header.after;  </span><br><span class="line">       <span class="keyword">if</span> (removeEldestEntry(eldest)) &#123;  </span><br><span class="line">           removeEntryForKey(eldest.key);  </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">           <span class="keyword">if</span> (size &gt;= threshold)   </span><br><span class="line">               resize(<span class="number">2</span> * table.length);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * This override differs from addEntry in that it doesn't resize the </span></span><br><span class="line"><span class="comment">    * table or remove the eldest entry. </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;  </span><br><span class="line">       HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];  </span><br><span class="line">Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, old);  </span><br><span class="line">       table[bucketIndex] = e;  </span><br><span class="line">       e.addBefore(header);  </span><br><span class="line">       size++;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>此方法通常不以任何方式修改映射，相反允许映射在其返回值的指引下进行自我修改。如果用此映射构建LRU缓存，则非常方便，它允许映射通过删除旧条目来减少内存损耗。</p>
<p>例如：重写此方法，维持此映射只保存100个条目的稳定状态，在每次添加新条目时删除最旧的条目。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">100</span>;  </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> size() &gt; MAX_ENTRIES;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://tomyz0223.iteye.com/blog/1035686" target="_blank" rel="noopener">使用LinkedHashMap构建LRU的</a></p>
<p><a href="http://woming66.iteye.com/blog/1284326" target="_blank" rel="noopener">基于LinkedHashMap实现LRU</a></p>
<p>其实LinkedHashMap几乎和HashMap一样，不同的是它定义了一个Entry&lt;K,V&gt; header，这个header不是放在Table里，它是额外独立出来的。LinkedHashMap通过继承hashMap中的Entry&lt;K,V&gt;,并添加两个属性Entry&lt;K,V&gt;  before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。</p>
<h4 id="1-8-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。"><a href="#1-8-抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么-类可以实现多个接口么。" class="headerlink" title="1.8 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。"></a>1.8 抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。</h4><p>1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。</p>
<p>2、抽象类要被子类继承，接口要被类实现。</p>
<p>3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现</p>
<p>4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</p>
<p>5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。</p>
<p>6、抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。</p>
<p>7、抽象类里可以没有抽象方法</p>
<p>8、如果一个类里有抽象方法，那么这个类只能是抽象类</p>
<p>9、抽象方法要被实现，所以不能是静态的，也不能是私有的。</p>
<p>10、接口可继承接口，并可多继承接口，但类只能单根继承。</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>抽象类</strong></th>
<th><strong>接口</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>默认的方法实现</td>
<td>它可以有默认的方法实现</td>
<td>接口完全是抽象的。它根本不存在方法的实现</td>
</tr>
<tr>
<td>关键字</td>
<td>子类使用<strong>extends</strong>关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字<strong>implements</strong>来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以有<strong>public</strong>、<strong>protected</strong>和<strong>default</strong>这些修饰符</td>
<td>接口方法默认修饰符是<strong>public</strong>。你不可以使用其它修饰符。</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有main方法并且我们可以运行它</td>
<td>接口没有main方法，因此我们不能运行它。</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象类只可以继承一个类和实现多个接口</td>
<td>接口和接口之间是可以多继承或者单继承多实现的。</td>
</tr>
<tr>
<td>速度</td>
<td>它比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td>
<td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td>
</tr>
<tr>
<td>设计理念</td>
<td>is-a的关系，体现的是一种关系的延续</td>
<td>like-a体现的是一种功能的扩展关系</td>
</tr>
</tbody>
</table>
<p><strong>具体使用的场景</strong></p>
<ul>
<li>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。</li>
<li>如果你想实现多重继承，那么你必须使用接口。由于<strong>Java不支持多继承</strong>，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。</li>
<li>如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</li>
<li>多用组合，少用继承。</li>
</ul>
<h4 id="1-9-继承和聚合的区别在哪。"><a href="#1-9-继承和聚合的区别在哪。" class="headerlink" title="1.9 继承和聚合的区别在哪。"></a>1.9 继承和聚合的区别在哪。</h4><p>继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；在Java中此类关系通过关键字extends明确标识，在设计时一般没有争议性；</p>
<p>聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等；表现在代码层面，和关联关系是一致的，只能从语义级别来区分</p>
<p><a href="https://www.cnblogs.com/jiqing9006/p/5915023.html" target="_blank" rel="noopener">继承、实现、依赖、关联、聚合、组合的联系与区别</a></p>
<h4 id="2-0-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型。"><a href="#2-0-IO模型有哪些，讲讲你理解的nio-，他和bio，aio的区别是啥，谈谈reactor模型。" class="headerlink" title="2.0 IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。"></a>2.0 IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。</h4><p>IO是面向流的，NIO是面向缓冲区的</p>
<p>NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</p>
<p><strong>传统BIO模型分析</strong></p>
<p>让我们先回忆一下传统的服务器端同步阻塞I/O处理（也就是BIO，Blocking I/O）的经典编程模型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> ExecutorService executor = Excutors.newFixedThreadPollExecutor(<span class="number">100</span>);<span class="comment">//线程池</span></span><br><span class="line"></span><br><span class="line"> ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket();</span><br><span class="line"> serverSocket.bind(<span class="number">8088</span>);</span><br><span class="line"> <span class="keyword">while</span>(!Thread.currentThread.isInturrupted())&#123;<span class="comment">//主线程死循环等待新连接到来</span></span><br><span class="line"> Socket socket = serverSocket.accept();</span><br><span class="line"> executor.submit(<span class="keyword">new</span> ConnectIOnHandler(socket));<span class="comment">//为新的连接创建新的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnectIOnHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectIOnHandler</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(!Thread.currentThread.isInturrupted()&amp;&amp;!socket.isClosed())&#123;死循环处理读写事件</span><br><span class="line">          String someThing = socket.read()....<span class="comment">//读取数据</span></span><br><span class="line">          <span class="keyword">if</span>(someThing!=<span class="keyword">null</span>)&#123;</span><br><span class="line">             ......<span class="comment">//处理数据</span></span><br><span class="line">             socket.write()....<span class="comment">//写数据</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个经典的每连接每线程的模型，之所以使用多线程，主要原因在于socket.accept()、socket.read()、socket.write()三个主要函数都是同步阻塞的，当一个连接在处理I/O的时候，系统是阻塞的，如果是单线程的话必然就挂死在那里；但CPU是被释放出来的，开启多线程，就可以让CPU去处理更多的事情。其实这也是所有使用多线程的本质：</p>
<ol>
<li>利用多核。</li>
<li>当I/O阻塞系统，但CPU空闲的时候，可以利用多线程使用CPU资源。</li>
</ol>
<p>现在的多线程一般都使用线程池，可以让线程的创建和回收成本相对较低。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的I/O并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。</p>
<p>不过，这个模型最本质的问题在于，严重依赖于线程。但线程是很”贵”的资源，主要表现在：</p>
<ol>
<li>线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数。</li>
<li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。</li>
<li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。</li>
<li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。</li>
</ol>
<p>所以，当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。随着移动端应用的兴起和各种网络游戏的盛行，百万级长连接日趋普遍，此时，必然需要一种更高效的I/O处理模型。</p>
<p><strong>NIO是怎么工作的</strong></p>
<p>很多刚接触NIO的人，第一眼看到的就是Java相对晦涩的API，比如：Channel，Selector，Socket什么的；然后就是一坨上百行的代码来演示NIO的服务端Demo……瞬间头大有没有？</p>
<p>我们不管这些，抛开现象看本质，先分析下NIO是怎么工作的。</p>
<p><strong>常见I/O模型对比</strong></p>
<p>所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p>
<p>需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在”干活”，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，可以理解为基本不耗时。</p>
<p>下图是几种常见I/O模型的对比：</p>
<p><img src="https://pic2.zhimg.com/80/v2-f47206d5b5e64448744b85eaf568f92d_hd.jpg" alt="img"></p>
<p>以socket.read()为例子：</p>
<p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</p>
<p>对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</p>
<p>最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</p>
<p>换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。</p>
<p>NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。</p>
<p><strong>如何结合事件模型使用NIO同步非阻塞特性</strong></p>
<p>回忆BIO模型，之所以需要多线程，是因为在进行I/O操作的时候，一是没有办法知道到底能不能写、能不能读，只能”傻等”，即使通过各种估算，算出来操作系统没有能力进行读写，也没法在socket.read()和socket.write()函数中返回，这两个函数无法进行有效的中断。所以除了多开线程另起炉灶，没有好的办法利用CPU。</p>
<p>NIO的读写函数可以立刻返回，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。</p>
<p>下面具体看下如何利用事件模型单线程处理所有I/O请求：</p>
<p>NIO的主要事件有几个：读就绪、写就绪、有新连接到来。</p>
<p>我们首先需要注册当这几个事件到来的时候所对应的处理器。然后在合适的时机告诉事件选择器：我对这个事件感兴趣。对于写操作，就是写不出去的时候对写事件感兴趣；对于读操作，就是完成连接和系统没有办法承载新读入的数据的时；对于accept，一般是服务器刚启动的时候；而对于connect，一般是connect失败需要重连或者直接异步调用connect的时候。</p>
<p>其次，用一个死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是select、poll，2.6之后是epoll，Windows是IOCP），还会阻塞的等待新事件的到来。新事件到来的时候，会在selector上注册标记位，标示可读、可写或者有连接到来。</p>
<p>注意，select是阻塞的，无论是通过操作系统的通知（epoll）还是不停的轮询(select，poll)，这个函数是阻塞的。所以你可以放心大胆地在一个while(true)里面调用这个函数而不用担心CPU空转。</p>
<p>所以我们的程序大概的模样是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelReadable</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">channelWritable</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span></span>&#123;</span><br><span class="line">   Socket socket;</span><br><span class="line">   Event event;<span class="comment">//读，写或者连接</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//IO线程主循环:</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">IoThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"> Channel channel;</span><br><span class="line"> <span class="keyword">while</span>(channel=Selector.select())&#123;<span class="comment">//选择就绪的事件和对应的连接</span></span><br><span class="line">    <span class="keyword">if</span>(channel.event==accept)&#123;</span><br><span class="line">       registerNewChannelHandler(channel);<span class="comment">//如果是新连接，则注册一个新的读写处理器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(channel.event==write)&#123;</span><br><span class="line">       getChannelHandler(channel).channelWritable(channel);<span class="comment">//如果可以写，则执行写事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(channel.event==read)&#123;</span><br><span class="line">        getChannelHandler(channel).channelReadable(channel);<span class="comment">//如果可以读，则执行读事件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> Map&lt;Channel，ChannelHandler&gt; handlerMap;<span class="comment">//所有channel的对应事件处理器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序很简短，也是最简单的Reactor模式：注册所有感兴趣的事件处理器，单线程轮询选择就绪事件，执行事件处理器。</p>
<p><strong>优化线程模型</strong></p>
<p>由上面的示例我们大概可以总结出NIO是怎么解决掉线程的瓶颈并处理海量连接的：</p>
<p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。</p>
<p>并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。</p>
<p>单线程处理I/O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。但现在的服务器，一般都是多核处理器，如果能够利用多核心进行I/O，无疑对效率会有更大的提高。</p>
<p>仔细分析一下我们需要的线程，其实主要包括以下几种：</p>
<ol>
<li>事件分发器，单线程选择就绪的事件。</li>
<li>I/O处理器，包括connect、read、write等，这种纯CPU操作，一般开启CPU核心个线程就可以。</li>
<li>业务线程，在处理完I/O后，业务一般还会有自己的业务逻辑，有的还会有其他的阻塞I/O，如DB操作，RPC等。只要有阻塞，就需要单独的线程。</li>
</ol>
<p>Java的Selector对于Linux系统来说，有一个致命限制：同一个channel的select不能被并发的调用。因此，如果有多个I/O线程，必须保证：一个socket只能属于一个IoThread，而一个IoThread可以管理多个socket。</p>
<p>另外连接的处理和读写的处理通常可以选择分开，这样对于海量连接的注册和读写就可以分发。虽然read()和write()是比较高效无阻塞的函数，但毕竟会占用CPU，如果面对更高的并发则无能为力。</p>
<p><img src="https://pic2.zhimg.com/80/v2-22efc734724d07251f8293e2f1143639_hd.png" alt="img"></p>
<p><strong>NIO在客户端的魔力</strong></p>
<p>通过上面的分析，可以看出NIO在服务端对于解放线程，优化I/O和处理海量连接方面，确实有自己的用武之地。那么在客户端上，NIO又有什么使用场景呢?</p>
<p>常见的客户端BIO+连接池模型，可以建立n个连接，然后当某一个连接被I/O占用的时候，可以使用其他连接来提高性能。</p>
<p>但多线程的模型面临和服务端相同的问题：如果指望增加连接数来提高性能，则连接数又受制于线程数、线程很贵、无法建立很多线程，则性能遇到瓶颈。</p>
<p><strong>每连接顺序请求的Redis</strong></p>
<p>对于Redis来说，由于服务端是全局串行的，能够保证同一连接的所有请求与返回顺序一致。这样可以使用单线程＋队列，把请求数据缓冲。然后pipeline发送，返回future，然后channel可读时，直接在队列中把future取回来，done()就可以了。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisClient</span> <span class="title">Implements</span> <span class="title">ChannelHandler</span></span>&#123;</span><br><span class="line"> <span class="keyword">private</span> BlockingQueue CmdQueue;</span><br><span class="line"> <span class="keyword">private</span> EventLoop eventLoop;</span><br><span class="line"> <span class="keyword">private</span> Channel channel;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Cmd</span></span>&#123;</span><br><span class="line">  String cmd;</span><br><span class="line">  Future result;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Future <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">   Cmd cmd= <span class="keyword">new</span> Cmd(key);</span><br><span class="line">   queue.offer(cmd);</span><br><span class="line">   eventLoop.submit(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        queue.drainTo(list);</span><br><span class="line">        <span class="keyword">if</span>(channel.isWritable())&#123;</span><br><span class="line">         channel.writeAndFlush(list);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChannelReadFinish</span><span class="params">(Channel channel，Buffer Buffer)</span></span>&#123;</span><br><span class="line">    List result = handleBuffer();<span class="comment">//处理数据</span></span><br><span class="line">    <span class="comment">//从cmdQueue取出future，并设值，future.done();</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChannelWritable</span><span class="params">(Channel channel)</span></span>&#123;</span><br><span class="line">   channel.flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做，能够充分的利用pipeline来提高I/O能力，同时获取异步处理能力。</p>
<p><strong>多连接短连接的HttpClient</strong></p>
<p>类似于竞对抓取的项目，往往需要建立无数的HTTP短连接，然后抓取，然后销毁，当需要单机抓取上千网站线程数又受制的时候，怎么保证性能呢?</p>
<p>何不尝试NIO，单线程进行连接、写、读操作？如果连接、读、写操作系统没有能力处理，简单的注册一个事件，等待下次循环就好了。</p>
<p>如何存储不同的请求/响应呢？由于http是无状态没有版本的协议，又没有办法使用队列，好像办法不多。比较笨的办法是对于不同的socket，直接存储socket的引用作为map的key。</p>
<p><strong>常见的RPC框架，如Thrift，Dubbo</strong></p>
<p>这种框架内部一般维护了请求的协议和请求号，可以维护一个以请求号为key，结果的result为future的map，结合NIO+长连接，获取非常不错的性能。</p>
<p><strong>NIO高级主题</strong></p>
<p><strong>Proactor与Reactor</strong></p>
<p>一般情况下，I/O 复用机制需要事件分发器（event dispatcher）。 事件分发器的作用，即将那些读写事件源分发给各读写事件的处理者，就像送快递的在楼下喊: 谁谁谁的快递到了， 快来拿吧！开发人员在开始的时候需要在分发器那里注册感兴趣的事件，并提供相应的处理者（event handler)，或者是回调函数；事件分发器在适当的时候，会将请求的事件分发给这些handler或者回调函数。</p>
<p>涉及到事件分发器的两种模式称为：Reactor和Proactor。 Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。</p>
<p>而在Proactor模式中，事件处理者（或者代由事件分发器发起）直接发起一个异步读写操作（相当于请求），而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区、读的数据大小或用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分发器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO操作（称为overlapped技术），事件分发器等IO Complete事件完成。这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。</p>
<p>举个例子，将有助于理解Reactor与Proactor二者的差异，以读操作为例（写操作类似）。</p>
<p><strong>在Reactor中实现读</strong></p>
<ul>
<li>注册读就绪事件和相应的事件处理器。</li>
<li>事件分发器等待事件。</li>
<li>事件到来，激活分发器，分发器调用事件对应的处理器。</li>
<li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li>
</ul>
<p><strong>在Proactor中实现读：</strong></p>
<ul>
<li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li>
<li>事件分发器等待操作完成事件。</li>
<li>在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。</li>
<li>事件分发器呼唤处理器。</li>
<li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分发器。</li>
</ul>
<p>可以看出，两个模式的相同点，都是对某个I/O事件的事件通知（即告诉某个模块，这个I/O操作可以进行或已经完成)。在结构上，两者也有相同点：事件分发器负责提交IO操作（异步)、查询设备是否可操作（同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下（Proactor)，当回调handler时，表示I/O操作已经完成；同步情况下（Reactor)，回调handler时，表示I/O设备可以进行某个操作（can read 或 can write)。</p>
<p>下面，我们将尝试应对为Proactor和Reactor模式建立可移植框架的挑战。在改进方案中，我们将Reactor原来位于事件处理器内的Read/Write操作移至分发器（不妨将这个思路称为“模拟异步”），以此寻求将Reactor多路同步I/O转化为模拟异步I/O。以读操作为例子，改进过程如下：</p>
<ul>
<li>注册读就绪事件和相应的事件处理器。并为分发器提供数据缓冲区地址，需要读取数据量等信息。</li>
<li>分发器等待事件（如在select()上等待）。</li>
<li>事件到来，激活分发器。分发器执行一个非阻塞读操作（它有完成这个操作所需的全部信息），最后调用对应处理器。</li>
<li>事件处理器处理用户自定义缓冲区的数据，注册新的事件（当然同样要给出数据缓冲区地址，需要读取的数据量等信息），最后将控制权返还分发器。<br>如我们所见，通过对多路I/O模式功能结构的改造，可将Reactor转化为Proactor模式。改造前后，模型实际完成的工作量没有增加，只不过参与者间对工作职责稍加调换。没有工作量的改变，自然不会造成性能的削弱。对如下各步骤的比较，可以证明工作量的恒定：</li>
</ul>
<p><strong>标准/典型的Reactor：</strong></p>
<ul>
<li>步骤1：等待事件到来（Reactor负责）。</li>
<li>步骤2：将读就绪事件分发给用户定义的处理器（Reactor负责）。</li>
<li>步骤3：读数据（用户处理器负责）。</li>
<li>步骤4：处理数据（用户处理器负责）。</li>
</ul>
<p><strong>改进实现的模拟Proactor：</strong></p>
<ul>
<li><p>步骤1：等待事件到来（Proactor负责）。</p>
</li>
<li><p>步骤2：得到读就绪事件，执行读数据（现在由Proactor负责）。</p>
</li>
<li><p>步骤3：将读完成事件分发给用户处理器（Proactor负责）。</p>
</li>
<li><p>步骤4：处理数据（用户处理器负责）。</p>
<p>对于不提供异步I/O API的操作系统来说，这种办法可以隐藏Socket API的交互细节，从而对外暴露一个完整的异步接口。借此，我们就可以进一步构建完全可移植的，平台无关的，有通用对外接口的解决方案。</p>
</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">channelReadComplate</span><span class="params">(Channel channel，<span class="keyword">byte</span>[] data)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">channelWritable</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Channel</span></span>&#123;</span><br><span class="line">     Socket socket;</span><br><span class="line">     Event event;<span class="comment">//读，写或者连接</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//IO线程主循环：</span></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">IoThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Channel channel;</span><br><span class="line">   <span class="keyword">while</span>(channel=Selector.select())&#123;<span class="comment">//选择就绪的事件和对应的连接</span></span><br><span class="line">      <span class="keyword">if</span>(channel.event==accept)&#123;</span><br><span class="line">         registerNewChannelHandler(channel);<span class="comment">//如果是新连接，则注册一个新的读写处理器</span></span><br><span class="line">         Selector.interested(read);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(channel.event==write)&#123;</span><br><span class="line">         getChannelHandler(channel).channelWritable(channel);<span class="comment">//如果可以写，则执行写事件</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(channel.event==read)&#123;</span><br><span class="line">          <span class="keyword">byte</span>[] data = channel.read();</span><br><span class="line">          <span class="keyword">if</span>(channel.read()==<span class="number">0</span>)<span class="comment">//没有读到数据，表示本次数据读完了</span></span><br><span class="line">          &#123;</span><br><span class="line">          getChannelHandler(channel).channelReadComplate(channel，data;<span class="comment">//处理读完成事件</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(过载保护)&#123;</span><br><span class="line">          Selector.interested(read);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   Map&lt;Channel，ChannelHandler&gt; handlerMap;<span class="comment">//所有channel的对应事件处理器</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Selector.wakeup()</strong></p>
<p><strong>主要作用</strong></p>
<p>解除阻塞在Selector.select()/select(long)上的线程，立即返回。</p>
<p>两次成功的select之间多次调用wakeup等价于一次调用。</p>
<p>如果当前没有阻塞在select上，则本次wakeup调用将作用于下一次select——“记忆”作用。</p>
<p>为什么要唤醒？</p>
<p>注册了新的channel或者事件。</p>
<p>channel关闭，取消注册。</p>
<p>优先级更高的事件触发（如定时器事件），希望及时处理。</p>
<p><strong>原理</strong></p>
<p>Linux上利用pipe调用创建一个管道，Windows上则是一个loopback的tcp连接。这是因为win32的管道无法加入select的fd set，将管道或者TCP连接加入select fd set。</p>
<p>wakeup往管道或者连接写入一个字节，阻塞的select因为有I/O事件就绪，立即返回。可见，wakeup的调用开销不可忽视。</p>
<p><strong>Buffer的选择</strong></p>
<p>通常情况下，操作系统的一次写操作分为两步：</p>
<ol>
<li>将数据从用户空间拷贝到系统空间。</li>
<li>从系统空间往网卡写。同理，读操作也分为两步：<br>① 将数据从网卡拷贝到系统空间；<br>② 将数据从系统空间拷贝到用户空间。</li>
</ol>
<p>对于NIO来说，缓存的使用可以使用DirectByteBuffer和HeapByteBuffer。如果使用了DirectByteBuffer，一般来说可以减少一次系统空间到用户空间的拷贝。但Buffer创建和销毁的成本更高，更不宜维护，通常会用内存池来提高性能。</p>
<p>如果数据量比较小的中小应用情况下，可以考虑使用heapBuffer；反之可以用directBuffer。</p>
<p><strong>NIO存在的问题</strong></p>
<p>使用NIO != 高性能，当连接数&lt;1000，并发程度不高或者局域网环境下NIO并没有显著的性能优势。</p>
<p>NIO并没有完全屏蔽平台差异，它仍然是基于各个操作系统的I/O系统实现的，差异仍然存在。使用NIO做网络编程构建事件驱动模型并不容易，陷阱重重。</p>
<p>推荐大家使用成熟的NIO框架，如Netty，MINA等。解决了很多NIO的陷阱，并屏蔽了操作系统的差异，有较好的性能和编程模型。</p>
<p><strong>总结</strong></p>
<p>最后总结一下到底NIO给我们带来了些什么：</p>
<blockquote>
<ul>
<li>事件驱动模型</li>
<li>避免多线程</li>
<li>单线程处理多任务</li>
<li>非阻塞I/O，I/O读写不再阻塞，而是返回0</li>
<li>基于block的传输，通常比基于流的传输更高效</li>
<li>更高级的IO函数，zero-copy</li>
<li>IO多路复用大大提高了Java网络应用的可伸缩性和实用性</li>
</ul>
</blockquote>
<h4 id="2-1-反射的原理，反射创建类实例的三种方式是什么。"><a href="#2-1-反射的原理，反射创建类实例的三种方式是什么。" class="headerlink" title="2.1 反射的原理，反射创建类实例的三种方式是什么。"></a>2.1 反射的原理，反射创建类实例的三种方式是什么。</h4><p><strong>方法反射实例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Proxy target = <span class="keyword">new</span> Proxy();</span><br><span class="line">        Method method = Proxy.class.getDeclaredMethod("run");</span><br><span class="line">        method.invoke(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"run"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Java的反射机制，可以在运行期间调用对象的任何方法，如果大量使用这种方式进行调用，会有性能或内存隐患么？为了彻底了解方法的反射机制，只能从底层代码入手了。</p>
<p><strong>Method获取</strong></p>
<p>调用Class类的getDeclaredMethod可以获取指定方法名和参数的方法对象Method。</p>
<p><strong>getDeclaredMethod</strong> </p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">     checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), <span class="keyword">true</span>);</span><br><span class="line">     Method method = searchMethods(privateGetDeclaredMethods(<span class="keyword">false</span>), name, parameterTypes);</span><br><span class="line">     <span class="keyword">if</span> (method == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(getName() + <span class="string">"."</span> + name + argumentTypesToString(parameterTypes));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> method;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>其中privateGetDeclaredMethods方法从缓存或JVM中获取该Class中申明的方法列表，searchMethods方法将从返回的方法列表里找到一个匹配名称和参数的方法对象。</p>
<p><strong>searchMethods</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Method <span class="title">searchMethods</span><span class="params">(Method[] methods,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Class&lt;?&gt;[] parameterTypes)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Method res = <span class="keyword">null</span>;</span><br><span class="line">        String internedName = name.intern();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            Method m = methods[i];</span><br><span class="line">            <span class="keyword">if</span> (m.getName() == internedName</span><br><span class="line">                &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())</span><br><span class="line">                &amp;&amp; (res == <span class="keyword">null</span></span><br><span class="line">                    || res.getReturnType().isAssignableFrom(m.getReturnType())))</span><br><span class="line">                res = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (res == <span class="keyword">null</span> ? res : getReflectionFactory().copyMethod(res));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果找到一个匹配的Method，则重新copy一份返回，即Method.copy()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Method <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// This routine enables sharing of MethodAccessor objects</span></span><br><span class="line">       <span class="comment">// among Method objects which refer to the same underlying</span></span><br><span class="line">       <span class="comment">// method in the VM. (All of this contortion is only necessary</span></span><br><span class="line">       <span class="comment">// because of the "accessibility" bit in AccessibleObject,</span></span><br><span class="line">       <span class="comment">// which implicitly requires that new java.lang.reflect</span></span><br><span class="line">       <span class="comment">// objects be fabricated for each reflective call on Class</span></span><br><span class="line">       <span class="comment">// objects.)</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can not copy a non-root Method"</span>);</span><br><span class="line"></span><br><span class="line">       Method res = <span class="keyword">new</span> Method(clazz, name, parameterTypes, returnType,</span><br><span class="line">                               exceptionTypes, modifiers, slot, signature,</span><br><span class="line">                               annotations, parameterAnnotations, annotationDefault);</span><br><span class="line">       res.root = <span class="keyword">this</span>;</span><br><span class="line">       <span class="comment">// Might as well eagerly propagate this if already present</span></span><br><span class="line">       res.methodAccessor = methodAccessor;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>所次每次调用getDeclaredMethod方法返回的Method对象其实都是一个新的对象，且新对象的root属性都指向原来的Method对象，如果需要频繁调用，最好把Method对象缓存起来。</p>
<p><strong>privateGetDeclaredMethods</strong></p>
<p>从缓存或JVM中获取该Class中申明的方法列表，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Method[] privateGetDeclaredMethods(<span class="keyword">boolean</span> publicOnly) &#123;</span><br><span class="line">        checkInitted();</span><br><span class="line">        Method[] res;</span><br><span class="line">        ReflectionData&lt;T&gt; rd = reflectionData();</span><br><span class="line">        <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// No cached value available; request value from VM</span></span><br><span class="line">        res = Reflection.filterMethods(<span class="keyword">this</span>, getDeclaredMethods0(publicOnly));</span><br><span class="line">        <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (publicOnly) &#123;</span><br><span class="line">                rd.declaredPublicMethods = res;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rd.declaredMethods = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中reflectionData()方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ReflectionData&lt;T&gt; <span class="title">reflectionData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = <span class="keyword">this</span>.reflectionData;</span><br><span class="line">       <span class="keyword">int</span> classRedefinedCount = <span class="keyword">this</span>.classRedefinedCount;</span><br><span class="line">       ReflectionData&lt;T&gt; rd;</span><br><span class="line">       <span class="keyword">if</span> (useCaches &amp;&amp;</span><br><span class="line">           reflectionData != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           (rd = reflectionData.get()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">           rd.redefinedCount == classRedefinedCount) &#123;</span><br><span class="line">           <span class="keyword">return</span> rd;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// else no SoftReference or cleared SoftReference or stale ReflectionData</span></span><br><span class="line">       <span class="comment">// -&gt; create and replace new instance</span></span><br><span class="line">       <span class="keyword">return</span> newReflectionData(reflectionData, classRedefinedCount);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里有个比较重要的数据结构ReflectionData，用来缓存从JVM中读取类的如下属性数据：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reflection data that might get invalidated when JVM TI RedefineClasses() is called</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionData</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">volatile</span> Field[] declaredFields;</span><br><span class="line">       <span class="keyword">volatile</span> Field[] publicFields;</span><br><span class="line">       <span class="keyword">volatile</span> Method[] declaredMethods;</span><br><span class="line">       <span class="keyword">volatile</span> Method[] publicMethods;</span><br><span class="line">       <span class="keyword">volatile</span> Constructor&lt;T&gt;[] declaredConstructors;</span><br><span class="line">       <span class="keyword">volatile</span> Constructor&lt;T&gt;[] publicConstructors;</span><br><span class="line">       <span class="comment">// Intermediate results for getFields and getMethods</span></span><br><span class="line">       <span class="keyword">volatile</span> Field[] declaredPublicFields;</span><br><span class="line">       <span class="keyword">volatile</span> Method[] declaredPublicMethods;</span><br><span class="line">       <span class="keyword">volatile</span> Class&lt;?&gt;[] interfaces;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Value of classRedefinedCount when we created this ReflectionData instance</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> redefinedCount;</span><br><span class="line"></span><br><span class="line">       ReflectionData(<span class="keyword">int</span> redefinedCount) &#123;</span><br><span class="line">           <span class="keyword">this</span>.redefinedCount = redefinedCount;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从reflectionData()方法实现可以看出：reflectionData对象是SoftReference类型的，说明在内存紧张时可能会被回收，不过也可以通过<code>-XX:SoftRefLRUPolicyMSPerMB</code>参数控制回收的时机，只要发生GC就会将其回收，如果reflectionData被回收之后，又执行了反射方法，那只能通过newReflectionData方法重新创建一个这样的对象了，newReflectionData方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ReflectionData&lt;T&gt; <span class="title">newReflectionData</span><span class="params">(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">int</span> classRedefinedCount)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!useCaches) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           ReflectionData&lt;T&gt; rd = <span class="keyword">new</span> ReflectionData&lt;&gt;(classRedefinedCount);</span><br><span class="line">           <span class="comment">// try to CAS it...</span></span><br><span class="line">           <span class="keyword">if</span> (Atomic.casReflectionData(<span class="keyword">this</span>, oldReflectionData, <span class="keyword">new</span> SoftReference&lt;&gt;(rd))) &#123;</span><br><span class="line">               <span class="keyword">return</span> rd;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// else retry</span></span><br><span class="line">           oldReflectionData = <span class="keyword">this</span>.reflectionData;</span><br><span class="line">           classRedefinedCount = <span class="keyword">this</span>.classRedefinedCount;</span><br><span class="line">           <span class="keyword">if</span> (oldReflectionData != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (rd = oldReflectionData.get()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               rd.redefinedCount == classRedefinedCount) &#123;</span><br><span class="line">               <span class="keyword">return</span> rd;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 通过unsafe.compareAndSwapObject方法重新设置reflectionData字段；</p>
<p>在privateGetDeclaredMethods方法中，如果通过reflectionData()获得的ReflectionData对象不为空，则尝试从ReflectionData对象中获取declaredMethods属性，如果是第一次，或则被GC回收之后，重新初始化后的类属性为空，则需要重新到JVM中获取一次，并赋值给ReflectionData，下次调用就可以使用缓存数据了。</p>
<p><strong>Method调用</strong></p>
<p>获取到指定的方法对象Method之后，就可以调用它的invoke方法了，invoke实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">          InvocationTargetException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">               Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">               checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">       <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">           ma = acquireMethodAccessor();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>应该注意到：这里的MethodAccessor对象是invoke方法实现的关键，一开始methodAccessor为空，需要调用acquireMethodAccessor生成一个新的MethodAccessor对象，MethodAccessor本身就是一个接口，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAccessor</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在acquireMethodAccessor方法中，会通过ReflectionFactory类的newMethodAccessor创建一个实现了MethodAccessor接口的对象，实现如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodAccessor <span class="title">newMethodAccessor</span><span class="params">(Method var1)</span> </span>&#123;</span><br><span class="line">       checkInitted();</span><br><span class="line">       <span class="keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) &#123;</span><br><span class="line">           <span class="keyword">return</span> (<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(var1.getDeclaringClass(), var1.getName(), var1.getParameterTypes(), var1.getReturnType(), var1.getExceptionTypes(), var1.getModifiers());</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           NativeMethodAccessorImpl var2 = <span class="keyword">new</span> NativeMethodAccessorImpl(var1);</span><br><span class="line">           DelegatingMethodAccessorImpl var3 = <span class="keyword">new</span> DelegatingMethodAccessorImpl(var2);</span><br><span class="line">           var2.setParent(var3);</span><br><span class="line">           <span class="keyword">return</span> var3;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在ReflectionFactory类中，有2个重要的字段：noInflation(默认false)和inflationThreshold(默认15)，在checkInitted方法中可以通过-Dsun.reflect.inflationThreshold=xxx和-Dsun.reflect.noInflation=true对这两个字段重新设置，而且只会设置一次；</p>
<p>如果noInflation为false，方法newMethodAccessor都会返回DelegatingMethodAccessorImpl对象，DelegatingMethodAccessorImpl的类实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DelegatingMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MethodAccessorImpl delegate;</span><br><span class="line"></span><br><span class="line">    DelegatingMethodAccessorImpl(MethodAccessorImpl var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setDelegate(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.delegate.invoke(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDelegate</span><span class="params">(MethodAccessorImpl var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = var1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，DelegatingMethodAccessorImpl对象就是一个代理对象，负责调用被代理对象delegate的invoke方法，其中delegate参数目前是NativeMethodAccessorImpl对象，所以最终Method的invoke方法调用的是NativeMethodAccessorImpl对象invoke方法，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">           MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), <span class="keyword">this</span>.method.getName(), <span class="keyword">this</span>.method.getParameterTypes(), <span class="keyword">this</span>.method.getReturnType(), <span class="keyword">this</span>.method.getExceptionTypes(), <span class="keyword">this</span>.method.getModifiers());</span><br><span class="line">           <span class="keyword">this</span>.parent.setDelegate(var3);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里用到了ReflectionFactory类中的inflationThreshold，当delegate调用了15次invoke方法之后，如果继续调用就通过MethodAccessorGenerator类的generateMethod方法生成MethodAccessorImpl对象，并设置为delegate对象，这样下次执行Method.invoke时，就调用新建的MethodAccessor对象的invoke()方法了。</p>
<p><strong>这里需要注意的是：</strong><br> generateMethod方法在生成MethodAccessorImpl对象时，会在内存中生成对应的字节码，并调用ClassDefiner.defineClass创建对应的class对象，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (MagicAccessorImpl)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;MagicAccessorImpl&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> MagicAccessorImpl <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> (MagicAccessorImpl)ClassDefiner.defineClass(var13, var17, <span class="number">0</span>, var17.length, var1.getClassLoader()).newInstance();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException var2) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(var2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<p>在ClassDefiner.defineClass方法实现中，每被调用一次都会生成一个DelegatingClassLoader类加载器对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Class&lt;?&gt; defineClass(String var0, <span class="keyword">byte</span>[] var1, <span class="keyword">int</span> var2, <span class="keyword">int</span> var3, <span class="keyword">final</span> ClassLoader var4) &#123;</span><br><span class="line">        ClassLoader var5 = (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;ClassLoader&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DelegatingClassLoader(var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> unsafe.defineClass(var0, var1, var2, var3, var5, (ProtectionDomain)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里每次都生成新的类加载器，是为了性能考虑，在某些情况下可以卸载这些生成的类，因为类的卸载是只有在类加载器可以被回收的情况下才会被回收的，如果用了原来的类加载器，那可能导致这些新创建的类一直无法被卸载，从其设计来看本身就不希望这些类一直存在内存里的，在需要的时候有就行了。</p>
<p><strong>获取class</strong></p>
<p>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。获取类的Class对象有多种方式：</p>
<ul>
<li>调用getClass    </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Boolean var1 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; classType2 = var1.getClass();</span><br><span class="line"></span><br><span class="line">System.out.println(classType2);</span><br><span class="line"></span><br><span class="line">输出：<span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Boolean</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>运用.class 语法    </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; classType4 = Boolean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">System.out.println(classType4);</span><br><span class="line"></span><br><span class="line">输出：<span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Boolean</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>运用static method Class.forName()    </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; classType5 = Class.forName(<span class="string">"java.lang.Boolean"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(classType5);</span><br><span class="line"></span><br><span class="line">输出：<span class="class"><span class="keyword">class</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Boolean</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>运用primitive wrapper classes的TYPE 语法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这里返回的是原生类型，和Boolean<span class="class">.<span class="keyword">class</span>返回的不同</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Class</span>&lt;?&gt; <span class="title">classType3</span> </span>= Boolean.TYPE;</span><br><span class="line"></span><br><span class="line">System.out.println(classType3);        </span><br><span class="line"></span><br><span class="line">输出：<span class="keyword">boolean</span></span><br></pre></td></tr></table></figure>
<p><strong>实例化类对象</strong></p>
<ul>
<li>通过 Class 对象的 newInstance() 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clz = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Person person = (Person)clz.newInstance();</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 Constructor 对象的 newInstance() 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clz = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = clz.getConstructor();</span><br><span class="line">Person person = (Person)constructor.newInstance();</span><br></pre></td></tr></table></figure>
<p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clz = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor constructor = clz.getConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Person person = (Person)constructor.newInstance(<span class="string">"jack"</span>,<span class="number">21</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-2-反射中，Class-forName和ClassLoader区别-。"><a href="#2-2-反射中，Class-forName和ClassLoader区别-。" class="headerlink" title="2.2 反射中，Class.forName和ClassLoader区别 。"></a>2.2 反射中，Class.forName和ClassLoader区别 。</h4><p><strong>ClassLoader.loadClass()</strong>与<strong>Class.forName()</strong>大家都知道是反射用来构造类的方法，但是他们的用法还是有一定区别的。</p>
<p>在讲区别之前，我觉得很有不要把类的加载过程在此整理一下。</p>
<p>在Java中，类装载器把一个类装入Java虚拟机中，要经过三个步骤来完成：装载、链接和初始化，其中链接又可以分成校验、准备和解析三步，除了解析外，其它步骤是严格按照顺序完成的，各个步骤的主要工作如下：</p>
<ul>
<li><p><strong>装载</strong>：查找和导入类或接口的二进制数据； </p>
</li>
<li><p><strong>链接</strong>：执行下面的校验、准备和解析步骤，其中解析步骤是可以选择的； </p>
</li>
<li><p><strong>校验</strong>：检查导入类或接口的二进制数据的正确性； </p>
</li>
<li><p><strong>准备</strong>：给类的静态变量分配并初始化存储空间； </p>
</li>
<li><p><strong>解析</strong>：将符号引用转成直接引用； </p>
</li>
<li><p><strong>初始化</strong>：激活类的静态变量的初始化Java代码和静态Java代码块。</p>
<p>于是乎我们可以开始看2者的区别了。</p>
</li>
</ul>
<p>Class.forName(className)方法，其实调用的方法是<strong>Class.forName(className,true,classloader)</strong>;注意看第2个boolean参数，它表示的意思，<strong>在loadClass后必须初始化</strong>。比较下jvm加载类的知识，我们可以清晰的看到在执行过此方法后，目标对象的 static块代码已经被执行，static参数也已经被初始化。</p>
<p>再看ClassLoader.loadClass(className)方法，其实他调用的方法是<strong>ClassLoader.loadClass(className,false)</strong>;还是注意看第2个 boolean参数，该参数表示<strong>目标对象被装载后不进行链接</strong>，这就意味这<strong>不会去执行该类静态块中间的内</strong>容。因此2者的区别就显而易见了。</p>
<p>最后还有必要在此提一下new方法和newInstance方法的区别</p>
<p><strong>newInstance</strong>: 弱类型。<strong>低效率</strong>。<strong>只能调用无参构造</strong>。</p>
<p><strong>new</strong>: 强类型。相对高效。<strong>能调用任何public构造</strong>。</p>
<p>例如，在JDBC编程中，常看到这样的用法，Class.forName(“com.mysql.jdbc.Driver”)，如果换成了 getClass().getClassLoader().loadClass(“com.mysql.jdbc.Driver”)，就不行。</p>
<p>为什么呢？打开com.mysql.jdbc.Driver的源代码看看，</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Driver在static块中会注册自己到java.sql.DriverManager。而static块就是在Class的初始化中被执行。所以这个地方就只能用Class.forName(className)。</p>
<h4 id="2-3-描述动态代理的几种实现方式，分别说出相应的优缺点。"><a href="#2-3-描述动态代理的几种实现方式，分别说出相应的优缺点。" class="headerlink" title="2.3 描述动态代理的几种实现方式，分别说出相应的优缺点。"></a>2.3 描述动态代理的几种实现方式，分别说出相应的优缺点。</h4><p>代理可以分为 “静态代理” 和 “动态代理”，动态代理又分为 “JDK动态代理” 和 “CGLIB动态代理” 实现。</p>
<p><strong>静态代理</strong>：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object</p>
<ul>
<li><strong>优点</strong>：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。</li>
<li><strong>缺点</strong>：不同的接口要有不同的代理类实现，会很冗余</li>
</ul>
<p><strong>JDK 动态代理</strong>：</p>
<ul>
<li>为了解决静态代理中，生成大量的代理类造成的冗余；</li>
<li>JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，</li>
<li>jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象</li>
<li>jdk动态代理之所以<strong>只能代理接口</strong>是因为<strong>代理类本身已经extends了Proxy，而java是不允许多重继承的</strong>，但是允许实现多个接口</li>
<li><strong>优点</strong>：解决了静态代理中冗余的代理实现类问题。</li>
<li><strong>缺点</strong>：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。</li>
</ul>
<p><strong>CGLIB 代理</strong>：</p>
<ul>
<li>由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；</li>
<li>CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。</li>
<li>实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。</li>
<li>但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。</li>
<li>同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。</li>
<li><strong>优点</strong>：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。</li>
<li><strong>缺点</strong>：技术实现相对难理解些。</li>
</ul>
<h4 id="2-4-动态代理与cglib实现的区别。"><a href="#2-4-动态代理与cglib实现的区别。" class="headerlink" title="2.4 动态代理与cglib实现的区别。"></a>2.4 动态代理与cglib实现的区别。</h4><p><strong>JDK动态代理与CGLIB动态代理对比</strong></p>
<p>JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。</p>
<p>cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。</p>
<p>JDK Proxy 的优势：</p>
<ul>
<li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li>
<li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li>
<li>代码实现简单。</li>
</ul>
<p>基于类似 cglib 框架的优势：</p>
<ul>
<li>无需实现接口，达到代理类无侵入</li>
<li>只操作我们关心的类，而不必为其他相关类增加工作量。</li>
<li>高性能</li>
</ul>
<h4 id="2-5-为什么CGlib方式可以对接口实现代理。"><a href="#2-5-为什么CGlib方式可以对接口实现代理。" class="headerlink" title="2.5 为什么CGlib方式可以对接口实现代理。"></a>2.5 为什么CGlib方式可以对接口实现代理。</h4><p>参考2.3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> proxy.UserService;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建代理类的工厂 该类要实现 MethodInterceptor 接口。</span></span><br><span class="line"><span class="comment"> * 该类中完成三样工作：</span></span><br><span class="line"><span class="comment"> * （1）声明目标类的成员变量，并创建以目标类对象为参数的构造器。用于接收目标对象</span></span><br><span class="line"><span class="comment"> * （2）定义代理的生成方法，用于创建代理对象。方法名是任意的。代理对象即目标类的子类</span></span><br><span class="line"><span class="comment"> * （3）定义回调接口方法。对目标类的增强这在这里完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明目标类的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGLibFactory</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义代理的生成方法,用于创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">myCGLibCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 为代理对象设置父类，即指定目标类</span></span><br><span class="line">        enhancer.setSuperclass(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置回调接口对象 注意，只所以在setCallback()方法中可以写上this，</span></span><br><span class="line"><span class="comment">         * 是因为MethodIntecepter接口继承自Callback，是其子接口</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> (UserService) enhancer.create();<span class="comment">// create用以生成CGLib代理对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start invoke "</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"end invoke "</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-final的用途。"><a href="#2-6-final的用途。" class="headerlink" title="2.6 final的用途。"></a>2.6 final的用途。</h4><ol>
<li><p>Java中final修饰符既可以修饰类、方法，也可以修饰变量.</p>
<p><strong>基本规则</strong></p>
<ol>
<li>用final修饰的类不能被扩展，也就是说不可能有子类；</li>
<li>用final修饰的方法不能被替换或隐藏：</li>
</ol>
<ul>
<li>使用final修饰的实例方法在其所属类的子类中不能被替换（overridden）；</li>
<li>使用final修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏（hidden）；</li>
</ul>
<ol>
<li>用final修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同：</li>
</ol>
<ul>
<li>静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量，赋值可以在其声明中通过初始化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，赋值只能在其声明中通过初始化表达式完成；</li>
<li>实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通过初始化表达式完成，也可以在实例初始化块或构造器中进行；</li>
<li>方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体（body）结束，在此期间其值不能改变；</li>
<li>构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，同时被初始化为对应实参值，终止于构造器体结束，在此期间其值不能改变；</li>
<li>异常处理器参数变量在有异常被try语句的catch子句捕捉到时创建，同时被初始化为实际的异常对象，终止于catch语句块结束，在此期间其值不能改变；</li>
<li>局部变量在其值被访问之前必须被明确赋值；</li>
</ul>
<p><strong>关于final变量的进一步说明：</strong></p>
<ol>
<li>定义：blank final变量是其声明中不包含初始化表达式的final变量。</li>
<li>对于引用类型变量，final修饰符表示一旦赋值该变量就始终指向堆中同一个对象，不可改变，但是其所指对象本身（其状态）是可以改变的；不象C++中的const，在Java中没有办法仅通过一个final就可声明一个对象的不变性（immutability）。</li>
<li>常变量（constant variable）：</li>
</ol>
<ul>
<li>定义：常变量是用编译时常量表达式初始化的带有final修饰符的基本类型或字符串类型变量；</li>
<li>无论静态变量还是实例变量，如果它是常变量，则其引用在编译时会被解析成该常变量所表示的值，在class文件中并不存在任何对常变量域的引用；也正是基于此，当在源代码中修改某个常变量域的初始值并重新编译后，该改动并不为其他class文件可见，除非对他们也重新编译。</li>
</ul>
<p><strong>final变量的初始化</strong></p>
<p><strong>共性：</strong></p>
<ol>
<li>final在初始化之后，就不能再赋值了，也就是说，它们只能被赋值一次</li>
<li>一般情况下是定义时直接初始化如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i=<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>但也可以定义时不初始化，叫blank final,如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> bi;</span><br></pre></td></tr></table></figure>
<p>然后留待后面进行赋值。</p>
<p><strong>但这因三种情况而不同：</strong></p>
<p>1.普通auto变量(就是如方法中的局部变量)：可以在其后的代码中赋值，但也可以不赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i;<span class="comment">//blank final</span></span><br><span class="line">anything();</span><br><span class="line">i=<span class="number">1</span>;<span class="comment">//在其后赋值。</span></span><br><span class="line">i=<span class="number">3</span>; <span class="comment">//error!不可再次赋值</span></span><br></pre></td></tr></table></figure>
<p>而成员变量必须被赋值，只是赋值的地方不同：</p>
<ol>
<li>静态成员变量：<br> 静态成员变量必须在静态构造代码中初始化，</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">static</span> &#123; s=<span class="number">3</span>;&#125;<span class="comment">//静态构造块</span></span><br></pre></td></tr></table></figure>
<ol>
<li>非静态成员变量：<br> 必须在构造函数中被赋值。如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> ai;</span><br><span class="line">&#123; ai = <span class="number">3</span>; &#125;<span class="comment">//instance initializer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Contructor</span><span class="params">()</span></span>&#123;ai=<span class="number">3</span>;&#125;<span class="comment">//构造函数中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Contructor</span><span class="params">(<span class="keyword">int</span> in)</span></span>&#123;ai=in;&#125;<span class="comment">//构造函数中</span></span><br></pre></td></tr></table></figure>
<p>注意构造函数可以会有互相调用，注意在这过程中不要使变量被重复的赋值。</p>
<p>另外，如果变量是对象或数组这样的引用类型。则可以操作其对象或数组，但不可以改变引用本身：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> [] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//一个由三个数字组成的数组。</span></span><br><span class="line">array[<span class="number">1</span>]=<span class="number">9</span>;<span class="comment">//array == &#123;1,9,3&#125;</span></span><br><span class="line"><span class="comment">// array=new int[6]; error!</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="2-7-写出三种单例模式实现-。"><a href="#2-7-写出三种单例模式实现-。" class="headerlink" title="2.7 写出三种单例模式实现 。"></a>2.7 写出三种单例模式实现 。</h4><p>​    <strong>单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点！</strong></p>
<ol>
<li><p>懒汉，线程不安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。</p>
</li>
<li><p>饿汉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式基于classloder机制避免了多线程的同步问题，instance在类装载时就实例化。目前java单例是指一个虚拟机的范围，因为装载类的功能是虚拟机的，所以一个虚拟机在通过自己的ClassLoader装载饿汉式实现单例类的时候就会创建一个类的实例。这就意味着一个虚拟机里面有很多ClassLoader，而这些classloader都能装载某个类的话，就算这个类是单例，也能产生很多实例。当然如果一台机器上有很多虚拟机，那么每个虚拟机中都有至少一个这个类的实例的话，那这样 就更不会是单例了。(这里讨论的单例不适合集群！)</p>
</li>
<li><p>静态内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​      这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载！这个时候，这种方式相比第2种方式就显得很合理。</p>
<p> 4.枚举 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。</p>
<p>5.双重校验锁(jdk1.5)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">		    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样方式实现线程安全地创建实例，而又不会对性能造成太大影响。它只是第一次创建实例的时候同步，以后就不需要同步了。</p>
<p>由于volatile关键字屏蔽了虚拟机中一些必要的代码优化，所以运行效率并不是很高，因此建议没有特别的需要不要使用。双重检验锁方式的单例不建议大量使用，根据情况决定。</p>
<p><strong>总结</strong></p>
<p>有两个问题需要注意：</p>
<p>1.如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。</p>
<p>2.如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。</p>
<p>对第一个问题修复的办法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">getClass</span><span class="params">(String classname)</span>    </span></span><br><span class="line"><span class="function">                                         <span class="keyword">throws</span> ClassNotFoundException </span>&#123;   </span><br><span class="line">      ClassLoader classLoader = Thread.currentThread().getContextClassLoader();   </span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span>(classLoader == <span class="keyword">null</span>)   </span><br><span class="line">         classLoader = Singleton<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;   </span><br><span class="line">    </span><br><span class="line">      <span class="keyword">return</span> (classLoader.loadClass(classname));   </span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对第二个问题修复的办法是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();   </span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">      </span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">            <span class="keyword">return</span> INSTANCE;   </span><br><span class="line">      &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-8-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。"><a href="#2-8-如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。" class="headerlink" title="2.8 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。"></a>2.8 如何在父类中为子类自动完成所有的hashcode和equals实现？这么做有何优劣。</h4><p><strong>覆盖equals时需要遵守的通用约定：</strong><br>覆盖equals方法看起来似乎很简单，但是如果覆盖不当会导致错误，并且后果相当严重。《Effective Java》一书中提到“最容易避免这类问题的办法就是不覆盖equals方法”，这句话貌似很搞笑，其实想想也不无道理，其实在这种情况下，类的每个实例都只与它自身相等。如果满足了以下任何一个条件，这就正是所期望的结果：</p>
<ul>
<li><strong>类的每个实例本质上都是唯一的</strong>。对于代表活动实体而不是值的类来说却是如此，例如Thread。Object提供的equals实现对于这些类来说正是正确的行为。</li>
<li><strong>不关心类是否提供了“逻辑相等”的测试功能。</strong>假如Random覆盖了equals，以检查两个Random实例是否产生相同的随机数序列，但是设计者并不认为客户需要或者期望这样的功能。在这样的情况下，从Object继承得到的equals实现已经足够了。</li>
<li><strong>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的</strong>。大多数的Set实现都从AbstractSet继承equals实现，List实现从AbstractList继承equals实现，Map实现从AbstractMap继承equals实现。</li>
<li><strong>类是私有的或者是包级私有的，可以确定它的equals方法永远不会被调用</strong>。在这种情况下，无疑是应该覆盖equals方法的，以防止它被意外调用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(); <span class="comment">//Method is never called</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在覆盖equals方法的时候，你必须要遵守它的通用约定。下面是约定的内容，来自Object的规范[JavaSE6]</p>
<ul>
<li><p><strong>自反性</strong>。对于任何非null的引用值x，x.equals(x)必须返回true。</p>
</li>
<li><p><strong>对称性</strong>。对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true</p>
</li>
<li><strong>传递性</strong>。对于任何非null的引用值x、y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true。</li>
<li><strong>一致性</strong>。对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用该x.equals(y)就会一直地返回true，或者一致地返回false。</li>
<li>对于任何非null的引用值x，x.equals(null)必须返回false。</li>
</ul>
<p><strong>结合以上要求，得出了以下实现高质量equals方法的诀窍：</strong></p>
<ul>
<li><p><strong>使用==符号检查“参数是否为这个对象的引用”</strong>。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。</p>
</li>
<li><p><strong>使用instanceof操作符检查“参数是否为正确的类型”</strong>。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。</p>
</li>
<li>把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。</li>
<li><strong>对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配</strong>。如果这些测试全部成功，则返回true;否则返回false。</li>
<li><strong>当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”</strong>。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>覆盖equals时总要覆盖hashCode 《Effective Java》作者说的</li>
<li>不要企图让equals方法过于只能。</li>
<li>不要将equals声明中的Object对象替换为其他的类型（因为这样我们并没有覆盖Object中的equals方法哦）</li>
</ul>
<p><strong>覆盖equals时总要覆盖hashCode</strong><br>  一个很常见的错误根源在于没有覆盖hashCode方法。在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。</p>
<ul>
<li>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li>
<li>如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。</li>
<li>如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。</li>
</ul>
<h4 id="2-9-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。"><a href="#2-9-请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。" class="headerlink" title="2.9 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。"></a>2.9 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。</h4><p>访问修饰符，主要标示修饰块的作用域，方便隔离防护</p>
<p>作用域   类内部   同包   子类    其他包</p>
<p>public       √          √           √            √<br>protected √         √            √            ×<br>friendly     √         √            ×            ×<br>private      √         ×            ×            ×</p>
<p>public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不</p>
<p>仅可以跨类访问，而且允许跨包（package）访问。</p>
<p>private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以</p>
<p>及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。</p>
<p>protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、</p>
<p>属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。</p>
<p>default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访</p>
<p>问。</p>
<h4 id="3-0-深拷贝和浅拷贝区别。"><a href="#3-0-深拷贝和浅拷贝区别。" class="headerlink" title="3.0 深拷贝和浅拷贝区别。"></a>3.0 深拷贝和浅拷贝区别。</h4><p><strong>什么是拷贝?</strong></p>
<p>开始之前，我要先强调一下 Java 中的拷贝是什么。首先，让我们对引用拷贝和对象拷贝进行一下区分。 </p>
<p><strong>引用拷贝</strong>, 正如它的名称所表述的意思, 就是创建一个指向对象的引用变量的拷贝。如果我们有一个 Car 对象，而且让 <em>myCar</em> 变量指向这个变量，这时候当我们做引用拷贝，那么现在就会有两个 myCar 变量，但是对象仍然只存在一个。</p>
<p><img src="http://static.oschina.net/uploads/space/2016/1102/110619_NSfb_2903254.jpg" alt="img"></p>
<p><strong>对象拷贝</strong>会创建对象本身的一个副本。因此如果我们再一次服务我们 car 对象，就会创建这个对象本身的一个副本, 同时还会有第二个引用变量指向这个被复制出来的对象。</p>
<p><img src="http://static.oschina.net/uploads/space/2016/1102/110634_VqLp_2903254.jpg" alt="img"></p>
<p><strong>什么是对象?</strong> </p>
<p>深拷贝和浅拷贝都是对象拷贝, 但一个对象实际是什么呢? 当我们谈论到对象时，我们经常会说它就像一粒浑圆的咖啡豆，已经是一个不能够被进一步分解的单位了，但这种说法太过于简化了。</p>
<p><img src="http://static.oschina.net/uploads/space/2016/1102/110649_3o2i_2903254.jpg" alt="img"></p>
<p>比方说我们有一个 Person 对象。这个 Person 对象实际上是由其它的对象组合而成的。如下图所示， Person 对象包含了一个 Name 对象和一个 Address 对象。<em>Name 对象又包含了</em>一个 <em>FirstName</em> 对象和一个 <em>LastName</em> 对象；Address 对象又是由一个 <em>Street</em> 对象以及一个 <em>City</em> 对象组合而成的。那么当我们讨论本文中的这个 Person 时，实际上我是在讨论这些个对象所组成的整个的对象联系网络。</p>
<p><img src="http://static.oschina.net/uploads/space/2016/1102/110706_c4aV_2903254.jpg" alt="img"></p>
<p>那么为什么我会要对这个 Person 对象进行拷贝呢? 对象复制，经常也会被称作克隆，它是在我们想要修改或者移除某个对象，但仍然想要保留原来的那个对象时所要进行的操作。</p>
<p><strong>浅拷贝</strong> </p>
<p>首先让我们来说说浅拷贝。对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。例如，我们会为一个 Person对象创建第二个 <em>Person 对象</em>, 而两个 <em>Person</em> 会共享相同的 Name 和 Address 对象。</p>
<p>让我们来看看代码示例。如中，我们有一个类 Person，类里面包含了一个 Name 和 Address 对象。拷贝构造器会拿到 originalPerson 对象，然后对其应用变量进行复制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Name name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Person originalPerson)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = originalPerson.name;</span><br><span class="line">         <span class="keyword">this</span>.address = originalPerson.address;</span><br><span class="line">    &#125;</span><br><span class="line">[…]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浅拷贝的问题就是两个对象并非独立的。如果你修改了其中一个 Person 对象的 Name 对象，那么这次修改也会影响奥另外一个 Person 对象。</p>
<p>让我们在示例中看看这个问题。假如说我们有一个 Person 对象，然后也会有一个引用变量 monther 来指向它；然后当我们对 mother 进行拷贝时，创建第二个 Person 对象 son。如果在此后的代码中， son 尝试用 <em>moveOut()</em> 来修改他的 <em>Address</em> 对象, 那么 mother 也会跟着他一起搬走!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person mother = <span class="keyword">new</span> Person(<span class="keyword">new</span> Name(…), <span class="keyword">new</span> Address(…));</span><br><span class="line">[…]</span><br><span class="line">Person son  = <span class="keyword">new</span> Person(mother);</span><br><span class="line">[…]</span><br><span class="line">son.moveOut(<span class="keyword">new</span> Street(…), <span class="keyword">new</span> City(…));</span><br></pre></td></tr></table></figure>
<p>这种现象之所以会发生，是因为 mother 和son 对象共享了相同的 Address 对象，如你在示例 7 中所看到的描述。当我们在一个对象中修改了 Address 对象，那么也就表示两个对象总的 Address 都被修改了。</p>
<p><img src="http://static.oschina.net/uploads/space/2016/1102/110725_sZVi_2903254.jpg" alt="img"></p>
<p><strong>深拷贝</strong> </p>
<p>不同于浅拷贝，深拷贝是一个<strong>整个独立的对象拷贝。</strong>如果我们对整个 Person对象进行深拷贝，我们会对整个对象的结构都进行拷贝。</p>
<p><img src="http://static.oschina.net/uploads/space/2016/1102/110737_JstE_2903254.jpg" alt="img"></p>
<p>如你在上图中所见，对一个 Person 的Address对象进行了修改并不会对另外一个对象造成影响。当我们观察示下面的代码，会发现我们不单单对 Person 对象使用了拷贝构造器，同时也会对里面的对象使用拷贝构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Name name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Person otherPerson)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name    =  <span class="keyword">new</span> Name(otherPerson.name);</span><br><span class="line">         <span class="keyword">this</span>.address =  <span class="keyword">new</span> Address(otherPerson.address);</span><br><span class="line">    &#125;</span><br><span class="line">[…]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种深拷贝，我们可以重新尝试示上面的 mother-son 这个用例。现在 son 可以成功的搬走了！</p>
<p>不过，故事到这儿并没有结束。要创建一个真正的深拷贝，就需要我们一直这样拷贝下去，一直覆盖到 Person 对象所有的内部元素, 最后只剩下原始的类型以及“不可变对象（<strong>Immutables）</strong>”。让我们观察下如下这个 Street 类以获得更好的理解:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Street</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Street</span><span class="params">(Street otherStreet)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.name = otherStreet.name;</span><br><span class="line">         <span class="keyword">this</span>.number = otherStreet.number;</span><br><span class="line">    &#125;</span><br><span class="line">[…]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Street 对象有两个实体变量组成 – <em>String 类型的 name</em> 以及 <em>int 类型的 number</em>。<em>int  类型的 number</em> 是一个原始类型，并非对象。它只是一个简单的值，不能共享, 因此在创建第二个实体变量时，我们可以自动创建一个独立的拷贝。<em>String</em> 是一个不可变对象（Immutable）。简言之，不可变对象也是对象，可一旦创建好了以后就再也不能被修改了。因此，你可以不用为其创建深拷贝就能对其进行共享。</p>
<p><strong>总结</strong> </p>
<p>作为总结，我要说说上面在 mother-son 示例中所用到的一些编码技术。只是因为深拷贝可以让你修改一个对象里面的详细信息，比如 Address 对象，这并不意味着你就该这样做。这样做<strong>会提高代码的质量</strong>, 因为它可以使得 Person 更容易修改 – 不管 <em>Address 类什么时候被修改了，你也都会要</em>修改应用到 Person 类。例如，如果 Address 类型不再包含 Street 对象了，我们就得根据已经对 Address 类做出的修改来对Person 类中的 <em>moveOut()</em>  方法进行修改。</p>
<p>在本文中，我只选择使用了一个新的 Street 和 City 对象，这样可以更好的对浅拷贝和深拷贝的不同之处进行描述。不过，我会建议你给方法分配一个新的 Address 对象，这样能有效的将其转换成一个浅拷贝和深拷贝的<strong>混合体</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person mother = <span class="keyword">new</span> Person(<span class="keyword">new</span> Name(…), <span class="keyword">new</span> Address(…));</span><br><span class="line">[…]</span><br><span class="line">Person son  = <span class="keyword">new</span> Person(mother);</span><br><span class="line">[…]</span><br><span class="line">son.moveOut(<span class="keyword">new</span> Address(...));</span><br></pre></td></tr></table></figure>
<p>在面向对象领域，这样做违背了封装的原则，因此应该被避免。封装<strong>是面向对象编程中一个最重要的方面。</strong>在这里，我已经违背封装的原则，对 Person 类中 Address 对象的内部细节进行了访问。这样做对我们的代码造成了伤害，因为我们现在跟 Person 类中的 Address 类纠缠在一起，如果对 Address 类进行了修改，就会如我上面所解释的对代码造成伤害。不过是你显然是会需要将你定义的各种类互相联系在一起以构成代码工程的，但在你要将两个类联系在一起时，需要好好分析一下成本和收益。</p>
<h4 id="3-1-数组和链表数据结构描述，各自的时间复杂度。"><a href="#3-1-数组和链表数据结构描述，各自的时间复杂度。" class="headerlink" title="3.1 数组和链表数据结构描述，各自的时间复杂度。"></a>3.1 数组和链表数据结构描述，各自的时间复杂度。</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h5><p><strong>数组</strong>　</p>
<p>是将元素在内存中<strong>连续存放</strong>，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要<strong>快速访问数据，很少插入和删除元素，就应该用数组。</strong></p>
<p><strong>链表</strong>　</p>
<p>元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起，每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的 指针。<br>如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要<strong>经常插入和删除元素你就需要用链表</strong>。</p>
<p><strong>内存存储区别</strong></p>
<p>数组从<strong>栈</strong>中分配空间, 对于程序员方便快速,但自由度小。</p>
<p>链表从<strong>堆</strong>中分配空间, 自由度大但申请管理比较麻烦.　</p>
<p><strong>逻辑结构区别</strong></p>
<p>数组必须事先定义<strong>固定的长度</strong>（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。　</p>
<p>链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项）　</p>
<p><strong>总结</strong></p>
<p>1、存取方式上，数组可以顺序存取或者随机存取，而链表只能顺序存取；　</p>
<p>2、存储位置上，数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定；　</p>
<p>3、存储空间上，链表由于带有指针域，存储密度不如数组大；　</p>
<p>4、按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)；　</p>
<p>5、按值查找时，若数组无序，数组和链表时间复杂度均为O(n)，但是当数组有序时，可以采用二分查找将时间复杂度降为O(logn)；　</p>
<p>6、插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可；　</p>
<p>7、空间分配方面：<br>数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移                                             动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败；<br>链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；</p>
<h4 id="3-2-error和exception的区别，CheckedException，RuntimeException的区别。"><a href="#3-2-error和exception的区别，CheckedException，RuntimeException的区别。" class="headerlink" title="3.2 error和exception的区别，CheckedException，RuntimeException的区别。"></a>3.2 error和exception的区别，CheckedException，RuntimeException的区别。</h4><p><strong>Exception</strong><br>一般分为Checked异常和Runtime异常，所有RuntimeException类及其子类的实例被称为Runtime异常，不属于该范畴的异常则被称为CheckedException。</p>
<p><strong>Checked异常</strong><br>只有java语言提供了Checked异常，Java认为Checked异常都是可以被处理的异常，所以Java程序必须显示处理Checked异常。如果程序没有处理Checked异常，该程序在编译时就会发生错误无法编译。这体现了Java的设计哲学：没有完善错误处理的代码根本没有机会被执行。对Checked异常处理方法有两种</p>
<p>1 当前方法知道如何处理该异常，则用try…catch块来处理该异常。<br>2 当前方法不知道如何处理，则在定义该方法是声明抛出该异常。</p>
<p>我们比较熟悉的Checked异常有</p>
<p>Java.lang.ClassNotFoundException<br>Java.lang.NoSuchMetodException<br>java.io.IOException</p>
<p><strong>RuntimeException</strong><br>Runtime如除数是0和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。</p>
<p>我们比较熟悉的RumtimeException子类：</p>
<p>Java.lang.ArithmeticException<br>Java.lang.ArrayStoreExcetpion<br>Java.lang.ClassCastException<br>Java.lang.IndexOutOfBoundsException<br>Java.lang.NullPointerException</p>
<p><strong>Error</strong><br>当程序发生不可控的错误时，通常做法是通知用户并中止程序的执行。与异常不同的是Error及其子类的对象不应被抛出。</p>
<p>Error是throwable的子类，代表编译时间和系统错误，用于指示合理的应用程序不应该试图捕获的严重问题。</p>
<p>Error由Java虚拟机生成并抛出，包括动态链接失败，虚拟机错误等。程序对其不做处理。</p>
<h4 id="3-3-请列出5个运行时异常。"><a href="#3-3-请列出5个运行时异常。" class="headerlink" title="3.3 请列出5个运行时异常。"></a>3.3 请列出5个运行时异常。</h4><p>Java.lang.ArithmeticException<br>Java.lang.ArrayStoreExcetpion<br>Java.lang.ClassCastException<br>Java.lang.IndexOutOfBoundsException<br>Java.lang.NullPointerException</p>
<h4 id="3-4-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。"><a href="#3-4-在自己的代码中，如果创建一个java-lang-String类，这个类是否可以被类加载器加载？为什么。" class="headerlink" title="3.4 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。"></a>3.4 在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么。</h4><p><strong>双亲委派模型</strong><br>类加载器可分为两类：一是启动类加载器(Bootstrap ClassLoader)，是C++实现的，是JVM的一部分；另一种是其它的类加载器，是Java实现的，独立于JVM，全部都继承自抽象类java.lang.ClassLoader。jdk自带了三种类加载器，分别是启动类加载器（Bootstrap ClassLoader），扩展类加载器（Extension ClassLoader），应用程序类加载器（Application ClassLoader）。后两种加载器是继承自抽象类java.lang.ClassLoader。</p>
<p>一般是： 自定义类加载器 &gt;&gt; 应用程序类加载器 &gt;&gt; 扩展类加载器 &gt;&gt; 启动类加载器</p>
<p>上面的层次关系被称为双亲委派模型(Parents Delegation Model)。除了最顶层的启动类加载器外，其余的类加载器都有对应的父类加载器。</p>
<p>简单说下双亲委托机制：如果一个类加载器收到了类加载的请求，它首先不会自己尝试去加载这个类，而是把这个请求委派给父类加载器，每一个层次的类加载器都是加此，因此所有的加载请求最终到达顶层的启动类加载器，只有当父类加载器反馈自己无法完成加载请求时（指它的搜索范围没有找到所需的类），子类加载器才会尝试自己去加载。</p>
<p>各个类加载器之间是组合关系，并非继承关系。</p>
<p>双亲委派模型可以确保安全性，可以保证所有的Java类库都是由启动类加载器加载。如用户编写的java.lang.Object，加载请求传递到启动类加载器，启动类加载的是系统中的Object对象，而用户编写的java.lang.Object不会被加载。如用户编写的java.lang.virus类，加载请求传递到启动类加载器，启动类加载器发现virus类并不是核心Java类，无法进行加载，将会由具体的子类加载器进行加载，而经过不同加载器进行加载的类是无法访问彼此的。由不同加载器加载的类处于不同的运行时包。所有的访问权限都是基于同一个运行时包而言的。</p>
<p><strong>为什么要使用这种双亲委托模式呢？</strong><br>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。</p>
<p>考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的ClassLoader。</p>
<p>思考：假如我们自己写了一个java.lang.String的类，我们是否可以替换调JDK本身的类？<br>答案是否定的。我们不能实现。为什么呢？我看很多网上解释是说双亲委托机制解决这个问题，其实不是非常的准确。因为双亲委托机制是可以打破的，你完全可以自己写一个classLoader来加载自己写的java.lang.String类，但是你会发现也不会加载成功，具体就是因为针对java.*开头的类，jvm的实现中已经保证了必须由bootstrp来加载。</p>
<p>因加载某个类时，优先使用父类加载器加载需要使用的类。如果我们自定义了java.lang.String这个类， 加载该自定义的String类，该自定义String类使用的加载器是AppClassLoader，根据优先使用父类加载器原理， AppClassLoader加载器的父类为ExtClassLoader，所以这时加载String使用的类加载器是ExtClassLoader， 但是类加载器ExtClassLoader在jre/lib/ext目录下没有找到String.class类。然后使用ExtClassLoader父类的加载器BootStrap， 父类加载器BootStrap在JRE/lib目录的rt.jar找到了String.class，将其加载到内存中。这就是类加载器的委托机制。</p>
<p><strong>定义自已的ClassLoader</strong><br>既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？</p>
<p>因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。</p>
<p>定义自已的类加载器分为两步：</p>
<p>1、继承java.lang.ClassLoader</p>
<p>2、重写父类的findClass方法</p>
<p>可能在这里有疑问，父类有那么多方法，为什么偏偏只重写findClass方法？</p>
<p>因为JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法，当在loadClass方法中搜索不到类时，loadClass方法就会调用findClass方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写loadClass搜索类的算法。</p>
<h4 id="3-5-说一说你对java-lang-Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。"><a href="#3-5-说一说你对java-lang-Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。" class="headerlink" title="3.5 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。"></a>3.5 说一说你对java.lang.Object对象中hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。</h4><p><strong>hashcode</strong></p>
<p>hashcode（）方法提供了对象的hashCode值，是一个native方法，返回的默认值与System.identityHashCode(obj)一致。</p>
<p>通常这个值是对象头部的一部分二进制位组成的数字，具有一定的标识对象的意义存在，但绝不定于地址。</p>
<p>作用是：用一个数字来标识对象。比如在HashMap、HashSet等类似的集合类中，如果用某个对象本身作为Key，即要基于这个对象实现Hash的写入和查找，那么对象本身如何实现这个呢？就是基于hashcode这样一个数字来完成的，只有数字才能完成计算和对比操作。</p>
<p><strong>hashcode是否唯一</strong></p>
<p>hashcode只能说是标识对象，在hash算法中可以将对象相对离散开，这样就可以在查找数据的时候根据这个key快速缩小数据的范围，但<strong>hashcode不一定是唯一的，所以hash算法中定位到具体的链表后，需要循环链表，然后通过equals方法来对比Key是否是一样的</strong>。</p>
<p><strong>equals与hashcode的关系</strong></p>
<p>equals相等两个对象，则hashcode一定要相等。但是hashcode相等的两个对象不一定equals相等。</p>
<p><strong>小结</strong></p>
<p>hashcode是为了算法快速定位数据而存在的，而equals是为了对比真实值而存在的。</p>
<h4 id="3-6-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。"><a href="#3-6-在jdk1-5中，引入了泛型，泛型的存在是用来解决什么问题。" class="headerlink" title="3.6 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。"></a>3.6 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。</h4><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。</p>
<p><strong>第一是泛化。</strong>可以用T代表任意类型Java语言中引入泛型是一个较大的功能增强不仅语言、类型系统和编译器有了较大的变化，以支持泛型，而且类库也进行了大翻修，所以许多重要的类，比如集合框架，都已经成为泛型化的了，这带来了很多好处。</p>
<p><strong>第二是类型安全。</strong>泛型的一个主要目标就是提高ava程序的类型安全，使用泛型可以使编译器知道变量的类型限制，进而可以在更高程度上验证类型假设。如果不用泛型，则必须使用强制类型转换，而强制类型转换不安全，在运行期可能发生ClassCast Exception异常，如果使用泛型，则会在编译期就能发现该错误。</p>
<p><strong>第三是消除强制类型转换。</strong>泛型可以消除源代码中的许多强制类型转换，这样可以使代码更加可读，并减少出错的机会。</p>
<p><strong>第四是向后兼容。</strong>支持泛型的Java编译器（例如JDK1.5中的<a href="https://baike.baidu.com/item/Javac/5156702" target="_blank" rel="noopener">Javac</a>）可以用来编译经过泛型扩充的Java程序（Generics Java程序），但是现有的没有使用泛型扩充的Java程序仍然可以用这些编译器来编译。</p>
<h4 id="3-7-这样的a-hashcode-有什么用，与a-equals-b-有什么关系。"><a href="#3-7-这样的a-hashcode-有什么用，与a-equals-b-有什么关系。" class="headerlink" title="3.7 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。"></a>3.7 这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。</h4><p>equals相等两个对象，则hashcode一定要相等。但是hashcode相等的两个对象不一定equals相等。</p>
<h4 id="3-8-有没有可能2个不相等的对象有相同的hashcode。"><a href="#3-8-有没有可能2个不相等的对象有相同的hashcode。" class="headerlink" title="3.8 有没有可能2个不相等的对象有相同的hashcode。"></a>3.8 有没有可能2个不相等的对象有相同的hashcode。</h4><p>有</p>
<h4 id="3-9-Java中的HashSet内部是如何工作的。"><a href="#3-9-Java中的HashSet内部是如何工作的。" class="headerlink" title="3.9 Java中的HashSet内部是如何工作的。"></a>3.9 Java中的HashSet内部是如何工作的。</h4><p>对于 HashSet 而言，它是基于 HashMap 实现的，底层采用 HashMap 来保存元素</p>
<p>我们先通过 HashSet 最简单的构造函数和几个成员变量来看一下，证明咱们上边说的，其底层是 HashMap：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment"> * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在英文注释中已经说的比较明确了。首先有一个HashMap的成员变量，我们在 HashSet 的构造函数中将其初始化，默认情况下采用的是 initial capacity为16，load factor 为 0.75。</p>
<p><strong>HashSet 的实现</strong></p>
<p>对于 HashSet 而言，它是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，我们应该为保存到 HashSet 中的对象覆盖 hashCode() 和 equals()</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认的无参构造器，构造一个空的HashSet。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含指定collection中的元素的新set。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实际底层使用默认的加载因子0.75和足以包含指定collection中所有元素的初始容量来创建一个HashMap。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 其中的元素将存放在此set中的collection。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(Math.max((<span class="keyword">int</span>) (c.size()/.<span class="number">75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以指定的initialCapacity和loadFactor构造一个空的HashSet。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实际底层以相应的参数构造一个空的HashMap。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 加载因子。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以指定的initialCapacity构造一个空的HashSet。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实际底层以相应的参数及加载因子loadFactor为0.75构造一个空的HashMap。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;E,Object&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。此构造函数为包访问权限，不对外公开，</span></span><br><span class="line"><span class="comment"> * 实际只是是对LinkedHashSet的支持。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实际底层会以指定的参数构造一个空LinkedHashMap实例来实现。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialCapacity 初始容量。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loadFactor 加载因子。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dummy 标记。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>add 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 将添加到此set中的元素。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果此set尚未包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果此 set 中尚未包含指定元素，则添加指定元素。更确切地讲，如果此 set 没有包含满足(e==null ? e2==null : e.equals(e2)) 的元素 e2，则向此 set 添加指定的元素 e。如果此 set 已包含该元素，则该调用不更改 set 并返回 false。但底层实际将将该元素作为 key 放入 HashMap。思考一下为什么？</p>
<p>由于 HashMap 的 put() 方法添加 key-value 对时，当新放入 HashMap 的 Entry 中 key 与集合中原有 Entry 的 key 相同（hashCode()返回值相等，通过 equals 比较也返回 true），新添加的 Entry 的 value 会将覆盖原来 Entry 的 value（HashSet 中的 value 都是<code>PRESENT</code>），但 key 不会有任何改变，因此如果向 HashSet 中添加一个已经存在的元素时，新添加的集合元素将不会被放入 HashMap中，原来的元素也不会有任何改变，这也就满足了 Set 中元素不重复的特性。</p>
<p>该方法如果添加的是在 HashSet 中不存在的，则返回 true；如果添加的元素已经存在，返回 false。其原因在于我们之前提到的关于 HashMap 的 put 方法。该方法在添加 key 不重复的键值对的时候，会返回 null。</p>
<p><strong>其余方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此set包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment">     * 更确切地讲，当且仅当此set包含一个满足(o==null ? e==null : o.equals(e))的e元素时，返回true。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的containsKey判断是否包含指定key。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 在此set中的存在已得到测试的元素。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果此set包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果指定元素存在于此set中，则将其移除。更确切地讲，如果此set包含一个满足(o==null ? e==null : o.equals(e))的元素e，</span></span><br><span class="line"><span class="comment">     * 则将其移除。如果此set已包含该元素，则返回true</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的remove方法删除指定Entry。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 如果存在于此set中则需要将其移除的对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果set包含指定元素，则返回true。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此HashSet实例的浅表副本：并没有复制这些元素本身。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 底层实际调用HashMap的clone()方法，获取HashMap的浅表副本，并设置到HashSet中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();</span><br><span class="line">            <span class="keyword">return</span> newSet;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>相关说明</strong></p>
<ol>
<li>相关 HashMap 的实现原理，请参考上面的点</li>
<li>对于 HashSet 中保存的对象，请注意正确重写其 equals 和 hashCode 方法，以保证放入的对象的唯一性。这两个方法是比较重要的，希望大家在以后的开发过程中需要注意一下。</li>
</ol>
<h4 id="4-0-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。"><a href="#4-0-什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。" class="headerlink" title="4.0 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。"></a>4.0 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。</h4><p>序列化与反序列化是开发过程中不可或缺的一步，简单来说，序列化是将对象转换成字节流的过程，而反序列化的是将字节流恢复成对象的过程。序列化与反序列化是一个标准（具体参考<a href>XDR:外部数据表示标准 RFC 1014</a>），它是编程语言的一种共性，只是有些编程语言是内置的（如Java，PHP等），有些语言是通过第三方库来实现的（如C/C++）。</p>
<p> 使用场景</p>
<ul>
<li>对象的持久化（将对象内容保存到数据库或文件中）</li>
<li>远程数据传输（将对象发送给其他计算机系统）</li>
</ul>
<p><strong>为什么需要序列化与序列化？</strong></p>
<p>序列化与序列化主要解决的是数据的一致性问题。简单来说，就是输入数据与输出数据是一样的。</p>
<p>对于数据的本地持久化，只需要将数据转换为字符串进行保存即可是实现，但对于远程的数据传输，由于操作系统，硬件等差异，会出现内存大小端，内存对齐等问题，导致接收端无法正确解析数据，为了解决这种问题，Sun Microsystems在20世纪80年代提出了XDR规范，于1995年正式成为IETF标准。</p>
<p><strong>Java中的序列化与反序列化</strong></p>
<p>Java语言内置了序列化和反序列化，通过Serializable接口实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> birthday;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>序列化兼容性</strong></p>
<p>序列化的兼容性指的是对象的结构变化（如增删字段，修改字段，字段修饰符的改变等）对序列化的影响。为了能够识别对象结构的变化，Serializable使用serialVersionUID字段来标识对象的结构。默认情况下，它会根据对象的数据结构自动生成，结构发生变化后，它的值也会跟随变化。虚拟机在反序列化的时候会检查serialVersionUID的值，如果字节码中的serialVersionUID和要被转换的类型的serialVersionUID不一致，就无法进行正常的反序列化。</p>
<p>示例：将Account对象保存到文件中，然后在Account类中添加address字段，再从文件中读取之前保存的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将Account对象保存到文件中</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(account);</span><br><span class="line">oos.flush();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改Account对象的结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> birthday;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String address;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">this</span>.age = age;</span><br><span class="line">	    <span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取Account的内容</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">Account account2 = (Account)ois.readObject();</span><br></pre></td></tr></table></figure>
<p>由于在保存Account对象后修改了Account的结构，会导致serialVersionUID的值发生变化，在读文件（反序列化）的时候就会出错。所以为了更好的兼容性，在序列化的时候，最好将serialVersionUID的值设置为固定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> birthday;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>序列化的存储规则</strong></p>
<p>Java中的序列化在将对象持久化（序列化）的时候，为了节省磁盘空间，对于相同的对象会进行优化。当多次保存相同的对象时，其实保存的只是第一个对象的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将account对象保存两次，第二次保存时修改其用户名</span></span><br><span class="line">Account account = <span class="keyword">new</span> Account(<span class="string">"Freeman"</span>);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">oos.writeObject(account);</span><br><span class="line">System.out.println(<span class="string">"fileSize="</span> +file.length());</span><br><span class="line">account.setUserName(<span class="string">"Tom"</span>);</span><br><span class="line">oos.writeObject(account);</span><br><span class="line">System.out.println(<span class="string">"fileSize="</span> +file.length());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取两次保存的account对象</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">Account account2 = (Account)ois.readObject();</span><br><span class="line">Account account3 = (Account)ois.readObject();</span><br><span class="line">System.out.println(<span class="string">"account2.name="</span> + account2.getUserName() + <span class="string">"\n  account3.name="</span> + account3.getUserName() + <span class="string">"\naccount2==account3 -&gt; "</span> + account2.equals(account3));</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">account2.name=Freeman  </span><br><span class="line">account3.name=Freeman </span><br><span class="line">account2==account3 -&gt; <span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>所以在对同一个对象进行多次序列化的时候，最好通过clone一个新的对象再进行序列化。</p>
<p><strong>序列化对单例的影响</strong></p>
<p>反序列化的时候，JVM会根据序列化生成的内容构造新的对象，对于实现了Serializable的单例类来说，这相当于开放了构造方法。为了保证单例类实例的唯一性，我们需要重写resolveObject方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在反序列化的时候被调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回根据字节码创建的新对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ObjectStreamException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span><span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>控制序列化过程</strong></p>
<p>虽然直接使用Serializable很方便，但有时我们并不想序列化所有的字段，如标识选中状态的isSelected字段，涉及安全问题的password字段等。此时可通过通过以下方法实现：</p>
<ol>
<li>给不想序列化的字段添加static或transient修饰词：</li>
</ol>
<p>Java中的序列化保存的只是对象的成员变量，既不包括static成员（static成员属于类），也不包括成员方法。同时Java为了让序列化更灵活，提供了transient关键字，用来关闭字段的序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String idcard;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>直接使用Externalizable接口控制序列化过程：</li>
</ol>
<p>Externalizable也是Java提供的序列化接口，与Serializable不同的是，默认情况下，它不会序列化任何成员变量，所有的序列化，反序列化工作都需要手动完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> String userName;</span><br><span class="line">	<span class="keyword">private</span> String idcard;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		out.writeObject(userName);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">		userName = (String) in.readObject();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>自己实现序列化/反序列化过程</p>
<p>public class Account implements Serializable {</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String idcard;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream oos)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">// 调用默认的序列化方法，序列化非transient/static字段</span></span><br><span class="line">	oos.defaultWriteObject();</span><br><span class="line">	oos.writeObject(idcard);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">	<span class="comment">// 调用默认的反序列化方法，发序列化非transient/static字段</span></span><br><span class="line">	ois.defaultReadObject();</span><br><span class="line">	idcard = (String)ois.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}</p>
</li>
</ol>
<p>关于Java序列化算法的详细介绍可参考：<a href="https://longdick.iteye.com/blog/458557" target="_blank" rel="noopener">Java序列化算法透析</a></p>
<p><strong>Java序列化注意事项</strong></p>
<ol>
<li>通过Serializable序列化的对象，在反序列化的时候，直接根据字节码构造对象，并不会调用对象的构造方法；</li>
<li>通过Serializable序列化子类时，如果父类没有实现Serializable接口，那么父类需要提供默认的构造方法，否则在反序列化的时候抛出java.io.NotSerializableException异常；</li>
<li>通过Externalizale实现序列化时，反序列化的时候需要调用对象的默认构造方法；</li>
<li>由于Externalizale默认情况下不会对任何成员变量进行序列化，所以transient关键字只能在Serializable序列化方式中使用；</li>
</ol>
<p><strong>数据交换协议</strong></p>
<p>序列化与反序列化为数据交换提供了可能，但是因为传递的是字节码，可读性差。在应用层开发过程中不易调试，为了解决这种问题，最直接的想法就是将对象的内容转换为字符串的形式进行传递。具体的传输格式可自行定义，但自定义格式有一个很大的问题——兼容性，如果引入其他系统的模块，就需要对数据格式进行转换，维护其他的系统时，还要先了解一下它的序列化方式。为了统一数据传输的格式，出现了几种数据交换协议，如：JSON, Protobuf，XML。这些数据交换协议可视为是应用层面的序列化/反序列化。</p>
<p><strong>JSON</strong></p>
<p>JSON（JavaScript Object Notation）是一种轻量级，完全独立于语言的数据交换格式。目前被广泛应用在前后端的数据交互中。</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>JSON中的元素都是键值对——key:value形式，键值对之间以”:”分隔，每个键需用双引号引起来，值的类型为String时也需要双引号。其中value的类型包括：对象，数组，值，每种类型具有不同的语法表示。</p>
<h6 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h6><p>对象是一个无序的键值对集合。以”{“开始，以”}”结束， 每个成员以”,”分隔。例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"value" : &#123;</span><br><span class="line">    "name": "Freeman",</span><br><span class="line">    "gender": 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h6><p>数组是一个有序的集合，以”[“开始，以”]”结束，成员之间以”,”分隔。例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"value" : [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"zhangsan"</span>,</span><br><span class="line">        <span class="attr">"gender"</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"lisi"</span>,</span><br><span class="line">        <span class="attr">"gender"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h6 id="值"><a href="#值" class="headerlink" title="值"></a>值</h6><p>值类型表示JSON中的基本类型，包括String，Number(byte, short, int, long, float, double), boolean。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"name": "Freeman"</span><br><span class="line">"gender": 1</span><br><span class="line">"registered": false</span><br><span class="line">"article": null</span><br></pre></td></tr></table></figure>
<p>==注意==：对象，数组，值这三种元素可互相嵌套！</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"success"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"zhangsan"</span>,</span><br><span class="line">            <span class="attr">"gender"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"lisi"</span>,</span><br><span class="line">            <span class="attr">"gender"</span>: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于JSON，目前流行的第三方库有<a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a>, <a href="https://github.com/alibaba/fastjson" target="_blank" rel="noopener">fastjson</a>：关于Gson的详细介绍，参考<a href="https://juejin.im/post/5c46fb376fb9a049ca37af33" target="_blank" rel="noopener">Gson使用教程</a></p>
<p><strong>Protobuf</strong></p>
<p><a href="https://github.com/protocolbuffers/protobuf" target="_blank" rel="noopener">Protobuf</a>是Google实现的一种与语言无关，与平台无关，可扩展的序列化方式，比XML更小，更快，使用更简单。</p>
<p>Protobuf具有很高的效率，并且几乎为主流的开发语言都提供了支持，具体参考<a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Protobuf开发文档</a>。</p>
<p>在Android中使用Protobuf，需要<a href="https://github.com/google/protobuf-gradle-plugin" target="_blank" rel="noopener">protobuf-gradle-plugin</a>插件，具体使用查看其项目说明。</p>
<p><strong>XML</strong></p>
<p>XML（Extensible Markup Language）可扩展标记语言，通过标签描述数据。示例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Freeman<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>1<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用这种方式传输数据时，只需要将对象转换成这种标签形式，在接收到数据后，将其转换成相应的对象。</p>
<p>关于JAVA开发中对XML的解析可参考<a href="http://www.cnblogs.com/lanxuezaipiao/archive/2013/05/17/3082949.html" target="_blank" rel="noopener">四种生成和解析XML文档的方法详解</a></p>
<p><strong>数据交换协议如何选择</strong></p>
<p>从性能，数据大小，可读性三方面进行比较，结果如下：</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>性能</th>
<th>数据大小</th>
<th>可读性</th>
</tr>
</thead>
<tbody>
<tr>
<td>JSON</td>
<td>良</td>
<td>良</td>
<td>优</td>
</tr>
<tr>
<td>Protobuf</td>
<td>优</td>
<td>优</td>
<td>差</td>
</tr>
<tr>
<td>XML</td>
<td>中</td>
<td>中</td>
<td>中</td>
</tr>
</tbody>
</table>
<p>对于数据量不是很大，实时性不是特别高的交互，JSON完全可以满足要求，毕竟它的可读性高，出现问题容易定位（注：它是目前前端，app和后端交换数据使用的主流协议）。而对于实时性要求很高，或数据量大的场景，可使用Protobuf协议。具体数据交换协议的比较可参考<a href="https://note.youdao.com/" target="_blank" rel="noopener">github.com/eishay/jvm-…</a></p>
<h4 id="4-1-java8的新特性。"><a href="#4-1-java8的新特性。" class="headerlink" title="4.1 java8的新特性。"></a>4.1 java8的新特性。</h4><p><a href="/2017/02/18/Java-8-最佳技巧/">Java 8-最佳技巧</a></p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法求sqrt (2)精确到小数点后 10 位</title>
    <url>/2019/12/26/%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82sqrt-2-%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E-10-%E4%BD%8D/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h5 id="因为-sqrt-2-约等于-1-4，所以可以在-1-4-1-5-区间做二分"><a href="#因为-sqrt-2-约等于-1-4，所以可以在-1-4-1-5-区间做二分" class="headerlink" title="因为 sqrt(2)约等于 1.4，所以可以在(1.4, 1.5)区间做二分"></a>因为 sqrt(2)约等于 1.4，所以可以在(1.4, 1.5)区间做二分</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> TEN = <span class="number">0.0000000001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sqrt2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> low = <span class="number">1.4</span>;</span><br><span class="line">        <span class="keyword">double</span> high = <span class="number">1.5</span>;</span><br><span class="line">        <span class="keyword">double</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> ((high - low) &gt; TEN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (high * high &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>单向链表逆序输出</title>
    <url>/2019/12/25/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h5 id="实现链表逆序输出"><a href="#实现链表逆序输出" class="headerlink" title="实现链表逆序输出"></a>实现链表逆序输出</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ListNode&lt;T&gt; head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	   <span class="keyword">return</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode&lt;T&gt; currentNode = head;</span><br><span class="line">       Stack&lt;ListNode&lt;T&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">    	   stack.push(currentNode);</span><br><span class="line">    	   ListNode&lt;T&gt; tempNode = currentNode.next;</span><br><span class="line">           <span class="comment">// 断开连接</span></span><br><span class="line">    	   currentNode.next = <span class="keyword">null</span>; </span><br><span class="line">    	   currentNode = tempNode;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       head = stack.pop();</span><br><span class="line">       currentNode = head;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">    	   currentNode.next = stack.pop();</span><br><span class="line">    	   currentNode = currentNode.next;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	T val;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListNode</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode&lt;T&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Github建立分支备份Hexo</title>
    <url>/2019/01/12/Github%E5%BB%BA%E7%AB%8B%E5%88%86%E6%94%AF%E5%A4%87%E4%BB%BDHexo/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于之前忘记备份Hexo博客的markdown文件，在重做系统时候还忘记备份博客了，导致现在不得不重新从网页上扒下来之前的文章重新写一遍，十分耗费精力。因此在网上找了下如何备份Hexo博客，在此记录下。</p>
<h1 id="备份博客"><a href="#备份博客" class="headerlink" title="备份博客"></a>备份博客</h1><p>先将本地Hexo博客已经初始化</p>
<h2 id="创建新分支"><a href="#创建新分支" class="headerlink" title="创建新分支"></a>创建新分支</h2><p>在Github.io上建立博客时已经开了一个新仓库了，如果再开另一个仓库存放源代码有点浪费，因此采用建立新分支的方法备份博客。</p>
<p>虽然理论上什么时候创建新分支来备份都可以，但是还是建议在建立博客的时候就创建备份分支。（然而我中途才想起来-.-）</p>
<p>不过在建立新分支前请确保仓库内已有<code>master</code>分支（Hexo本地建站后第一次上传时会自动生成），否则后期再添加<code>master</code>分支比较麻烦（请自行搜索<code>git</code>命令）。</p>
<p>本地Git建立新分支命令如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">$ git checkout -<span class="keyword">b </span><span class="keyword">BRANCHNAME</span></span><br></pre></td></tr></table></figure>
<p><code>BRANCHNAME</code>是自定义的新分支的名字，建议起为<code>hexo</code>。</p>
<a id="more"></a>
<h2 id="建立-gitignore"><a href="#建立-gitignore" class="headerlink" title="建立.gitignore"></a>建立.gitignore</h2><p>建立<code>.gitignore</code>文件将不需要备份的文件屏蔽。个人的<code>.gitignore</code>文件如下：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">.DS_Store</span></span><br><span class="line">Thumbs<span class="number">.</span><span class="built_in">db</span></span><br><span class="line"><span class="built_in">db</span><span class="number">.</span>json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line"><span class="meta">public</span>/</span><br><span class="line"><span class="meta">.deploy</span>*/</span><br></pre></td></tr></table></figure>
<h2 id="在Github上备份"><a href="#在Github上备份" class="headerlink" title="在Github上备份"></a>在Github上备份</h2><p>通过如下命令将本地文件备份到Github上。</p>
<p>假设目前在hexo博客的根目录下。</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git add .</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">"Backup"</span></span><br><span class="line"><span class="variable">$ </span>git push origin hexo</span><br></pre></td></tr></table></figure>
<p>这样就备份完博客了且在Github上能看到两个分支(<code>master</code>和<code>hexo</code>)。</p>
<h2 id="设置默认分支"><a href="#设置默认分支" class="headerlink" title="设置默认分支"></a>设置默认分支</h2><p>在Github上你的github.io仓库中设置默认分支为<code>hexo</code>。这样有助于之后恢复博客。<code>master</code>分支时默认的博客静态页面分支，在之后恢复博客的时候并不需要。</p>
<h2 id="个人备份习惯"><a href="#个人备份习惯" class="headerlink" title="个人备份习惯"></a>个人备份习惯</h2><p>个人而言习惯于先备份文件再生成博客。即先执行<code>git add .</code>,<code>git commit -m &quot;Backup&quot;</code>,<code>git push origin hexo</code>将博客备份完成，然后执行<code>hexo g -d</code>发布博客。</p>
<h1 id="恢复博客"><a href="#恢复博客" class="headerlink" title="恢复博客"></a>恢复博客</h1><p>先把本地Hexo博客基础环境已经搭好</p>
<h2 id="克隆项目到本地"><a href="#克隆项目到本地" class="headerlink" title="克隆项目到本地"></a>克隆项目到本地</h2><p>输入下列命令克隆博客必须文件(<code>hexo</code>分支)：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">https</span>://github.com/yourgithubname/yourgithubname.github.io</span><br></pre></td></tr></table></figure>
<h2 id="恢复博客-1"><a href="#恢复博客-1" class="headerlink" title="恢复博客"></a>恢复博客</h2><p>在克隆的那个文件夹下输入如下命令恢复博客：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> hexo-cli</span><br><span class="line">$ npm <span class="keyword">install</span></span><br><span class="line">$ npm <span class="keyword">install</span> hexo-deployer-git</span><br></pre></td></tr></table></figure>
<p>在此不需要执行<code>hexo init</code>这条指令，因为不是从零搭建起新博客。</p>
<h2 id="提交准备"><a href="#提交准备" class="headerlink" title="提交准备"></a>提交准备</h2><p>（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“ 把其中的邮件地址换成自己的邮件地址，然后一路回车</p>
<p>（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<p>（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。</p>
<p>完成～</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title>Java解析类Xml格式文件</title>
    <url>/2018/04/30/Java%E8%A7%A3%E6%9E%90%E7%B1%BBXml%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>解析上游发来的类XML格式数据，直接使用<code>Document document = reader.read(path);</code>会失败，因为不包含<code>&lt;root&gt;&lt;/root&gt;</code>，所以这里需要自己手动拼接一下，方便解析，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Element <span class="title">getRoot</span><span class="params">(String path)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">        <span class="comment">//因为数据格式不是标准的xml，手动拼接一下方便解析</span></span><br><span class="line">        Enumeration&lt;InputStream&gt; streams = Collections.enumeration(</span><br><span class="line">                Arrays.asList(<span class="keyword">new</span> InputStream[]&#123;</span><br><span class="line">                        <span class="keyword">new</span> ByteArrayInputStream(<span class="string">"&lt;root&gt;"</span>.getBytes()),</span><br><span class="line">                        is,</span><br><span class="line">                        <span class="keyword">new</span> ByteArrayInputStream(<span class="string">"&lt;/root&gt;"</span>.getBytes()),</span><br><span class="line">                &#125;));</span><br><span class="line">        SequenceInputStream seqStream = <span class="keyword">new</span> SequenceInputStream(streams);</span><br><span class="line">        Document document = saxReader.read(seqStream);</span><br><span class="line">        <span class="keyword">return</span> document.getRootElement();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>项目托管至Github</title>
    <url>/2018/01/02/%E9%A1%B9%E7%9B%AE%E6%89%98%E7%AE%A1%E8%87%B3Github/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本地新建项目后，如何同步到 github 上呢？</p>
<ol>
<li>在GitHub上新建项目</li>
<li>进入本地项目目录，依次执行</li>
</ol>
<blockquote>
<p>git init<br>git add .<br>git commit -m “备注”<br>git remote add origin 仓库地址<br>git push -u origin master</p>
</blockquote>
<a id="more"></a>
<h3 id="命令说明："><a href="#命令说明：" class="headerlink" title="命令说明："></a>命令说明：</h3><h4 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h4><blockquote>
<p>初始化本地仓库</p>
</blockquote>
<h4 id="git-add"><a href="#git-add" class="headerlink" title="git add ."></a>git add .</h4><blockquote>
<p>添加全部已经修改的文件，准备commit 提交 该命令效果等同于 git add -A</p>
</blockquote>
<h4 id="git-commit-m-‘提交说明’"><a href="#git-commit-m-‘提交说明’" class="headerlink" title="git commit -m ‘提交说明’"></a>git commit -m ‘提交说明’</h4><blockquote>
<p>将修改后的文件提交到本地仓库，如：git commit -m ‘增加README.md说明文档’</p>
</blockquote>
<h4 id="git-remote-add-origin-远程仓库地址"><a href="#git-remote-add-origin-远程仓库地址" class="headerlink" title="git remote add origin 远程仓库地址"></a>git remote add origin 远程仓库地址</h4><blockquote>
<p>连接到远程仓库并为该仓库创建别名 , 别名为origin . 这个别名是自定义的，通常用origin ; 远程仓库地址，就是你自己新建的那个仓库的地址，复制地址的方法参考 第二张图。<br>如：git remote add origin <a href="https://github.com/JustDoItLee/xxxxxx.git" target="_blank" rel="noopener">https://github.com/JustDoItLee/xxxxxx.git</a> 这段代码的含义是： 连接到github上<a href="https://github.com/JustDoItLee/xxxxxx.git" target="_blank" rel="noopener">https://github.com/JustDoItLee/xxxxxx.git</a> 这个仓库，并创建别名为origin . （之后push 或者pull 的时候就需要使用到这个 origin 别名）</p>
</blockquote>
<h4 id="git-push-u-origin-master"><a href="#git-push-u-origin-master" class="headerlink" title="git push -u origin master"></a>git push -u origin master</h4><blockquote>
<p>创建一个 upStream （上传流），并将本地代码通过这个 upStream 推送到 别名为 origin 的仓库中的 master 分支上</p>
<p>-u ，就是创建 upStream 上传流，如果没有这个上传流就无法将代码推送到 github；同时，这个 upStream 只需要在初次推送代码的时候创建，以后就不用创建了</p>
<p>另外，在初次 push 代码的时候，可能会因为网络等原因导致命令行终端上的内容一直没有变化，耐心等待一会就好。</p>
</blockquote>
<h3 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h3><p>如果执行 <code>git push -u origin master</code> 报错，是因为在 github 上项目不是空的，大部分情况是因为有一个 <code>README.md</code> 文件</p>
<blockquote>
<p>error: failed to push some refs to <a href="mailto:&#39;git@github.com" target="_blank" rel="noopener">&#39;git@github.com</a>:xxxxxx.git’<br>hint: Updates were rejected because the remote contains work that you do<br>hint: not have locally. This is usually caused by another repository pushing<br>hint: to the same ref. You may want to first integrate the remote changes<br>hint: (e.g., ‘git pull …’) before pushing again.<br>hint: See the ‘Note about fast-forwards’ in ‘git push –help’ for details.</p>
</blockquote>
<p>执行下面的代码，把github上没有拉下来的代码或文件拉下来</p>
<blockquote>
<p>git pull –rebase origin master</p>
</blockquote>
<p>然后再执行</p>
<blockquote>
<p> git push -u origin master</p>
</blockquote>
<p>提交代码即可。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>所以如果在<code>github</code> 上新建项目时初始化了 <code>README</code> 文件，按下面的顺序执行命令就可以</p>
<blockquote>
<p>git init git add . git commit -m “备注” git remote add origin 仓库地址 git pull –rebase origin master git push -u origin master</p>
</blockquote>
]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>系统学习Spring(三)——Bean的高级装配</title>
    <url>/2017/05/15/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Spring-%E4%B8%89-%E2%80%94%E2%80%94Bean%E7%9A%84%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>在软件开发中，常常设置不同的运行环境：开发环境、预发环境、性能测试环境和生产环境等等。</p>
<p>不同的环境下，应用程序的配置项也不同，例如数据库配置、远程服务地址等。<a id="more"></a>以数据库配置为例子，在开发环境中你可能使用一个嵌入式的内存数据库，并将测试数据放在一个脚本文件中。例如，在一个Spring的配置类中，可能需要定义如下的bean：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(destroyMethod = <span class="string">"shutdown"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .addScript(<span class="string">"classpath:schema.sql"</span>)</span><br><span class="line">            .addScript(<span class="string">"classpath:test-data.sql"</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用EmbeddedDatabaseBuilder这个构建器可以建立一个内存数据库，通过指定路径下的schema.sql文件中的内容可以建立数据库的表定义，通过test-data.sql可以准备好测试数据。</p>
<p>开发环境下可以这么用，但是在生产环境下不可以。在生产环境下，你可能需要从容器中使用JNDI获取DataSource对象，这中情况下，对应的创建代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JndiObjectFactoryBean jndiObjectFactoryBean =</span><br><span class="line">             <span class="keyword">new</span> JndiObjectFactoryBean();</span><br><span class="line">    jndiObjectFactoryBean.setJndiName(<span class="string">"jdbc/myDS"</span>);</span><br><span class="line">    jndiObjectFactoryBean.setResourceRef(<span class="keyword">true</span>);</span><br><span class="line">    jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> (DataSource) jndiObjectFactoryBean.getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用JNDI管理DataSource对象，很适合生产环境，但是对于日常开发环境来说太复杂了。</p>
<p>另外，在QA环境下你也可以选择另外一种DataSource配置，可以选择使用普通的DBCP连接池，例如：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">@Bean(destroyMethod = <span class="string">"close"</span>)</span><br><span class="line">public DataSource dataSource() &#123;</span><br><span class="line">    BasicDataSource dataSource = new BasicDataSource();</span><br><span class="line">    dataSource.<span class="built_in">set</span>Url(<span class="string">"jdbc:h2:tcp://dbserver/~/test"</span>);</span><br><span class="line">    dataSource.<span class="built_in">set</span>DriverClassName(<span class="string">"org.h2.Driver"</span>);</span><br><span class="line">    dataSource.<span class="built_in">set</span>Username(<span class="string">"sa"</span>);</span><br><span class="line">    dataSource.<span class="built_in">set</span>Password(<span class="string">"password"</span>);</span><br><span class="line">    dataSource.<span class="built_in">set</span>InitialSize(<span class="number">20</span>);</span><br><span class="line">    dataSource.<span class="built_in">set</span>MaxActive(<span class="number">30</span>);</span><br><span class="line">    return dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述三种办法可以为不同环境创建各自需要的javax.sql.DataSource实例，这个例子很适合介绍不同环境下创建bean，那么有没有一种办法：只需要打包应用一次，然后部署到不同的开发环境下就会自动选择不同的bean创建策略。一种方法是创建三个独立的配置文件，然后利用Maven profiles的预编译命令处理在特定的环境下打包哪个配置文件到最终的应用中。这种解决方法有一个问题，即在切换到不同环境时，需要重新构建应用——从开发环境到测试环境没有问题，但是从测试环境到生产环境也需要重新构建则可能引入一定风险。</p>
<p>Spring提供了对应的方法，使得在环境切换时不需要重新构建整个应用。</p>
<p></p><h2>配置profile beans</h2><br>Spring提供的方法不是在构件时针对不同的环境决策，而是在运行时，这样，一个应用只需要构建一次，就可以在开发、QA和生产环境运行。<p></p>
<p>在Spring 3.1之中，可以使用@Profile注解来修饰JavaConfig类，当某个环境对应的profile被激活时，就使用对应环境下的配置类。</p>
<p>在Spring3.2之后，则可以在函数级别使用@Profile注解（是的，跟@Bean注解同时作用在函数上），这样就可以将各个环境的下的bean定义都放在同一个配置类中，还是以之前的例子：</p>
<p>利用注解配置</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package com.spring.sample.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Bean</span>;</span><br><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Configuration</span>;</span><br><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Profile</span>;</span><br><span class="line">import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;</span><br><span class="line">import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;</span><br><span class="line">import org.springframework.jndi.JndiObjectFactoryBean;</span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig</span> &#123;</span></span><br><span class="line">    @Bean(destroyMethod = <span class="string">"shutdown"</span>)</span><br><span class="line">    @Profile(<span class="string">"dev"</span>)</span><br><span class="line">    public DataSource embeddedDataSource() &#123;</span><br><span class="line">        <span class="keyword">return</span> new EmbeddedDatabaseBuilder()</span><br><span class="line">                .setType(EmbeddedDatabaseType.H2)</span><br><span class="line">                .addScript(<span class="string">"classpath:schema.sql"</span>)</span><br><span class="line">                .addScript(<span class="string">"classpath:test-data.sql"</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    @Bean</span><br><span class="line">    @Profile(<span class="string">"prod"</span>)</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        JndiObjectFactoryBean jndiObjectFactoryBean =</span><br><span class="line">                new JndiObjectFactoryBean();</span><br><span class="line">        jndiObjectFactoryBean.setJndiName(<span class="string">"jdbc/myDS"</span>);</span><br><span class="line">        jndiObjectFactoryBean.setResourceRef(<span class="literal">true</span>); </span><br><span class="line">        jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource<span class="class">.<span class="keyword">class</span>);</span></span><br><span class="line">        <span class="keyword">return</span> (DataSource) jndiObjectFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了被@Profile修饰的其他bean，无论在什么开发环境下都会被创建。</p>
<p>利用XML文件配置</p>
<p>和在JavaConfig的用法一样，可以从文件级别定义环境信息，也可以将各个环境的bean放在一个XML配置文件中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:schema.sql"</span>/&gt;</span></span><br><span class="line">                     <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:test-data.sql"</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"qa"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">destroy-method</span>=<span class="string">"close"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">p:url</span>=<span class="string">"jdbc:h2:tcp://dbserver/~/test"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">p:driverClassName</span>=<span class="string">"org.h2.Driver"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">p:username</span>=<span class="string">"sa"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">p:password</span>=<span class="string">"password"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">p:initialSize</span>=<span class="string">"20"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">p:maxActive</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"prod"</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">jndi-name</span>=<span class="string">"jdbc/MyDatabase"</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">resource-ref</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                               <span class="attr">proxy-interface</span>=<span class="string">"javax.sql.DataSource"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述三个javax.sql.DataSource的bean，ID都是dataSource，但是在运行的时候只会创建一个bean。</p>
<p></p><h2>激活profiles</h2><br>Spring提供了spring.profiles.active和spring.profiles.default这两个配置项定义激活哪个profile。如果应用中设置了spring.profiles.active选项，则Spring根据该配置项的值激活对应的profile，如果没有设置spring.profiles.active，则Spring会再查看spring.profiles.default这个配置项的值，如果这两个变量都没有设置，则Spring只会创建没有被profile修饰的bean。<p></p>
<p>有下列几种方法设置上述两个变量的值：</p>
<p><li>DispatcherServlet的初始化参数</li></p>
<p><li>web应用的上下文参数(context parameters)</li></p>
<p><li>JNDI项</li></p>
<p><li>环境变量</li></p>
<p><li>JVM系统属性<br></li><li>在集成测试类上使用@ActiveProfiles注解</li></p>
<p>开发人员可以按自己的需求设置spring.profiles.active和spring.profiles.default这两个属性的组合。</p>
<p>我推荐在web应用的web.xml文件中设置spring.profiles.default属性——通过设置DispatcherServlet的初始参数和<context-param>标签。</context-param></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>spring.profiles.default<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServletName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>spring.profiles.default<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServletName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>按照上述方法设置spring.profiles.default属性，任何开发人员只需要下载源码就可以在开发环境中运行程序以及测试。</p>
<p>然后，当应用需要进入QA、生产环境时，负责部署的开发者只需要通过系统属性、环境变量或者JNDI等方法设置spring.profiles.active属性即可，因为spring.profiles.active优先级更高。</p>
<p>另外，在运行集成测试时，可能希望运行跟生产环境下相同的配置；但是，如果配置重需要的beans被profiles修饰的，则需要在跑单元测试之前激活对应的profiles。</p>
<p>Spring提供了@ActiveProfiles注解来激活指定的profiles，用法如下：</p>
<p></p><h2>Conditional beans</h2><br>假设你希望只有在项目中引入特定的依赖库时、或者只有当特定的bean已经被创建时、或者是设置了某个环境变量时，某个bean才被创建。<p></p>
<p>Spring 4之前很难实现这种需求，不过在Spring 4中提出了一个新的注解——@Conditional，该注解作用于@Bean注解修饰的方法上，通过判断指定的条件是否满足来决定是否创建该bean。</p>
<p>举个例子，工程中有一个MagicBean，你希望只有当magic环境变量被赋值时才创建MagicBean，否则该Bean的创建函数被忽略。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@Conditional</span>(MagicExistsCondition.class)</span><br><span class="line">public MagicBean magicBean() &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">MagicBean</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子表示：只有当MagicExistsCondition类已经存在时，才会创建MagicBean。</p>
<p>@Conditional注解的源码列举如下：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package org.springframework.context.<span class="keyword">annotation</span>;</span><br><span class="line"></span><br><span class="line">import java.lang.<span class="keyword">annotation</span>.<span class="title">ElementType</span>;</span><br><span class="line">import java.lang.<span class="keyword">annotation</span>.<span class="title">Retention</span>;</span><br><span class="line">import java.lang.<span class="keyword">annotation</span>.<span class="title">RetentionPolicy</span>;</span><br><span class="line">import java.lang.<span class="keyword">annotation</span>.<span class="title">Target</span>;</span><br><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Condition</span>;</span><br><span class="line"></span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">public @interface Conditional &#123;</span><br><span class="line">    Class&lt;? extends Condition&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，传入@Conditional注解的类一定要实现Condition接口，该接口提供matchs()方法——如果matches()方法返回true，则被@Conditional注解修饰的bean就会创建，否则对应的bean不会创建。</p>
<p>在这个例子中，MagicExistsCondition类应该实现Condition接口，并在matches()方法中实现具体的判断条件，代码如下所示：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package com.spring.sample.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Condition</span>;</span><br><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">ConditionContext</span>;</span><br><span class="line">import org.springframework.core.env.Environment;</span><br><span class="line">import org.springframework.core.<span class="keyword">type</span>.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MagicExistsCondition</span> <span class="title">implements</span> <span class="title">Condition</span> &#123;</span></span><br><span class="line">    public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123;</span><br><span class="line">        Environment env = conditionContext.getEnvironment();</span><br><span class="line">        <span class="keyword">return</span> env.containsProperty(<span class="string">"magic"</span>); <span class="regexp">//</span>检查magic环境变量是否被设置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的matchs()方法简单且有效：它首先获取环境变量，然后再判断环境变量中是否存在magic属性。在这个例子中，magic的值是多少并不重要，它只要存在就好。</p>
<p>MagicExistsCondition的matchs()方法是通过ConditionContext获取了环境实例。matchs()方法的参数有两个：ConditionContext和AnnotatedTypeMetadata，分别看下这两个接口的源码：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ConditionContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ConditionContext</span> &#123;</span><br><span class="line">    <span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">ConfigurableListableBeanFactory <span class="title">getBeanFactory</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">Environment <span class="title">getEnvironment</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">ResourceLoader <span class="title">getResourceLoader</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function">ClassLoader <span class="title">getClassLoader</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用ConditionContext接口可做的事情很多，列举如下：</p>
<p><li>通过getRegistry()方法返回的BeanDefinitionRegistry实例，可以检查bean的定义；</li></p>
<p><li>通过getBeanFactory()方法返回的ConfigurableListableBeanFactory实例，可以检查某个bean是否存在于应用上下文中，还可以获得该bean的属性；</li></p>
<p><li>通过getEnvironment()方法返回的Environment实例，可以检查指定环境变量是否被设置，还可以获得该环境变量的值；</li></p>
<p><li>通过getResourceLoader()方法返回的ResourceLoader实例，可以得到应用加载的资源包含的内容；</li></p>
<p><li>通过getClassLoader()方法返回的ClassLoader实例，可以检查某个类是否存在。</li></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AnnotatedTypeMetadata</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> AnnotatedTypeMetadata &#123;</span><br><span class="line">    <span class="built_in">boolean</span> isAnnotated(<span class="built_in">String</span> var1);</span><br><span class="line">    Map&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; getAnnotationAttributes(<span class="built_in">String</span> var1);</span><br><span class="line">    Map&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; getAnnotationAttributes(<span class="built_in">String</span> var1, <span class="built_in">boolean</span> var2);</span><br><span class="line">    MultiValueMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; getAllAnnotationAttributes(<span class="built_in">String</span> var1);</span><br><span class="line">    MultiValueMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; getAllAnnotationAttributes(<span class="built_in">String</span> var1, <span class="built_in">boolean</span> var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过isAnnotated()方法可以检查@Bean方法是否被指定的注解类型修饰；通过其他方法可以获得修饰@Bean方法的注解的属性。</p>
<p>从Spring 4开始，@Profile注解也利用@Conditional注解和Condition接口进行了重构。作为分析@Conditional注解和Condition接口的另一个例子，我们可以看下在Spring 4中@Profile注解的实现。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Conditional</span>(&#123;ProfileCondition.class&#125;)</span><br><span class="line">public <span class="variable">@interface</span> Profile &#123;</span><br><span class="line">    <span class="selector-tag">String</span><span class="selector-attr">[]</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，@Profile注解的实现被@Conditional注解修饰，并且依赖于ProfileCondition类——该类是Condition接口的实现。如下列代码所示，ProfileCondition利用ConditionContext和AnnotatedTypeMetadata两个接口提供的方法进行决策。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    ProfileCondition() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123;</span><br><span class="line">        <span class="keyword">if</span>(context.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            MultiValueMap attrs = metadata.getAllAnnotationAttributes(Profile<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>());</span></span><br><span class="line"><span class="class">            <span class="title">if</span>(<span class="title">attrs</span> != <span class="title">null</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">Iterator</span> var4 = ((<span class="built_in">List</span>)attrs.<span class="keyword">get</span>(<span class="string">"value"</span>)).iterator();</span><br><span class="line"></span><br><span class="line">                <span class="built_in">Object</span> value;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!var4.hasNext()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    value = var4.next();</span><br><span class="line">                &#125; <span class="keyword">while</span>(!context.getEnvironment().acceptsProfiles((<span class="built_in">String</span>[])((<span class="built_in">String</span>[])value)));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//传给@Profile注解的参数对应的环境profiles已激活</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//默认为true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这代码写得不太好理解:ProfileCondition通过AnnotatedTypeMetadata实例获取与@Profile注解相关的所有注解属性；然后检查每个属性的值（存放在value实例中），对应的profiles别激活——即context.getEnvironment().acceptsProfiles(((String[]) value))的返回值是true，则matchs()方法返回true。</p>
<p>Environment类提供了可以检查profiles的相关方法，用于检查哪个profile被激活：</p>
<p><li>String[] getActiveProfiles()——返回被激活的profiles数组；</li></p>
<p><li>String[] getDefaultProfiles()——返回默认的profiles数组；</li></p>
<p><li>boolean acceptsProfiles(String… profiles)——如果某个profiles被激活，则返回true。</li></p>
<p></p><h2>处理自动装配的歧义</h2><br>在一文中介绍了如何通过自动装配让Spring自动简历bean之间的依赖关系——自动装配非常有用，通过自动装配可以减少大量显式配置代码。不过，自动装配（autowiring）要求bean的匹配具备唯一性，否则就会产生歧义，从而抛出异常。<p></p>
<p>举个例子说明自动装配的歧义性，假设你有如下自动装配的代码：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dessert = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dessert是一个接口，有三个对应的实现：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line">public class Cake implements Dessert &#123; ... &#125;</span><br><span class="line"><span class="variable">@Component</span></span><br><span class="line">public class Cookies implements Dessert &#123; ... &#125;</span><br><span class="line"><span class="variable">@Component</span></span><br><span class="line">public class IceCream implements Dessert &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>因为上述三个类都被@Component注解修饰，因此都会被component-scanning发现并在应用上下文中创建类型为Dessert的bean；然后，当Spring试图为setDessert()方法装配对应的Dessert参数时，就会面临多个选择；然后Spring就会抛出异常——NoUniqueBeanDefinitionException。</p>
<p>虽然在实际开发中并不会经常遇到这种歧义性，但是它确实是个问题，幸运的是Spring也提供了对应的解决办法。</p>
<p></p><h3> @Primary指定优先bean</h3><br>在定义bean时，可以通过指定一个优先级高的bean来消除自动装配过程中遇到的歧义问题。<p></p>
<p>在上述例子中，可以选择一个最重要的Bean，用@Primary注解修饰：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Primary</span></span><br><span class="line">public class IceCream implements Dessert &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>如果你没有使用自动扫描，而是使用基于Java的显式配置文件，则如下定义@Bean方法：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@Primary</span></span><br><span class="line">public Dessert iceCream() &#123;</span><br><span class="line">  <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">IceCream</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用基于XML文件的显式配置，则如下定义：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"iceCream"</span></span><br><span class="line">             <span class="attribute">class</span>=<span class="string">"com.dasserteater.IceCream"</span></span><br><span class="line">             <span class="attribute">primary</span>=<span class="string">"true"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>不论哪种形式，效果都一样：告诉Spring选择primary bean来消除歧义。不过，当应用中指定多个Primary bean时，Spring又不会选择了，再次遇到歧义。Spring还提供了功能更强大的歧义消除机制——@Qualifiers注解。</p>
<p></p><h3>@Qualifier指定bean的ID</h3><br>@Qualifier注解可以跟@Autowired或@Inject一起使用，指定需要导入的bean的ID，例如，上面例子中的setDessert()方法可以这么写：<p></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"iceCream"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dessert = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个bean都具备唯一的ID，因此此处彻底消除了歧义。</p>
<p>如果进一步深究，@Qualifier(“iceCream”)表示以”iceCream”字符串作为qualifier的bean。每个bean都有一个qualifier，内容与该bean的ID相同。因此，上述装配的实际含义是：setDessert()方法会装配一个以”iceCream”为qualifier的bean，只不过碰巧是该bean的ID也是iceCream。</p>
<p>以默认的bean的ID作为qualifier非常简单，但是也会引发新的问题：如果将来对IceCream类进行重构，它的类名发生改变（例如Gelato）怎么办？在这种情况下，该bean对应的ID和默认的qualifier将变为”gelato”，然后自动装配就会失败。</p>
<p>问题的关键在于：你需要指定一个qualifier，该内容不会受目标类的类名的限制和影响。</p>
<p><strong>开发者可以给某个bean设定自定义的qualifier</strong>，形式如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line">public class IceCream implements Dessert &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>然后，在要注入的地方也使用”cold”作为qualifier来获得该bean：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dessert = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使在JavaConfig中，也可以使用@Qualifier指定某个bean的qualifier，例如：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line">public Dessert iceCream() &#123;</span><br><span class="line">  <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">IceCream</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用自定义的@Qualifier值时，最好选择一个含义准确的名词，不要随意使用名词。在这个例子中，我们描述IceCream为”cold”bean，在装配时，可以读作：给我来一份cold dessert，恰好指定为IceCream。类似的，我们把Cake叫作”soft”，把Cookies*叫作”crispy”。</p>
<p><strong>使用自定义的qualifiers优于使用基于bean的ID的默认qualifier</strong>，但是当你有多个bean共享同一个qualifier时，还是会有歧义。例如，假设你定义一个新的Dessertbean：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line">public class Popsicle implements Dessert &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>现在你又有两个”cold”为qualifier的bean了，再次遇到歧义：最直白的想法是多增加一个限制条件，例如IceCream会成为下面的定义：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="variable">@Qualifier</span>(<span class="string">"creamy"</span>)</span><br><span class="line">public class IceCream implements Dessert &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>而Posicle类则如下定义：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="variable">@Qualifier</span>(<span class="string">"fruity"</span>)</span><br><span class="line">public class Popsicle implements Dessert &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在装配bean的时候，则需要使用两个限制条件，如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@Qualifier</span>(<span class="string">"cold"</span>)</span><br><span class="line"><span class="variable">@Qualifier</span>(<span class="string">"creamy"</span>)</span><br><span class="line">public Dessert iceCream() &#123;</span><br><span class="line">  <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">IceCream</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个小问题：Java 不允许在同一个item上加多个相同类型的注解（Java 8已经支持），但是这种写法显然很啰嗦。</p>
<p>解决办法是：通过定义自己的qualifier注解，例如，可以创建一个@Cold注解来代替@Qualifier(“cold”)：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD,</span><br><span class="line">                  ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="variable">@Rentention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Qualifier</span></span><br><span class="line">public <span class="variable">@interface</span> Cold &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>可以创建一个@Creamy注解来代替@Qualifier(“creamy”)：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD,</span><br><span class="line">                  ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="variable">@Rentention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Qualifier</span></span><br><span class="line">public <span class="variable">@interface</span> Creamy &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>这样，就可以使用@Cold和@Creamy修饰IceCream类，例如：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Cold</span></span><br><span class="line"><span class="variable">@Creamy</span></span><br><span class="line">public class IceCream implements Dessert &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>类似的，可以使用@Cold和@Fruity修饰Popsicle类，例如：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Cold</span></span><br><span class="line"><span class="variable">@Fruity</span></span><br><span class="line">public class Popsicle implements Dessert &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>最后，在装配的时候，可以使用@Cold和@Creamy限定IceCream类对应的bean：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Cold</span></span><br><span class="line"><span class="meta">@Creamy</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setDessert</span><span class="params">(Dessert dessert)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dessert = dessert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p><h2>bean的作用域</h2><br>默认情况下，Spring应用上下文中的bean都是单例对象，也就是说，无论给某个bean被多少次装配给其他bean，都是指同一个实例。<p></p>
<p>大部分情况下，单例bean很好用：如果一个对象没有状态并且可以在应用中重复使用，那么针对该对象的初始化和内存管理开销非常小。</p>
<p>但是，有些情况下你必须使用某中可变对象来维护几种不同的状态，因此形成非线程安全。在这种情况下，把类定义为单例并不是一个好主意——该对象在重入使用的时候可能遇到线程安全问题。</p>
<p>Spring定义了几种bean的作用域，列举如下：</p>
<p><li>Singleton——在整个应用中只有一个bean的实例；</li></p>
<p><li>Prototype——每次某个bean被装配给其他bean时，都会创建一个新的实例；</li></p>
<p><li>Session——在web应用中，在每次会话过程中只创建一个bean的实</li><li>例；<br>Request——在web应用中，在每次http请求中创建一个bean的实例。<br>Singleton域是默认的作用域，如前所述，对于可变类型来说并不理想。我们可以使用@Scope注解——和@Component或@Bean注解都可以使用。</li></p>
<p>例如，如果你依赖component-scanning发现和定义bean，则可以用如下代码定义prototype bean：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">public class Notepad&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>除了使用SCOPE_PROTOTYPE字符串指定bean的作用域，还可以使用@Scope(“prototype”)，但使用ConfigurableBeanFactory.SCOPE_PROTOTYPE更安全，不容易遇到拼写错误。</p>
<p>另外，如果你使用JavaConfig定义Notepad的bean，也可以给出下列定义：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line">public Notepad notepad() &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">Notepad</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用xml文件定义Notepad的bean，则有如下定义：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"notepad"</span></span><br><span class="line">            <span class="attribute">class</span>=<span class="string">"com.myapp.Notepad"</span></span><br><span class="line">            <span class="attribute">scope</span>=<span class="string">"prototype"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>无论你最后采取上述三种定义方式的哪一种定义prototype类型的bean，每次Notepad被装配到其他bean时，都会重新创建一个新的实例。</p>
<p></p><h3>request和session作用域</h3><br>在Web应用中，有时需要在某个request或者session的作用域范围内共享同一个bean的实例。举个例子，在一个典型的电子商务应用中，可能会有一个bean代表用户的购物车，如果购物车是单例对象，则所有的用户会把自己要买的商品添加到同一个购物车中；另外，如果购物车bean设置为prototype，则在应用中某个模块中添加的商品在另一个模块中将不能使用。<p></p>
<p>对于这个例子，使用session scope更合适，因为一个会话（session）唯一对应一个用户，可以通过下列代码使用session scope:</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@Scope</span>(value=WebApplicationContext.SCOPE_SESSION,</span><br><span class="line">                proxyMode=ScopedProxyMode.INTERFACES)</span><br><span class="line">public ShoppingCart cart() &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在这里你通过value属性设置了WebApplicationContext.SCOPE_SESSION，这告诉Spring为web应用中的每个session创建一个ShoppingCartbean的实例。在整个应用中会有多个ShoppingCart实例，但是在某个会话的作用域中ShoppingCart是单例的。</p>
<p>这里还用proxyMode属性设置了ScopedProxyMode.INTERFACES值，这涉及到另一个问题：把request/session scope的bean装配到singleton scope的bean时会遇到。首先看下这个问题的表现。</p>
<p>假设在应用中需要将ShoppingCartbean装配给单例StoreServicebean的setter方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoreService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShoppingCart</span><span class="params">(ShoppingCart shoppingCart)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shoppingCart = shoppingCart;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为StoreService是单例bean，因此在Spring应用上下文加载时该bean就会被创建。在创建这个bean时 ，Spring会试图装配对应的ShoppingCartbean，但是这个bean是session scope的，目前还没有创建——只有在用户访问时并创建session时，才会创建ShoppingCartbean。</p>
<p>而且，之后肯定会有多个ShoppingCartbean：每个用户一个。理想的情景是：在需要StoreService操作购物车时，StoreService能够和ShoppingCartbean正常工作。</p>
<p>针对这种需求，Spring应该给StoreServicebean装配一个ShoppingCartbean的代理，如下图所示。代理类对外暴露的接口和ShoppingCart中的一样，用于告诉StoreService关于ShoppingCart的接口信息——当StoreService调用对应的接口时，代理采取延迟解析策略，并把调用委派给实际的session-scoped ShoppingCartbean。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/44770-c117d67ea67a9f2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" height="300px"></p>
<p>Scoped proxies enable deferred injected of request- and session-coped beans<br>因为ShoppingCart是一个接口，因此这里工作正常，但是，如果ShoppingCart是具体的类，则Spring不能创建基于接口的代理。这里必须使用CGLib创建class-based的bean，即使用ScopedProxyMode.TARGET_CLASS指示代理类应该基础自目标类。</p>
<p>这里使用session scope作为例子，在request scope中也有同样的问题，当然解决办法也相同。</p>
<p></p><h3> 在XML文件中定义scoped代理</h3><br>如果你在xml配置文件中定义session-scoped或者request-scoped bean，则不能使用@Scope注解以及对应的proxyMode属性。<bean>元素的scope属性可以用来指定bean的scope，但是如何指定代理模式？<p></p>
<p>可以使用Spring aop指定代理模式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"cart"</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.myapp.ShoppingCart"</span></span><br><span class="line">            scope=<span class="string">"session"</span></span><br><span class="line">      &lt;aop: scoped-proxy /&gt;</span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure>
<p>&lt;aop: scoped-proxy&gt;在XML配置方式扮演的角色与proxyMode属性在注解配置方式中的相同，需要注意的是，这里默认使用CGLIB库创建代理，因此，如果需要创建接口代理，则需要设置proxy-target-class属性为false:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"cart"</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.myapp.ShoppingCart"</span></span><br><span class="line">            scope=<span class="string">"session"</span></span><br><span class="line">      &lt;aop: scoped-proxy proxy-target-<span class="class"><span class="keyword">class</span></span>=<span class="string">"false"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了使用&lt;aop: scoped-proxy&gt;元素，需要在XML配置文件中定义Spring的aop名字空间：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;?xml <span class="attribute">version</span>=<span class="string">"1.0"</span> <span class="attribute">encoding</span>=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans <span class="attribute">xmlns</span>=<span class="string">"htttp://www.springframework.org/schema/beans"</span></span><br><span class="line">              xmlns:<span class="attribute">xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">              xmlns:<span class="attribute">aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">              xsi:<span class="attribute">schemaLocations</span>=<span class="string">"</span></span><br><span class="line"><span class="string">                   http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="string">                   http://www.springframework.org/schema/aop/spring-aop.xsd</span></span><br><span class="line"><span class="string">                   http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">                   http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br><span class="line">    <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure>
<p></p><h2>运行时值注入</h2><br>一般而言，讨论依赖注入和装配时，我们多关注的是如何（how）实现依赖注入（构造函数、setter方法），即如何建立对象之间的联系。<p></p>
<p>依赖注入的另一个方面是何时（when）将值装配给bean的属性或者构造函数。在装配bean—依赖注入的本质一文中，我们执行了很多值装配的任务，例如有如下代码：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(</span><br><span class="line">             <span class="string">"Sgt. Pepper's Lonely Hearts Club Band"</span>,</span><br><span class="line">             <span class="string">"The Beatles"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种硬编码的方式有时可以，有时却需要避免硬编码——在运行时决定需要注入的值。Spring提供以下两种方式实现运行时注入：</p>
<p><li>Property placeholders</li></p>
<p><li>he Spring Expression Language(SpEL)</li></p>
<p></p><h3>注入外部的值</h3><br>在Spring中解析外部值的最好方法是定义一个配置文件，然后通过Spring的环境实例获取配置文件中的配置项的值。例如，下列代码展示如何在Spring 配置文件中使用外部配置项的值。<p></p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">package com.spring.sample.config;</span><br><span class="line"></span><br><span class="line">import com.spring.sample.soundsystem.CompactDisc;</span><br><span class="line">import org.springframework.beans.factory.<span class="keyword">annotation</span>.<span class="title">Autowired</span>;</span><br><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Bean</span>;</span><br><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">Configuration</span>;</span><br><span class="line">import org.springframework.context.<span class="keyword">annotation</span>.<span class="title">PropertySource</span>;</span><br><span class="line">import org.springframework.core.env.Environment;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@PropertySource(<span class="string">"classpath:/app.properties"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExpressiveConfig</span> &#123;</span></span><br><span class="line">        @Autowired</span><br><span class="line">        Environment env; </span><br><span class="line"></span><br><span class="line">       @Bean</span><br><span class="line">        public CompactDisc disc() &#123;</span><br><span class="line">              <span class="keyword">return</span> new BlankDisc(env.getProperty(<span class="string">"disc.title"</span>),</span><br><span class="line">                env.getProperty(<span class="string">"disc.artist"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，@PropertySource注解引用的配置文件内容如下：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">disc.<span class="attr">title=Sgt.</span> Pepper's Lonely Hearts Club Band</span><br><span class="line">disc.<span class="attr">artist=The</span> Beatles</span><br></pre></td></tr></table></figure>
<p>属性文件被加载到Spring的Environment实例中，然后通过getProperty()方法解析对应配置项的值。</p>
<p><strong>在Environment类中，getProperty()方法有如下几种重载形式</strong>：</p>
<p><li>String getProperty(String var1);</li></p>
<p><li>String getProperty(String var1, String var2);</li></p>
<p><li><t> T getProperty(String var1, Class<t> var2);</t></t></li></p>
<p><li><t> T getProperty(String var1, Class<t> var2, T var3);</t></t></li></p>
<p>前两个方法都是返回String值，利用第二个参数，可以设置默认值；后两个方法可以指定返回值的类型，举个例子：假设你需要从连接池中获取连接个数，如果你使用前两个方法，则返回的值是String，你需要手动完成类型转换；但是使用后两个方法，可以由Spring自动完成这个转换：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">int<span class="built_in"> connection </span>= env.getProperty(<span class="string">"db.connection.count"</span>, Integer.class, 30)</span><br></pre></td></tr></table></figure>
<p>除了getProperty()方法，还有其他方法可以获得配置项的值，如果不设置默认值参数，则在对应的配置项不存在的情况下对应的属性会配置为null，如果你不希望这种情况发生——即要求每个配置项必须存在，则可以使用getRequiredProperty()方法：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CompactDisc <span class="title">disc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BlankDisc(</span><br><span class="line">            env.getRequiredProperty(<span class="string">"disc.title"</span>),</span><br><span class="line">            env.getRequiredProperty(<span class="string">"disc.artist"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，如果disc.title或者disc.artist配置项不存在，Spring都会抛出IllegalStateException异常。</p>
<p>如果你希望检查某个配置项是否存在，则可以调用containsProperty()方法：<code>boolean titleExists = env.containsProperty(“disc.title”);</code>。如果你需要将一个属性解析成某个类，则可以使用getPropertyAsClass()方法：<code>Class<compactdisc> cdClass = env.getPropertyAsClass(“disc.class”, CompactDisc.class);</compactdisc></code></p>
<p><strong>在Spring中，可以使用${ … }将占位符包裹起来</strong>，例如，在XML文件中可以定义如下代码从配置文件中解析对应配置项的值：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="attribute">id</span>=<span class="string">"sgtPeppers"</span></span><br><span class="line">             <span class="attribute">class</span>=<span class="string">"soundsystem.BlankDisc"</span></span><br><span class="line">             c:<span class="attribute">_title</span>=<span class="string">"<span class="variable">$&#123;disc.title&#125;</span>"</span></span><br><span class="line">             c:<span class="attribute">_artist</span>=<span class="string">"<span class="variable">$&#123;disc.artist&#125;</span>"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>如果你使用component-scanning和自动装配创建和初始化应用组件，则可以使用@Value注解获取配置文件中配置项的值，例如BlankDisc的构造函数可以定义如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BlankDisc(</span><br><span class="line">            <span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;disc.title&#125;</span>"</span>)</span> String title,</span><br><span class="line">            <span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;disc.artist&#125;</span>"</span>)</span> String artist) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = title;</span><br><span class="line">      <span class="keyword">this</span>.artist = artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了使用占位符的值，需要配置PropertyPlaceholderConfigerbean或者PropertySourcesPlaceholderConfigurerbean。从Spring 3.1之后，更推荐使用PropertySourcesPlaceholderConfigurer，因为这个bean和Spring 的Environment的来源一样，例子代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">PropertySourcesPlaceholderConfigurer <span class="title">placeholderConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用XML配置文件，则通过<a href="context:property-placeholder" target="_blank" rel="noopener">context:property-placeholder</a>元素可以获得PropertySourcesPlaceholderConfigurerbean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span>       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:/app.properties"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p></p><h3>使用SpEL装配</h3><br>Spring 3引入了Spring Expression Language（SpEL），这是一种在运行时给bean的属性或者构造函数参数注入值的方法。<p></p>
<p>SpEL有很多优点，简单列举如下：</p>
<p><li>可以通过bean的ID引用bean；</li></p>
<p><li>可以调用某个对象的方法或者访问它的属性；</li></p>
<p><li>支持数学、关系和逻辑操作；</li></p>
<p><li>正则表达式匹配；</li></p>
<p><li>支持集合操作<br>在后续的文章中，可以看到SpEL被用到依赖注入的其他方面，例如在Spring Security中，可以使用SpEL表达式定义安全限制；如果在Spring MVC中使用Thymeleaf模板，在模板中可以使用SpEL表达式获取模型数据。<br>SpEL是一门非常灵活的表达式语言，在这里不准备花大量篇幅来涵盖它的所有方面，可以通过一些例子来感受一下它的强大能力。</li></p>
<p>首先，SpEL表达式被#{ … }包围，跟placeholders中的${ … }非常像，最简单的SpEL表达式可以写作<code>#{1}</code>。在应用中，你可能回使用更加有实际含义的SpEL表达式，例如<code>#{T(System).currentTimeMillis()}</code>——这个表达式负责获得当前的系统时间，而T()操作符负责将java.lang.System解析成类，以便可以调用currentTimeMillis()方法。</p>
<p>SpEL表达式可以引用指定ID的bean或者某个bean的属性，例如下面这个例子可以获得ID为sgtPeppers的bean的artist属性的值：<code>#{sgtPeppers.artist}</code>；也可以通过<code>#{systemProperties[‘disc.title’]}</code>引用系统属性。</p>
<p>上述这些例子都非常简单，我们接下来看下如何在bean装配中使用SpEL表达式，之前提到过，如果你使用component-scanning和自动装配创建应用组件，则可以使用@Value注解获得配置文件中配置项的值；除了使用placeholder表达式，还可以使用SpEL表达式，例如BlankDisc的构造函数可以按照下面这种方式来写：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> BlankDisc(</span><br><span class="line">            <span class="meta">@Value(<span class="meta-string">"#&#123;systemProperties['disc.title']&#125;"</span>)</span> String title,</span><br><span class="line">            <span class="meta">@Value(<span class="meta-string">"#&#123;systemProperties['disc.artist']&#125;"</span>)</span> String artist) &#123;</span><br><span class="line">      <span class="keyword">this</span>.title = title;</span><br><span class="line">      <span class="keyword">this</span>.artist = artist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SpEL表达式可以表示整数值，也可以表示浮点数、String值和Boolean值。例如可以使用#{3.14159}表式浮点数3.14159，并且还支持科学计数法——<code>#{9.87E4}</code>表示98700；<code>#{‘Hello’}</code>可以表示字符串值、<code>#{false}</code>可以表示Boolean值。</p>
<p>单独使用字面值是乏味的，一般不会使用到只包含有字面值的SpEL表达式，不过在构造更有趣、更复杂的表达式时支持字面值这个特性非常有用。</p>
<p>SpEL表达式可以通过bean的ID引用bean，例如<code>#{sgtPeppers}</code>；也可以引用指定bean的属性，例如<code>#{sgtPeppers.artist}</code>；还可以调用某个bean的方法，例如#<code>{artistSelector.selectArtist()}</code>表达式可以调用artistSelector这个bean的selectArtist()方法。</p>
<p>SpEL表达式也支持方法的连续调用，例如#<code>{artistSelector.selectArtist().toUpperCase()}</code>,为了防止出现NullPointerException异常，最好使用类型安全的操作符，例如#<code>{artistSelector.selectArtist()?.toUpperCase()}</code>。?.操作符在调用右边的函数之前，会确保左边的函数返回的值不为null。</p>
<p>在SpEL中能够调用类的方法或者常量的关键是T()操作符，例如通过<code>T(java.lang.Math)</code>可以访问Math类中的方法和属性——<code>#{(java.lang.Math).random()}</code>和<code>#{T(java.lang.Math).PI}</code>。</p>
<p>在操作文本字符串时，最常用的是检查某个文本是否符合某种格式。SpEL通过matches操作符支持正则表达式匹配。例如：<code>#{admin.email matches ‘[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.com’}</code>可以检查admin.email表示的邮件地址是否正确。</p>
<p>通过SpEL表达式还可以操作集合和数组，例如<code>#{jukebox.songs[4].title}</code>这个表达式可以访问jukebox的songs数组的第5个元素。</p>
<p>也可以实现更复杂的功能：随机选择一首歌——<code>#{jukebox.songs[T(java.lang.Math).random() * jukebox.songs.size()].title}</code>。</p>
<p>SpEL提供了一个选择操作符——<code>.?[]</code>，可以获得某个集合的子集，举个例子，假设你获得jukebox中所有artist为Aerosmith的歌，则可以使用这个表达式：<code>#{jukebox.songs.?[artist eq ‘Aerosmith’]}</code>。可以看出，<code>.?[]</code>操作符支持在[]中嵌套另一个SpEL表达式。</p>
<p>SpEL还提供了其他两个选择操作符：<code>.^[]</code>用于选择第一个匹配的元素；<code>.$[]</code>用于选择最后一个匹配的元素。</p>
<p>最后，SpEL还提供了一个提取操作符：<code>.![]</code>，可以根据指定的集合新建一个符合某个条件的新集合，例如<code>#{jukebox.songs.![title]}</code>可以将songs的title都提取出来构成一个新的字符串集合。</p>
<p>OK，SpEL的功能非常强大，但是这里需要给开发人员提个醒：别让你的SpEL表达式过于智能。你的表达式越智能，就越难对它们进行单元测试，因此，尽量保证你的SpEL表达式简单易理解。</p>
<p></p><h2>总结</h2><br>首先我们介绍了通过Spring的profiles解决多环境部署的问题，通过在运行时根据代表指定环境的profile选择性创建某个bean，Spring可以实现无需重新构建就可以在多个环境下部署同一个应用。<p></p>
<p>Profiles bean是运行时创建bean的一种解决方案，不过Spring 4提供了一个更普遍的解决方案：利用@Conditional注解和Condition接口实现条件性创建bean。</p>
<p>我们还介绍了两种机制来解决自动装配时可能遇到的歧义性问题：primary beans和qualifiers。尽管定义一个primary bean非常简单，但它仍然有局限，因此我们需要利用qualifier缩小自动装配的bean的范围，而且，我们也演示了如何创建自己的qualifiers。</p>
<p>尽管大多数Spring bean是单例对象，但是在某些情况下具备其他作用域的对象更加合适。Spring 应用中可以创建singletons、prototypes、request-scoped或session-scoped。在使用request-scoped或者session-scoped类型的bean时，还需要解决将非单例对象注入到单例对象时遇到的问题——利用代理接口或代理类。</p>
<p>最后，我们也介绍了Spring表达式语言（SpEL），利用SpEL可以实现在运行时给bean注入值。</p>
</bean>]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>系统学习Spring（二）——装配Bean</title>
    <url>/2017/05/10/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Spring%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%A3%85%E9%85%8DBean/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>任何一个成功的应用都是由多个为了实现某个业务目标而相互协作的组件构成的，这些组件必须相互了解、能够相互协作完成工作。<a id="more"></a><br>例如，在一个在线购物系统中，订单管理组件需要与产品管理组件以及信用卡认证组件协作；这些组件还需要跟数据库组件协作从而进行数据库读写操作。<br>在Spring应用中，对象无需自己负责查找或者创建与其关联的其他对象，由容器负责将创建各个对象，并创建各个对象之间的依赖关系。<br>通俗的来说，Spring就是一个工厂，Bean就是Spring工厂的产品，对于Spring工厂能够生产那些产品，这个取决于领导的决策，也就是配置文件中配置。<br>因此，<strong>对于开发者来说，我们需要关注的只是告诉Spring容器需要创建哪些bean以及如何将各个bean装配到一起</strong>。<strong>对于Spring来说，它要做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成“依赖注入”</strong>。</p>
<h2>Bean的定义</h2><br><li>   &lt; beans/&gt;是Sring配置文件的根节点<br></li><li> 一个&lt; beans/&gt;节点里面可以有多个<bean>节点<br>在定义Bean的时候，通常要指定两个属性：id和class。其中id用来指明bean的标识符，这个标识符具有唯一性，Spring对bean的管理以及bean之间这种依赖关系都需要这个属性；而class指明该bean的具体实现类，这里不能是接口（可以是接口实现类）全路径包名.类名。<br><br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个Bean的配置</span></span><br><span class="line">    &lt;bean id=<span class="string">"bean"</span> <span class="keyword">class</span>=<span class="string">"实现类"</span> /&gt;</span><br></pre></td></tr></table></figure><br><br>或者<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(<span class="meta-string">"bean"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>当我们用XML配置了这个bean的时候，该bean实现类中必须有一个无参构造器，故Spring底层相当于调用了如下代码：<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">bean</span> = new 实现类（）<span class="comment">;</span></span><br></pre></td></tr></table></figure><br><br>如果在bean的配置文件中，通过构造注入如：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"bean"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"实现类"</span> /&gt;  </span><br><span class="line">       &lt;<span class="keyword">constructor</span>-arg value="bean"/&gt;  </span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure><br><br>那么Spring相当于调用了<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Bean </span><span class="keyword">bean </span>= new 实现类（<span class="string">"bean"</span>）<span class="comment">;</span></span><br></pre></td></tr></table></figure><br><br><h2>Spring的配置方法</h2><br>Spring容器负责创建应用中的bean，并通过DI维护这些bean之间的协作关系。作为开发人员，你应该负责告诉Spring容器需要创建哪些bean以及如何将各个bean装配到一起。Spring提供三种装配bean的方式：<br><br><li>基于XML文件的显式装配<br></li><li>基于Java文件的显式装配<br></li><li>隐式bean发现机制和自动装配<br><br>绝大多数情况下，开发人员可以根据个人品味选择这三种装配方式中的一种。Spring也支持在同一个项目中混合使用不同的装配方式。<br><br>《Spring实战》的建议是：尽可能使用自动装配，越少写显式的配置文件越好；当你必须使用显式配置时（例如，你要配置一个bean，但是该bean的源码不是由你维护），尽可能使用类型安全、功能更强大的基于Java文件的装配方式；最后，在某些情况下只有XML文件中才又你需要使用的名字空间时，再选择使用基于XML文件的装配方式。<br><br><h2>自动装配Bean</h2>

<p>Spring通过两个角度来实现自动装配：</p>
<p><li>组件扫描，Spring会自动发现应用上下文中所创建的bean</li></p>
<p><li>自动装配，Spring自动满足bean之间的依赖</li></p>
<p>《Spring实战》中用了一个例子来说明，假设你需要实现一个音响系统，该系统中包含CDPlayer和CompactDisc两个组件，Spring将自动发现这两个bean，并将CompactDisc的引用注入到CDPlayer中。</p>
<p>首先创建CD的概念——CompactDisc接口，如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李智</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CompactDisc接口的作用是将CDPlayer与具体的CD实现解耦合，即面向接口编程。这里还需定义一个具体的CD实现，如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李智</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title = <span class="string">"Sgt.Pepper's Lonely Hearts Club Band"</span>;</span><br><span class="line">    <span class="keyword">private</span> String artist = <span class="string">"The Beatles"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Playing"</span> + title + <span class="string">"by"</span> + artist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里最重要的是@Component注解，它告诉Spring需要创建SgtPeppers bean。除此之外，还需要启动自动扫描机制，有两种方法：基于XML配置文件；基于Java配置文件，代码如下（二选一）：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//这是XML配置</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"soundsystem"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是Java配置</span></span><br><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李智</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个Java配置文件中有两个注解值得注意：@Configuration表示这个.java文件是一个配置文件；@ComponentScan表示开启Component扫描，Spring将会设置该目录以及子目录下所有被@Component注解修饰的类。</p>
<p>自动配置的另一个关键注解是@Autowired，基于之前的两个类和一个Java配置文件，可以写个测试<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">package</span> <span class="selector-tag">com</span><span class="selector-class">.spring</span><span class="selector-class">.sample</span><span class="selector-class">.soundsystem</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">com</span><span class="selector-class">.spring</span><span class="selector-class">.sample</span><span class="selector-class">.config</span><span class="selector-class">.SoundSystemConfig</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.junit</span><span class="selector-class">.Assert</span>;<span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.junit</span><span class="selector-class">.Test</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.junit</span><span class="selector-class">.runner</span><span class="selector-class">.RunWith</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.beans</span><span class="selector-class">.factory</span><span class="selector-class">.annotation</span><span class="selector-class">.Autowired</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.test</span><span class="selector-class">.context</span><span class="selector-class">.ContextConfiguration</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.test</span><span class="selector-class">.context</span><span class="selector-class">.junit4</span><span class="selector-class">.SpringJUnit4ClassRunner</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2017/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="keyword">@ContextConfiguration</span>(classes = SoundSystemConfig.class)</span><br><span class="line">public class SoundSystemTest &#123;</span><br><span class="line">    <span class="keyword">@Autowired</span></span><br><span class="line">    private CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@Test</span></span><br><span class="line">    public void cdShouldNotBeNull() &#123;</span><br><span class="line">        <span class="selector-tag">Assert</span><span class="selector-class">.assertNotNull</span>(<span class="selector-tag">cd</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行测试，看到绿色就成功了，说明@Autowired注解起作用了：自动将扫描机制创建的CompactDisc类型的bean注入到SoundSystemTest这个bean中。</p>
<p>这里需要注意两个点，一个是junit需要用高级一点的版本，之前用3.8一直有问题，换成4.12之后就好了；还一个是SpringTest的测试包。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Sprint-test 相关测试包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>简单得说，自动装配的意思就是让Spring从应用上下文中找到对应的bean的引用，并将它们注入到指定的bean。通过@Autowired注解可以完成自动装配。</p>
<p>例如，考虑下面代码中的CDPlayer类，它的构造函数被@Autowired修饰，表明当Spring创建CDPlayer的bean时，会给这个构造函数传入一个CompactDisc的bean对应的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> soundsystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李智</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlay</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CDPlayer</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cd = cd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cd.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有别的实现方法，例如将@Autowired注解作用在setCompactDisc()方法上:</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setCd</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cd = cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者是其他名字的方法上，例如：<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">insertCD</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cd = cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更简单的用法是，可以将@Autowired注解直接作用在成员变量之上，我们开发一般都是直接这么用的吧，例如：<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CompactDisc cd;</span><br></pre></td></tr></table></figure></p>
<p>只要对应类型的bean有且只有一个，则会自动装配到该属性上。如果没有找到对应的bean，应用会抛出对应的异常，如果想避免抛出这个异常，则需要设置<strong>@Autowired(required=false)</strong>。不过，在应用程序设计中，应该谨慎设置这个属性，因为这会使得你必须面对<strong>NullPointerException</strong>的问题。</p>
<p>如果存在多个同一类型的bean，则Spring会抛出异常，表示装配有歧义，解决办法有两个：<br>（1）通过@Qualifier注解指定需要的bean的ID；<br>（2）通过@Resource注解指定注入特定ID的bean；</p>
<p>现在我们验证一下上述代码，通过下列代码，可以验证：CompactDisc的bean已经注入到CDPlayer的bean中，同时在测试用例中是将CDPlayer的bean注入到当前测试用例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.contrib.java.lang.system.StandardOutputStreamLog;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"><span class="keyword">import</span> soundsystem.CDPlayerConfig;</span><br><span class="line"><span class="keyword">import</span> soundsystem.CompactDisc;</span><br><span class="line"><span class="keyword">import</span> soundsystem.MediaPlay;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李智</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2017/5/9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span> </span>= CDPlayerConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= &#123;<span class="string">"classpath:/applicationContext.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> StandardOutputStreamLog log = <span class="keyword">new</span> StandardOutputStreamLog();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MediaPlay player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotBeNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        player.play();</span><br><span class="line">        assertEquals(<span class="string">"Playing"</span> + <span class="string">"Sgt.Pepper's Lonely Hearts Club Band"</span> + <span class="string">"by"</span> + <span class="string">"The Beatles\n"</span>, log.getLog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以使用<code> public final Logger log = LoggerFactory.getLogger(CDPlayerTest.class);</code>来替代<code> public final StandardOutputStreamLog log = new StandardOutputStreamLog();</code>，要使用StandardOutputStreamLog，需要添加Jar包如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.stefanbirkner<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>system-rules<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2>基于Java配置文件装配Bean</h2><br>Java配置文件不同于其他用于实现业务逻辑的Java代码，因此不能将Java配置文件业务逻辑代码混在一起。一般都会给Java配置文件新建一个单独的package，实际上之前就用了Java配置的。<br><br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span>(basePackageClasses = &#123;CDPlayer.class, DVDPlayer.class&#125;)</span><br><span class="line">public class SoundSystemConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>@Configuration注解表示这个类是配置类，之前我们是通过@ComponentScan注解实现bean的自动扫描和创建，这里我们重点是学习如何显式创建bean，因此首先将<strong>@ComponentScan(basePackageClasses = {CDPlayer.class, DVDPlayer.class})</strong>这行代码去掉。<br><br>我们先通过@Bean注解创建一个Spring bean，该bean的默认ID和函数的方法名相同，即sgtPeppers。例如：<br><br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或注明id</span></span><br><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"lonelyHeartsClub"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">CompactDisc <span class="title">sgtPeppers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>可以利用Java语言的表达能力，实现类似工厂模式的代码如下：<br><br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CompactDisc <span class="title">randomBeatlesCD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> choice = (<span class="keyword">int</span>)Math.floor(Math.random() * <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (choice == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers();</span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(choice == <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WhiteAlbum();</span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(choice == <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HardDaysNight();</span><br><span class="line">    &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(choice == <span class="number">3</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Revolover();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>然后在JavaConfig中的属性注入：<br><br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CDPlayer <span class="title">cdPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>看起来是函数调用，实际上不是：由于sgtPeppers()方法被@Bean注解修饰，所以Spring会拦截这个函数调用，并返回之前已经创建好的bean——确保该SgtPeppers bean为单例。<br><br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CDPlayer <span class="title">cdPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CDPlayer <span class="title">anotherCDPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>如上代码所示：如果把sgtPeppers()方法当作普通Java方法对待，则cdPlayerbean和anotherCDPlayerbean会持有不同的SgtPeppers实例——结合CDPlayer的业务场景看：就相当于将一片CD同时装入两个CD播放机中，显然这不可能。<br><br>默认情况下，Spring中所有的bean都是单例模式，因此cdPlayer和anotherCDPlayer这俩bean持有相同的SgtPeppers实例。<br><br>当然，还有一种更清楚的写法：<br><br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CDPlayer <span class="title">cdPlayer</span><span class="params">(CompactDisc compactDisc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(compactDisc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">CDPlayer <span class="title">anotherCDPlayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(sgtPeppers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>这种情况下，cdPlayer和anotherCDPlayer这俩bean持有相同的SgtPeppers实例，该实例的ID为lonelyHeartsClub。这种方法最值得使用，因为它不要求CompactDisc bean在同一个配置文件中定义——只要在应用上下文容器中即可（不管是基于自动扫描发现还是基于XML配置文件定义）。<br><br><h2>基于XML的配置方法</h2><br>在之前Bean的定义有提到过，这里就不复述了。<br><br><h2>混合使用多种配置方法</h2><br>之前有提到过，开发过程中也可能使用混合配置，首先明确一点：对于自动配置，它从整个容器上下文中查找合适的bean，无论这个bean是来自JavaConfig还是XML配置。<br><br><strong>在JavaConfig中解析XML配置</strong><br><br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过@Import注解导入其他的JavaConfig，并且支持同时导入多个配置文件；</span></span><br><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@Import</span>(&#123;CDPlayerConfig.class, CDConfig.class&#125;)</span><br><span class="line">public class SoundSystemConfig &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过@ImportResource注解导入XML配置文件；</span></span><br><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@Import</span>(CDPlayerConfig.class)</span><br><span class="line"><span class="variable">@ImportResource</span>(<span class="string">"classpath: cd-config.xml"</span>)</span><br><span class="line">public class SoundSystemConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong>在XML配置文件中应用JavaConfig</strong><br><br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过&lt;import&gt;标签引入其他的XML配置文件；</span></span><br><span class="line"><span class="comment">//通过&lt;bean&gt;标签导入Java配置文件到XML配置文件，例如</span></span><br><span class="line">&lt;bean <span class="keyword">class</span>=<span class="string">"soundsystem.CDConfig"</span> /&gt;</span><br></pre></td></tr></table></figure><br><br>通常的做法是：无论使用JavaConfig或者XML装配，都要创建一个root configuration，即模块化配置定义；并且在这个配置文件中开启自动扫描机制：<a href="context:component-scan" target="_blank" rel="noopener">context:component-scan</a>或者@ComponentScan。<br><br><h2>总结</h2>

<p>由于自动装配几乎不需要手动定义bean，建议优先选择自动装配；如何必须使用显式配置，则优先选择基于Java文件装配这种方式，因为相比于XML文件，Java文件具备更多的能力、类型安全等特点；但是也有一种情况必须使用XML配置文件，即你需要使用某个名字空间（name space），该名字空间只在XML文件中可以使用。</p>
<p>ps:上述例子都是直接用的《Spring实战》</p>
</li></bean></li>]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>系统学习Spring（一）</title>
    <url>/2017/05/09/Spring%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>对于Java开发者来说，这是一个好的时代。<a id="more"></a></p>
<p>在过去的20年中，Java经历了好的时候，也经历了坏的时候。尽管有一些粗糙的地方，比如：Applets、<br>EJB、JDO和无数的日志框架，Java有丰富多样的历史，有很多企业已经建立的平台。其中，spring一直<br>都是其中最重要的组成部分。</p>
<p>在早期，Spring被创建用于替代笨重的Java企业技术，比如EJB。相比于EJB，Spring提供了一个更加精<br>简的编程模型。它提供了简单Java对象（POJO）更大的权力，相对于EJB及其他Java企业规范。</p>
<p>随着时间的推移，EJB及Java企业规范2.0版本本身也提供了一个简单的POJO模型。现在，EJB的一些概<br>念，如DI和AOP都来自于Spring。</p>
<p>尽管现在J2EE（即总所周知的JEE）能够赶上Spring，但是Spring从未停止演进。即使是现在，Spring开始进步的时候，<br>J2EE都是开始在探索，而不是创新。移动开发、社交API的集成、NoSql数据库、云计算和大数据，仅仅是Spring创新<br>的一些方面。而且未来，Spring会继续发展。</p>
<p>就像我说的，对于Java程序员来说，这是一个好的时代。 </p>
<p><strong>摘自《Spring实战》</strong></p>
<p>顾名思义，Spring就是为了简化我们Java开发而来的，而Spring主要还是围绕着两个点：一个DI（依赖注入），一个AOP（面向切面），或者说IOC（控制反转）和AOP（面向切面）。</p>
<blockquote>
<p>IOC主要的实现方式有两种：依赖查找，依赖注入<br>依赖注入是一种更可取的方式</p>
</blockquote>
<p></p><h2>依赖注入——Injecting Dependencies</h2><br>刚接触时，DI这个词刚听起来觉得是害怕的，它可能是相当复杂的编程技术或者设计模式。但事实证明，DI一点都不像 ，它听起来那么难。通过在应用中使用DI，你会发现你的应用程序变淡简单、容易理解并且易于测试。<br>那么DI是怎么工作的呢？一个正常的应用程序都是有两个或者更多个相互协作的类组合起来的。传统上，每个对象都会保存它所以来的对象的引用。这个会导致高度耦合并且难于测试。<p></p>
<p>例如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DamselRescuingKnight</span> <span class="keyword">implements</span> <span class="title">Knight</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RescueDamselQuest quest;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DamselRescuingKnight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quest = <span class="keyword">new</span> RescueDamselQuest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embarkOnQuest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        quest.embark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上所示，骑士创建了一个少女需要营救的请求（RescueDamselQuest）在它自己的构造函数中。这个会使骑士与少女请求绑定到一起，这严重限制了骑士的能力。如果一个少女需要营救，那没有问题。但是如果一头巨龙需要被杀死，那么骑士什么都做不了，只能坐在旁边观看。</p>
<p>所以耦合是一个特别难以拓展的问题，一方面，耦合的代码难于测试、难于重用、难以理解并且他经常导致“打地鼠”的Bug行为（一种修改一个Bug通常会引起其他新的一个甚至更多的新bug的行为）。另一方面，一定数量的耦合代码是必须的，完全不耦合的代码将什么事情都不做。为了去做一些有用的事情，类需要知道彼此。耦合是必须的，但是必须被小心的管理。</p>
<p>因此使用DI，对象在创建的时候被一些确定系统对象坐标的第三方去给予出其依赖，对象不需要去创建或者获取其依赖，像下图描述的那样，依赖被注入进了需要他们的对象。</p>
<p>所以针对上面的问题，我们修改了代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个灵活的骑士</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> knights;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BraveKnight</span> <span class="keyword">implements</span> <span class="title">Knight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Quest quest;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BraveKnight</span><span class="params">(Quest quest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quest = quest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embarkOnQuest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        quest.embark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就像在上面看到的一样，BraveKnight不像DamselRescuingKnight 一样创建自己的Quest，而是在构造函数的参数中传入Quest，这样的DI就是著名的构造函数注入（Constructor injection）。</p>
<p>更重要的是，那个Quest只是一个接口，所有实现该接口的实现都可以传入。所以BraveKnight可以处理不同的 需求。</p>
<p>关键点就是BraveKnight没有跟任何特定的Quest进行绑定。它不在乎是什么样的请求，只要该请求实现了Quest接口就可以。这个就是DI的好处–松耦合。如果一个对象的依赖只是一个接口，那么你可以将他的实 现从一个换成另外一个。</p>
<p>既然你BraveKnight对象可以处理任何你想传递给他的Quest对象，假设你想传递一个杀死巨龙的Quest，那么 你可以传递一个SlayDragonQuest给他是合适的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SlayDragonQuest</span> <span class="keyword">implements</span> <span class="title">Quest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PrintStream stream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SlayDragonQuest</span><span class="params">(PrintStream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stream = stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stream.println(<span class="string">"Embarking on quest to slay the dragon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就像你所看到的一样，SlayDragonQuest实现了Quest接口，使得它适合BraveKnight。</p>
<p>应用组件之间创建关联的行为通常称为布线或者装配（wiring）。在Spring中，组件之间的装配方式有很多种，但是一个通常的方式是使用XML。接下来的清单展示了一个简单的Spring配置文件–knights.xml，它将一个SlayDragonQuest、BraveKnight和一个PrintStream装配起来。</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></span><br><span class="line"><span class="xml">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="xml">       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"knight"</span> <span class="attr">class</span>=<span class="string">"com.springinaction.knights.BraveKnight"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!--quest注入quest的Bean--&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"quest"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--创建Quest--&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"quest"</span> <span class="attr">class</span>=<span class="string">"com.springinaction.knights.SlayDragonQuest"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"#</span></span></span><span class="template-variable">&#123;$(System).out&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这里，BraveKnight和SlayDragonQuest被声明为Bean，在BraveKnight Bean中，通过传递一个Quest的引用作为构造函数的参数。同时，SlayDragonQuest使用Spring表达式语言传递一个System.out的构造函数参数给SlayDragonQuest对象。如果XML配置文件不适合你的口味，你可以使用Java方式进行配置。如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnightConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Knight <span class="title">knight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BraveKnight(quest());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Quest <span class="title">quest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SlayDragonQuest(System.out);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不管使用xml还是java，依赖注入的好处都是一样的。尽管BraveKnight依赖Quest，但是它不需要知道具体是什么Quest，同样的SlayDragonQuest也不需要知道具体的PrintStream类型。在Spring中，仅仅通过配置使得所有的片段组装在一起。这个就使得可以去改变他们之间的依赖关系而不需要去修改类的实现。</p>
<p></p><h2>AOP——Aspect-OrientedProgramming</h2><br>虽然DI可以使得你的应用程序组件之间是松耦合的，但是AOP可以使得你可以在你应用程序中去捕获Bean的功能。<p></p>
<p>AOP通常被定义为分离软件关注点的一种技术。系统通常由一些具有特定功能的组件组成。但是，通常这些组件也附带一些除了核心功能之外的一些功能。系统服务，如日志记录、事务管理和安全性，通常会在每个组件中都是需要的。这些系统服务通常被称为横切关注点（cross-cutting concerns），因为他们会在系统中切割多个组件。</p>
<p>通过传递这些横切关注点，你会提供你应用程序的复杂性：</p>
<p><li>代码重复。这就意味着你如果修改其中一个功能，你修改需要许多的组件。即使你把关注点抽象为一个单独的模块，这样对你组件的影响是一个单一的方法，该方法调用也会在多个地方重复。</li></p>
<p><li>你的组件中充斥这与它核心功能不一致的代码。如添加一个条目到一个地址簿中，我们应该只关心如何添加地址，而不是关心是否安全或者是否具有事务一致性。</li></p>
<p>AOP可以模块化这些服务，并且通过声明式的方式应用这些服务，这将导致组件更加具有凝聚力，并且组件专注于自己特定的功能，对可能涉及的系统服务完全不知情。简单来说，就是让POJO始终保持扁平。</p>
<p>下面一个例子来演示分离核心功能与系统服务：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minstrel</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> PrintStream stream;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Minstrel</span><span class="params">(PrintStream stream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stream = stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//called before quest</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleBeforeQuest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stream.<span class="built_in">println</span>(<span class="string">"Fa la la, the knight is so brave"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//called after quest</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singleAfterQuest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stream.<span class="built_in">println</span>(<span class="string">"Tee hee hee, the brave knight did embark on a quest"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就像你看到的一样，Minstrel是一个包含两个方法的简单对象，这是简单的，将这个注入进我们之前的代码，如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BraveKnight</span> <span class="keyword">implements</span> <span class="title">Knight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Quest quest;</span><br><span class="line">    <span class="keyword">private</span> Minstrel minstrel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BraveKnight</span><span class="params">(Quest quest, Minstrel minstrel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.quest = quest;</span><br><span class="line">        <span class="keyword">this</span>.minstrel = minstrel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">embarkOnQuest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        minstrel.singleBeforeQuest();</span><br><span class="line">        quest.embark();</span><br><span class="line">        minstrel.singleAfterQuest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在，你需要做的就是在Spring的配置文件中加入Ministrel的构造函数参数。但是，等等….</p>
<p>好像看起来不对，这个真的是骑士本身关注的吗？骑士应该不必要做这个工作。毕竟，这是一个歌手的工作，歌颂骑士的努力，为什么其实一直在提醒歌手呢？</p>
<p>另外，由于骑士必须知道歌手，你被迫传递歌手给骑士，这个不仅使骑士的代码复杂，而且让我很困惑，当我需要一个骑士而没有一个歌手的时候，如果Ministrel为null，在代码中还得进行非空判断，简单的BraveKnight代码开始变得复杂。但是使用AOP，你可以宣布歌手必须歌唱骑士的任务，并且，释放骑士，直接处理歌手的方法。</p>
<p>在Spring配置文件中，你需要做的就是将歌手声明为一个切面。如下：<br><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></span><br><span class="line"><span class="xml">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="xml">       xmlns:aop="http://www.springframework.org/schema/aop"</span></span><br><span class="line"><span class="xml">       xsi:schemaLocation="http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="xml">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="xml">       http://www.springframework.org/schema/aop</span></span><br><span class="line"><span class="xml">       http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"knight"</span> <span class="attr">class</span>=<span class="string">"com.springinaction.knights.BraveKnight"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="comment">&lt;!--quest注入quest的Bean--&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"quest"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--创建Quest--&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"quest"</span> <span class="attr">class</span>=<span class="string">"com.springinaction.knights.SlayDragonQuest"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"#</span></span></span><span class="template-variable">&#123;T(System).out&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!--定义歌手的Bean--&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ministrel"</span> <span class="attr">class</span>=<span class="string">"com.springinaction.knights.Minstrel"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"#</span></span></span><span class="template-variable">&#123;T(System).out&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"ministrel"</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!--定义切点--&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"embark"</span> <span class="attr">expression</span>=<span class="string">"execution(* *.embarkOnQuest(..))"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!--定义前置通知--&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">"embark"</span> <span class="attr">method</span>=<span class="string">"singleBeforeQuest"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="comment">&lt;!--定义后置通知--&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"singleAfterQuest"</span> <span class="attr">pointcut-ref</span>=<span class="string">"embark"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用Spring的AOP配置一个Ministrel作为切面，在切面里面，定义一个切点，然后定义前置通知（before advice）和后置通知（after advice）。在两个例子中，pointcut-ref属性都使用了一个embark的引用，这个切点是通过pointcut元素定义的，它表明通知应该应用在什么地方，表达式的语法遵循AspectJ的切点表达式语法。</p>
<p>首先，Ministrel始终是一个POJO，没有任何说明他是用来作为切面的。作为一个切面是通过Spring配置文件实现的。其次，也是最重要的，Ministrel可以应用到BraveKnight而不需要BraveKnight直接调用它，实际上，BraveKnight根本不知道Ministrel的存在。</p>
<p>需要指出的是，你可以使用Spring的魔法使得Ministrel作为一个切面，但是Ministrel必须首先是一个Spring的Bean，关键的就是你可以使用任何Spring Bean作为切面，而且可以将其注入其他的Bean中。</p>
<p><strong>这些基础的理论都是从《Spring实战第四版》一书中记录下来的，以后的学习中，将会掺杂以自己视角来写。</strong></p>
<p><strong>ps:其实之前有写过Spring的一些理解，但是开发过程中还是发现很多细节都不理解不明白，因为之前Spring的学习都是基于开发过程中边做边学，所以决定从头开始系统的学习。</strong></p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>userId分库，怎么通过其他字段查询</title>
    <url>/2017/04/18/userId%E5%88%86%E5%BA%93%EF%BC%8C%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87%E5%85%B6%E4%BB%96%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>用户中心是几乎每一个公司必备的基础服务，用户注册、登录、信息查询与修改都离不开用户中心。</p>
<p>当数据量越来越大时，需要多用户中心进行水平切分。最常见的水平切分方式，<strong>按照userId取模分库</strong>：<a id="more"></a></p>
<p>例如：</p>
<p><img src="http://img.blog.csdn.net/20170418093703450" height="300px" width="500px"></p>
<p>通过userId取模，将数据分布到多个数据库实例上去，提高服务实例个数，降低单库数据量，以达到扩容的目的。</p>
<p>这样水平切分之后，userId属性上的查询可以直接路由到库，如上图，假设访问uid=10的数据，取模后能够直接定位db1。</p>
<p>但是分库之后，对于其他字段的查询，就不能这么幸运了。假设访问userName=”lizhi”的数据，由于不知道数据落在哪个库上，<strong>往往需要遍历所有库，当分库数量多起来，性能会显著降低</strong>。</p>
<p>所以我要们寻找如何高效查询的方法！（以下用userName为例）</p>
<h2>索引表法</h2>

<p>思路：userId直接定位到库，userName不能直接定位到库，如果通过userName能查询到userId，问题解决。</p>
<p>解决方案：<br><br>1）建立一个索引表记录userName-&gt;userId的映射关系<br>2）用userName来访问时，先通过索引表查询到userId，再定位相应的库<br>3）索引表属性较少，可以容纳非常多数据，一般不需要分库<br>4）如果数据量过大，可以通过userName来分库</p>
<p>潜在不足：多一次数据库查询，性能下降一倍。</p>
<p></p><h2>缓存映射法</h2><br>思路：访问索引表性能较低，把映射关系放在缓存里性能更佳。<p></p>
<p>解决方案：<br><br>1）userName查询先到cache中查询userId，再根据userId定位数据库<br>2）假设cache miss，采用扫全库法获取userName对应的userId，放入cache<br>3）userName到userId的映射关系不会变化，映射关系一旦放入缓存，不会更改，无需淘汰，缓存命中率超高<br>4）如果数据量过大，可以通过userName进行cache水平切分</p>
<p>潜在不足：多一次cache查询</p>
<p></p><h2>userName生成userId</h2><br>思路：不进行远程查询，由userName直接得到userId<p></p>
<p>解决方案：<br><br>1）在用户注册时，设计函数userName生成userId，userId=f(userName)，按userId分库插入数据<br>2）用userName来访问时，先通过函数计算出userId，即userId=f(userName)再来一遍，由userId路由到对应库</p>
<p>潜在不足：该函数设计需要非常讲究技巧，有userId生成冲突风险</p>
<p></p><h2>userName基因融入userId</h2><br>思路：不能用userName生成userId，可以从userName抽取“基因”，融入userId中<p></p>
<p>假设分8库，采用userId%8路由，潜台词是，userId的最后3个bit决定这条数据落在哪个库上，这3个bit就是所谓的“基因”。</p>
<p>解决方案：<br><br>1）在用户注册时，设计函数userName生成3bit基因，userName_gene=f(userName)<br>2）同时，生成61bit的全局唯一id，作为用户的标识<br>3）接着把3bit的userName_gene也作为userId的一部分<br>4）生成64bit的userId，由id和userName_gene拼装而成，并按照userId库插入数据<br>5）用userName来访问时，先通过函数由userName再次复原3bit基因，userName_gene=f(userName)，通过userName_gene%8直接定位到库</p>
]]></content>
      <categories>
        <category>数据库那点事</category>
      </categories>
      <tags>
        <tag>分库</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基于zxing生成二维码demo</title>
    <url>/2017/03/23/Java%E5%9F%BA%E4%BA%8Ezxing%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81demo/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>QR码属于矩阵式二维码中的一个种类，由DENSO(日本电装)公司开发，由JIS和ISO将其标准化。QR码的样子其实在很多场合已经能够被看到了，我这还是贴个图展示一下：</p>
<p><img src="http://img.blog.csdn.net/20170323193748791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWVsb2RfYmM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" height="300" width="300"><br><a id="more"></a></p>
<p>这个图如果被正确解码，应该看到百度。</p>
<p>具体的也不说什么了，百度一大把，直接上源码~</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.lincoln.Untils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.BarcodeFormat;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.EncodeHintType;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.MultiFormatWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.BitMatrix;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> java.io.<span class="built_in">File</span>;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.awt.<span class="built_in">image</span>.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QRUtil</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BLACK = <span class="number">0xFF000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WHITE = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param args</span></span><br><span class="line"><span class="comment">     * @throws Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws Exception </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">text</span> = <span class="string">"http://www.baidu.com"</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">width</span> = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">300</span>;</span><br><span class="line">        <span class="comment">//二维码的图片格式</span></span><br><span class="line">        <span class="keyword">String</span> format = <span class="string">"gif"</span>;</span><br><span class="line">        Hashtable hints = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        <span class="comment">//内容所使用编码</span></span><br><span class="line">        hints.<span class="built_in">put</span>(EncodeHintType.CHARACTER_SET, <span class="string">"utf-8"</span>);</span><br><span class="line">        BitMatrix bitMatrix = <span class="keyword">new</span> MultiFormatWriter().encode(<span class="built_in">text</span>,</span><br><span class="line">                BarcodeFormat.QR_CODE, <span class="built_in">width</span>, <span class="built_in">height</span>, hints);</span><br><span class="line">        <span class="comment">//生成二维码</span></span><br><span class="line">        <span class="built_in">File</span> outputFile = <span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"/Users/lizhi/Downloads"</span> + <span class="built_in">File</span>.separator + <span class="string">"new.gif"</span>);</span><br><span class="line">        QRUtil.writeToFile(bitMatrix, format, outputFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">QRUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BufferedImage <span class="title">toBufferedImage</span><span class="params">(BitMatrix matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">width</span> = matrix.getWidth();</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">height</span> = matrix.getHeight();</span><br><span class="line">        BufferedImage <span class="built_in">image</span> = <span class="keyword">new</span> BufferedImage(<span class="built_in">width</span>, <span class="built_in">height</span>, BufferedImage.TYPE_INT_RGB);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++) &#123;</span><br><span class="line">                <span class="built_in">image</span>.setRGB(x, y, matrix.<span class="built_in">get</span>(x, y) ? BLACK : WHITE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeToFile</span><span class="params">(BitMatrix matrix, <span class="keyword">String</span> format, <span class="built_in">File</span> file)</span></span></span><br><span class="line"><span class="function">            throws IOException </span>&#123;</span><br><span class="line">        BufferedImage <span class="built_in">image</span> = toBufferedImage(matrix);</span><br><span class="line">        <span class="keyword">if</span> (!ImageIO.<span class="built_in">write</span>(<span class="built_in">image</span>, format, file)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Could not write an image of format "</span> + format + <span class="string">" to "</span> + file);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeToStream</span><span class="params">(BitMatrix matrix, <span class="keyword">String</span> format, OutputStream stream)</span></span></span><br><span class="line"><span class="function">            throws IOException </span>&#123;</span><br><span class="line">        BufferedImage <span class="built_in">image</span> = toBufferedImage(matrix);</span><br><span class="line">        <span class="keyword">if</span> (!ImageIO.<span class="built_in">write</span>(<span class="built_in">image</span>, format, stream)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Could not write an image of format "</span> + format);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>恩，就这么简单。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网易短信接入demo</title>
    <url>/2017/03/23/Java%E7%BD%91%E6%98%93%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%85%A5demo/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>由于最近使用云信添加短信接入功能，记录一下一些点避免时间久了忘记。<a id="more"></a></p>
<blockquote>
<p><strong>发短信</strong></p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.lincoln.Untils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.NameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.entity.UrlEncodedFormEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message.BasicNameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Yunxin</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws Exception </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(sendMsg(<span class="string">"158********"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SERVER_URL = <span class="string">"https://api.netease.im/sms/sendcode.action"</span>;<span class="comment">//发送验证码的请求路径URL</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> APP_KEY = <span class="string">"*******"</span>;<span class="comment">//网易云信分配的账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> APP_SECRET = <span class="string">"*******"</span>;<span class="comment">//网易云信分配的密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> NONCE = <span class="string">"123456"</span>;<span class="comment">//随机数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">sendMsg</span><span class="params">(<span class="keyword">String</span> phone)</span> throws IOException </span>&#123;</span><br><span class="line">        CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line">        HttpPost post = <span class="keyword">new</span> HttpPost(SERVER_URL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span> curTime = <span class="keyword">String</span>.valueOf((<span class="keyword">new</span> Date().getTime() / <span class="number">1000L</span>));</span><br><span class="line">        <span class="keyword">String</span> checkSum = CheckSumBuilder.getCheckSum(APP_SECRET, NONCE, curTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置请求的header</span></span><br><span class="line">        post.addHeader(<span class="string">"AppKey"</span>, APP_KEY);</span><br><span class="line">        post.addHeader(<span class="string">"Nonce"</span>, NONCE);</span><br><span class="line">        post.addHeader(<span class="string">"CurTime"</span>, curTime);</span><br><span class="line">        post.addHeader(<span class="string">"CheckSum"</span>, checkSum);</span><br><span class="line">        post.addHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置请求参数</span></span><br><span class="line">        List&lt;NameValuePair&gt; nameValuePairs = <span class="keyword">new</span> ArrayList&lt;NameValuePair&gt;();</span><br><span class="line">        nameValuePairs.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"mobile"</span>, phone));</span><br><span class="line"></span><br><span class="line">        post.setEntity(<span class="keyword">new</span> UrlEncodedFormEntity(nameValuePairs, <span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行请求</span></span><br><span class="line">        HttpResponse response = httpclient.execute(post);</span><br><span class="line">        <span class="keyword">String</span> responseEntity = EntityUtils.toString(response.getEntity(), <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否发送成功，发送成功返回true</span></span><br><span class="line">        <span class="keyword">String</span> code = JSON.parseObject(responseEntity).getString(<span class="string">"code"</span>);</span><br><span class="line">        <span class="keyword">if</span> (code.equals(<span class="string">"200"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>验证</strong></p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lincoln.Untils;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2017/3/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.NameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.entity.UrlEncodedFormEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message.BasicNameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 校验验证码工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @author Administrator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class MobileMessageCheck &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(checkMsg(<span class="string">"158********"</span>,<span class="string">"1234"</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SERVER_URL = <span class="string">"https://api.netease.im/sms/verifycode.action"</span>;<span class="comment">//校验验证码的请求路径URL</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> APP_KEY = <span class="string">"*******"</span>;<span class="comment">//网易云信分配的账号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> APP_SECRET = <span class="string">"*******"</span>;<span class="comment">//网易云信分配的密钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> NONCE = <span class="string">"123456"</span>;<span class="comment">//随机数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> checkMsg(<span class="keyword">String</span> phone, <span class="keyword">String</span> sum) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line">        HttpPost post = <span class="keyword">new</span> HttpPost(SERVER_URL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span> curTime = <span class="keyword">String</span>.valueOf((<span class="keyword">new</span> Date().getTime() / <span class="number">1000</span>L));</span><br><span class="line">        <span class="keyword">String</span> checkSum = CheckSumBuilder.getCheckSum(APP_SECRET, NONCE, curTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置请求的header</span></span><br><span class="line">        post.addHeader(<span class="string">"AppKey"</span>, APP_KEY);</span><br><span class="line">        post.addHeader(<span class="string">"Nonce"</span>, NONCE);</span><br><span class="line">        post.addHeader(<span class="string">"CurTime"</span>, curTime);</span><br><span class="line">        post.addHeader(<span class="string">"CheckSum"</span>, checkSum);</span><br><span class="line">        post.addHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置请求参数</span></span><br><span class="line">        List&lt;NameValuePair&gt; nameValuePairs = <span class="keyword">new</span> ArrayList&lt;NameValuePair&gt;();</span><br><span class="line">        nameValuePairs.<span class="built_in">add</span>(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"mobile"</span>, phone));</span><br><span class="line">        nameValuePairs.<span class="built_in">add</span>(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"code"</span>, sum));</span><br><span class="line"></span><br><span class="line">        post.setEntity(<span class="keyword">new</span> UrlEncodedFormEntity(nameValuePairs, <span class="string">"utf-8"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行请求</span></span><br><span class="line">        HttpResponse response = httpclient.execute(post);</span><br><span class="line">        <span class="keyword">String</span> responseEntity = EntityUtils.toString(response.getEntity(), <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否发送成功，发送成功返回true</span></span><br><span class="line">        <span class="keyword">String</span> code = JSON.parseObject(responseEntity).getString(<span class="string">"code"</span>);</span><br><span class="line">        <span class="keyword">if</span> (code.equals(<span class="string">"200"</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>获取计算checksum</strong></p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.lincoln.Untils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2017/3/22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckSumBuilder</span> &#123;</span></span><br><span class="line">    <span class="comment">// 计算并获取CheckSum</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">getCheckSum</span><span class="params">(<span class="keyword">String</span> appSecret, <span class="keyword">String</span> nonce, <span class="keyword">String</span> curTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encode(<span class="string">"sha1"</span>, appSecret + nonce + curTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并获取md5值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">getMD5</span><span class="params">(<span class="keyword">String</span> requestBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encode(<span class="string">"md5"</span>, requestBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">encode</span><span class="params">(<span class="keyword">String</span> algorithm, <span class="keyword">String</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == null) &#123;</span><br><span class="line">            <span class="keyword">return</span> null;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MessageDigest messageDigest = MessageDigest.getInstance(algorithm);</span><br><span class="line">            messageDigest.update(value.getBytes());</span><br><span class="line">            <span class="keyword">return</span> getFormattedText(messageDigest.digest());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">getFormattedText</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = bytes.length;</span><br><span class="line">        StringBuilder buf = <span class="keyword">new</span> StringBuilder(len * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            buf.append(HEX_DIGITS[(bytes[j] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f</span>]);</span><br><span class="line">            buf.append(HEX_DIGITS[bytes[j] &amp; <span class="number">0x0f</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] HEX_DIGITS =</span><br><span class="line">            &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>亲测有效。</p>
<p>ps:这里用的是默认的短信模板，如果自定义了短信模板，传入参数的时候多加一个模板id就行了。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java使用websocket和WebRTC实现视频通话</title>
    <url>/2017/03/11/Java%E4%BD%BF%E7%94%A8websocket%E5%92%8CWebRTC%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>最近这段时间折腾了一下WebRTC，这两天终于是抽了时间把WebRTC搞定了，去年就想弄的，但是确实没时间。看了网上的<a href="https://apprtc.appspot.com/的例子（可能需要翻墙访问），这个例子是部署在Google" target="_blank" rel="noopener">https://apprtc.appspot.com/的例子（可能需要翻墙访问），这个例子是部署在Google</a> App Engine上的应用程序，依赖与GAE的环境，后台的语言是python，而且还依赖Google App Engine Channel API，所以无法在本地运行，也无法扩展。费了一番功夫研读了例子的python端的源代码，决定用Java实现，Tomcat7之后开始支持WebSocket，打算用WebSocket代替Google App Engine Channel API实现前后台的通讯，在整个例子中Java+WebSocket起到的作用是负责客户端之间的通信，并不负责视频的传输，视频的传输依赖于WebRTC。<br><a id="more"></a></p>
<p>首先WebRTC,这个可以百度一下，大概就是一个音频和视频通讯技术，可以跨平台，只要能用浏览器的基本都可以使用，当然要你的浏览器支持。</p>
<p>这里引用了google的js库：<code>channel.js</code>。不过还是下载下来放到本地服务器吧，因为很多地方访问google.com很吃力啊。最开始就是这个js没有加载完郁闷了很久，还一直以为是代码写错了。</p>
<p>另外在进入页面的时候，注意初始化页面js中的一个参数：<code>initiator</code>：如果是创建人这个参数设为false；如果是加入的时候这个设置为true。为true的时候，才会发起视频通话的请求。</p>
<p><strong><h2>实现</h2></strong></p>
<p>对于前端JS代码及用到的对象大家可以去查看详细的代码介绍，我就贴一个连接的方法。首先建立一个客户端实时获取状态的连接，在GAE的例子上是通过GAE Channel API实现，我在这里用WebSocket实现，代码：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">function openChannel() &#123;  </span><br><span class="line">     console.log(<span class="string">"打开websocket"</span>)<span class="comment">;</span></span><br><span class="line">     socket = new WebSocket(<span class="string">"ws://192.168.1.158:8080/WebRTC/acgist.video/$&#123;requestScope.uid&#125;"</span>)<span class="comment">;				</span></span><br><span class="line">	 socket.onopen = onChannelOpened<span class="comment">;</span></span><br><span class="line">	 socket.onmessage = onChannelMessage<span class="comment">;</span></span><br><span class="line">	 socket.onclose = onChannelClosed<span class="comment">;  </span></span><br><span class="line">	 socket.onerror = onChannelError()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>服务端代码很简单，就是收到用户的请求，发送给另外一个用户就可以了，这里处理的其实是用户WebRTC的一些信息，并不是去传输视频，如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="built_in">Map</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnClose;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnMessage;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.OnOpen;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.Session;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.PathParam;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@author 李智</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>@date 2017/3/11</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> *</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet"> * </span>WebRTC视频通话</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/acgist.video/&#123;uid&#125;"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AcgistVideo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 最大通话数量</span></span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">int</span> MAX_COUNT = <span class="number">10</span>;</span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> long MAX_TIME_OUT = <span class="number">1</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 用户和用户的对话映射</span></span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; user_user = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;()); </span><br><span class="line">    <span class="comment">// 用户和websocket的session映射</span></span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Session&gt; sessions = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, Session&gt;());</span><br><span class="line">     </span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>打开websocket</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param session websocket的session</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param uid 打开用户的UID</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    public <span class="keyword">void</span> onOpen(Session session, <span class="meta">@PathParam</span>(<span class="string">"uid"</span>)<span class="built_in">String</span> uid) &#123;</span><br><span class="line">        session.setMaxIdleTimeout(MAX_TIME_OUT);</span><br><span class="line">        sessions.put(uid, session);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>websocket关闭</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param session 关闭的session</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param uid 关闭的用户标识</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    public <span class="keyword">void</span> onClose(Session session, <span class="meta">@PathParam</span>(<span class="string">"uid"</span>)<span class="built_in">String</span> uid) &#123;</span><br><span class="line">        remove(session, uid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>收到消息</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param message 消息内容</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param session 发送消息的session</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param uid</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    public <span class="keyword">void</span> onMessage(<span class="built_in">String</span> message, Session session, <span class="meta">@PathParam</span>(<span class="string">"uid"</span>)<span class="built_in">String</span> uid) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(uid != <span class="keyword">null</span> &amp;&amp; user_user.<span class="keyword">get</span>(uid) != <span class="keyword">null</span> &amp;&amp; AcgistVideo.sessions.<span class="keyword">get</span>(user_user.<span class="keyword">get</span>(uid)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Session osession = sessions.<span class="keyword">get</span>(user_user.<span class="keyword">get</span>(uid)); <span class="comment">// 被呼叫的session</span></span><br><span class="line">                <span class="keyword">if</span>(osession.isOpen())</span><br><span class="line">                    osession.getAsyncRemote().sendText(<span class="keyword">new</span> <span class="built_in">String</span>(message.getBytes(<span class="string">"utf-8"</span>)));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">this</span>.nowaiting(osession);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.nowaiting(session);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>没有人在等待</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param session 发送消息的session</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    private <span class="keyword">void</span> nowaiting(Session session) &#123;</span><br><span class="line">        session.getAsyncRemote().sendText(<span class="string">"&#123;\"type\" : \"nowaiting\"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>是否可以继续创建通话房间</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return 可以：true；不可以false；</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">static</span> boolean canCreate() &#123;</span><br><span class="line">        <span class="keyword">return</span> sessions.size() &lt;= MAX_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>判断是否可以加入</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param oid 被申请对话的ID</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return 如果能加入返回：true；否则返回false；</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">static</span> boolean canJoin(<span class="built_in">String</span> oid) &#123;</span><br><span class="line">        <span class="keyword">return</span> !(oid != <span class="keyword">null</span> &amp;&amp; user_user.containsKey(oid) &amp;&amp; user_user.<span class="keyword">get</span>(oid) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>添加视频对象</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param uid 申请对话的ID</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param oid 被申请对话的ID</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@return 是否是创建者：如果没有申请对话ID为创建者，否则为为加入者。创建者返回：true；加入者返回：false；</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    public <span class="keyword">static</span> boolean addUser(<span class="built_in">String</span> uid, <span class="built_in">String</span> oid) &#123;</span><br><span class="line">        <span class="keyword">if</span>(oid != <span class="keyword">null</span> &amp;&amp; !oid.isEmpty()) &#123;</span><br><span class="line">            AcgistVideo.user_user.put(uid, oid);</span><br><span class="line">            AcgistVideo.user_user.put(oid, uid);</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            AcgistVideo.user_user.put(uid, <span class="keyword">null</span>);</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>移除聊天用户</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param session 移除的session</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">     * </span>@param uid 移除的UID</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">     */</span></span></span></span><br><span class="line">    private <span class="keyword">static</span> <span class="keyword">void</span> remove(Session session, <span class="built_in">String</span> uid) &#123;</span><br><span class="line">        <span class="built_in">String</span> oid = user_user.<span class="keyword">get</span>(uid);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span>(oid != <span class="keyword">null</span>) user_user.put(oid, <span class="keyword">null</span>); <span class="comment">// 设置对方无人聊天</span></span><br><span class="line">         </span><br><span class="line">        sessions.remove(uid); <span class="comment">// 异常session</span></span><br><span class="line">        user_user.remove(uid); <span class="comment">// 移除自己</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(session != <span class="keyword">null</span> &amp;&amp; session.isOpen()) session.close(); <span class="comment">// 关闭session</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己测试的时候搞个公用的stun服务器弄一弄就好了。不过人多的时候会延迟很就是了，成功截图就不放了，人丑家贫。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>spring ioc原理（自己也可以写个spring）</title>
    <url>/2017/03/10/spring-ioc%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>最近，买了本spring入门书：spring In Action 。大致浏览了下感觉还不错。就是入门了点。Manning的书还是不错的，我虽然不像哪些只看Manning书的人那样专注于Manning,但怀着崇敬的心情和激情通览了一遍。又一次接受了IOC 、DI、AOP等Spring核心概念。 先就IOC和DI谈一点我的看法。<br><a id="more"></a><br>IOC（DI）：其实这个Spring架构核心的概念没有这么复杂，更不像有些书上描述的那样晦涩。Java程序员都知道：java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object（） 这样的语法来完成合作对象的申请工作。你会发现：对象间的耦合度高了。而IOC的思想是：Spring容器来实现这些相互依赖对象的创建、协调工作。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了（IOC、DI）。</p>
<p>这是我对Spring的IOC的体会。DI其实就是IOC的另外一种说法。DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。<code>他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。</code></p>
<p>如果对这一核心概念还不理解：这里引用一个叫Bromon的blog上找到的浅显易懂的答案：</p>
<blockquote>
<p>IoC与DI</p>
</blockquote>
<blockquote>
<p>　　首先想说说IoC（Inversion of Control，控制倒转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p>
</blockquote>
<blockquote>
<p>　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。如果你还不明白的话，我决定放弃。</p>
</blockquote>
<blockquote>
<p>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。关于反射的相关资料请查阅java doc。<br>　理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。</p>
</blockquote>
<p>如果还不明白，放弃java吧！</p>
<p><strong>下面来让大家了解一下Spring到底是怎么运行的。</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;   </span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> FileSystemXmlApplicationContext(   </span><br><span class="line">                <span class="string">"applicationContext.xml"</span>);   </span><br><span class="line">        Animal animal = (Animal) context.getBean(<span class="string">"animal"</span>);   </span><br><span class="line">        animal.say();   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码你一定很熟悉吧，不过还是让我们分析一下它吧，首先是applicationContext.xml</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">"animal"</span> <span class="built_in">class</span>=<span class="string">"phz.springframework.test.Cat"</span>&gt;   </span><br><span class="line">        &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">"name"</span> value=<span class="string">"kitty"</span> /&gt;   </span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>他有一个类Cat</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="title">implements</span> <span class="title">Animal</span> &#123;</span>   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"I am "</span> + name + <span class="string">"!"</span>);   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.name = name;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现了Animal接口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>Animal &#123;   </span><br><span class="line">    public void say();   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显上面的代码输出I am kitty! </p>
<p>那么到底Spring是如何做到的呢？<br>接下来就让我们自己写个Spring 来看看Spring 到底是怎么运行的吧！ </p>
<p>首先，我们定义一个Bean类，这个类用来存放一个Bean拥有的属性</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Bean Id */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> id;   </span><br><span class="line">    <span class="comment">/* Bean Class */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> type;   </span><br><span class="line">    <span class="comment">/* Bean Property */</span>  </span><br><span class="line">    <span class="keyword">private</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; properties = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>一个Bean包括id,type,和Properties。 </p>
<p>接下来Spring 就开始加载我们的配置文件了，将我们配置的信息保存在一个HashMap中，HashMap的key就是Bean 的 Id ，HasMap 的value是这个Bean，只有这样我们才能通过context.getBean(“animal”)这个方法获得Animal这个类。我们都知道Spirng可以注入基本类型，而且可以注入像List，Map这样的类型，接下来就让我们以Map为例看看Spring是怎么保存的吧 </p>
<p>Map配置可以像下面的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"test"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"Test"</span>&gt;   </span><br><span class="line">        &lt;property name=<span class="string">"testMap"</span>&gt;   </span><br><span class="line">            &lt;map&gt;   </span><br><span class="line">                &lt;entry key=<span class="string">"a"</span>&gt;   </span><br><span class="line">                    &lt;value&gt;<span class="number">1</span>&lt;<span class="regexp">/value&gt;   </span></span><br><span class="line"><span class="regexp">                &lt;/</span>entry&gt;   </span><br><span class="line">                &lt;entry key=<span class="string">"b"</span>&gt;   </span><br><span class="line">                    &lt;value&gt;<span class="number">2</span>&lt;<span class="regexp">/value&gt;   </span></span><br><span class="line"><span class="regexp">                &lt;/</span>entry&gt;   </span><br><span class="line">            &lt;<span class="regexp">/map&gt;   </span></span><br><span class="line"><span class="regexp">        &lt;/</span>property&gt;   </span><br><span class="line">    &lt;<span class="regexp">/bean&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring是怎样保存上面的配置呢？，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (beanProperty.element(<span class="string">"map"</span>) != <span class="keyword">null</span>) &#123;   </span><br><span class="line">                    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; propertiesMap = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;();   </span><br><span class="line">                    <span class="built_in">Element</span> propertiesListMap = (<span class="built_in">Element</span>) beanProperty   </span><br><span class="line">                            .elements().<span class="keyword">get</span>(<span class="number">0</span>);   </span><br><span class="line">                    <span class="built_in">Iterator</span>&lt;?&gt; propertiesIterator = propertiesListMap   </span><br><span class="line">                            .elements().iterator();   </span><br><span class="line">                    <span class="keyword">while</span> (propertiesIterator.hasNext()) &#123;   </span><br><span class="line">                        <span class="built_in">Element</span> vet = (<span class="built_in">Element</span>) propertiesIterator.next();   </span><br><span class="line">                        <span class="keyword">if</span> (vet.getName().equals(<span class="string">"entry"</span>)) &#123;   </span><br><span class="line">                            <span class="built_in">String</span> key = vet.attributeValue(<span class="string">"key"</span>);   </span><br><span class="line">                            <span class="built_in">Iterator</span>&lt;?&gt; valuesIterator = vet.elements()   </span><br><span class="line">                                    .iterator();   </span><br><span class="line">                            <span class="keyword">while</span> (valuesIterator.hasNext()) &#123;   </span><br><span class="line">                                <span class="built_in">Element</span> value = (<span class="built_in">Element</span>) valuesIterator.next();   </span><br><span class="line">                                <span class="keyword">if</span> (value.getName().equals(<span class="string">"value"</span>)) &#123;   </span><br><span class="line">                                    propertiesMap.put(key, value.getText());   </span><br><span class="line">                                &#125;   </span><br><span class="line">                                <span class="keyword">if</span> (value.getName().equals(<span class="string">"ref"</span>)) &#123;   </span><br><span class="line">                                    propertiesMap.put(key, <span class="keyword">new</span> <span class="built_in">String</span>[] &#123; value   </span><br><span class="line">                                            .attributeValue(<span class="string">"bean"</span>) &#125;);   </span><br><span class="line">                                &#125;   </span><br><span class="line">                            &#125;   </span><br><span class="line">                        &#125;   </span><br><span class="line">                    &#125;   </span><br><span class="line">                    bean.getProperties().put(name, propertiesMap);   </span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
<p>接下来就进入最核心部分了，让我们看看Spring 到底是怎么依赖注入的吧，其实依赖注入的思想也很简单，它是通过反射机制实现的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中的类属性注入到类中。让我们看看具体它是怎么做的吧。<br>首先实例化一个类，像这样</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="keyword">new</span><span class="type">Instance</span>(<span class="keyword">String</span> className) &#123;   </span><br><span class="line">        Class&lt;?&gt; cls = <span class="literal">null</span>;   </span><br><span class="line">        Object obj = <span class="literal">null</span>;   </span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            cls = Class.forName(className);   </span><br><span class="line">            obj = cls.<span class="keyword">new</span><span class="type">Instance</span>();   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;   </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;   </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;   </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> obj;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接着它将这个类的依赖注入进去，像这样</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> static void setProperty(Object obj, String name, String value) &#123;   </span><br><span class="line">        <span class="class"><span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> <span class="title">Object</span>&gt; <span class="title">clazz</span> = <span class="title">obj</span>.<span class="title">getClass</span>();   </span></span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            String methodName = returnSetMthodName(name);   </span><br><span class="line">            <span class="function"><span class="keyword">Method</span>[] <span class="title">ms</span> =</span> clazz.getMethods();   </span><br><span class="line">            <span class="keyword">for</span> (<span class="function"><span class="keyword">Method</span> <span class="title">m</span> :</span> ms) &#123;   </span><br><span class="line">                <span class="keyword">if</span> (m.getName().equals(methodName)) &#123;   </span><br><span class="line">                    <span class="keyword">if</span> (m.getParameterTypes().length == <span class="number">1</span>) &#123;   </span><br><span class="line">                        <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">clazzParameterType</span> = <span class="title">m</span>.<span class="title">getParameterTypes</span>()[0];   </span></span><br><span class="line">                        setFieldValue(clazzParameterType.getName(), value, m,   </span><br><span class="line">                                obj);   </span><br><span class="line">                        break;   </span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;   </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;   </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;   </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);   </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;   </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);   </span><br><span class="line">        &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后它将这个类的实例返回给我们，我们就可以用了。我们还是以Map为例看看它是怎么做的，我写的代码里面是创建一个HashMap并把该HashMap注入到需要注入的类中，像这样，</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">if</span> (value instanceof <span class="meta">Map</span>) &#123;   </span><br><span class="line">                <span class="keyword">Iterator&lt;?&gt; </span>entryIterator = ((<span class="meta">Map</span>&lt;?, ?&gt;) value).entrySet()   </span><br><span class="line">                        .<span class="keyword">iterator(); </span>  </span><br><span class="line">                <span class="meta">Map</span>&lt;<span class="keyword">String, </span>Object&gt; <span class="meta">map</span> = new HashMap&lt;<span class="keyword">String, </span>Object&gt;()<span class="comment">;   </span></span><br><span class="line">                <span class="meta">while</span> (entryIterator.hasNext()) &#123;   </span><br><span class="line">                    <span class="meta">Entry</span>&lt;?, ?&gt; entryMap = (<span class="meta">Entry</span>&lt;?, ?&gt;) entryIterator.next()<span class="comment">;   </span></span><br><span class="line">                    <span class="meta">if</span> (entryMap.getValue() instanceof <span class="keyword">String[]) </span>&#123;   </span><br><span class="line">                        <span class="meta">map</span>.put((<span class="keyword">String) </span>entryMap.getKey(),   </span><br><span class="line">                                getBean(((<span class="keyword">String[]) </span>entryMap.getValue())[<span class="number">0</span>]))<span class="comment">;   </span></span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">BeanProcesser.setProperty(obj, </span>property, <span class="meta">map</span>)<span class="comment">;   </span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>好了，这样我们就可以用Spring 给我们创建的类了，是不是也不是很难啊？当然Spring能做到的远不止这些，这个示例程序仅仅提供了Spring最核心的依赖注入功能中的一部分。<br>本文参考了大量文章无法一一感谢，在这一起感谢，如果侵犯了你的版权深表歉意，很希望对大家有帮助！</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Volatile小结</title>
    <url>/2017/03/03/Volatile%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote>
<p>1）Java 中能创建 Volatile 数组吗？</p>
</blockquote>
<p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。<br><a id="more"></a></p>
<blockquote>
<p>2）volatile 能使得一个非原子操作变成原子操作吗？</p>
</blockquote>
<p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p>
<blockquote>
<p>3）volatile 修饰符有过什么实践？</p>
</blockquote>
<p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p>
<blockquote>
<p>4）volatile 类型变量提供什么保证？</p>
</blockquote>
<p>volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么volatile不能保证原子性而Atomic可以？</title>
    <url>/2017/03/02/%E4%B8%BA%E4%BB%80%E4%B9%88volatile%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E8%80%8CAtomic%E5%8F%AF%E4%BB%A5%EF%BC%9F/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>在Java中long赋值不是原子操作，因为先写32位，再写后32位，分两步操作，而AtomicLong赋值是原子操作，为什么？为什么volatile能替代简单的锁，却不能保证原子性？这里面涉及volatile，是java中的一个我觉得这个词在Java规范中从未被解释清楚的神奇关键词，在Sun的JDK官方文档是这样形容volatile的：<br><a id="more"></a></p>
<blockquote>
<p>The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes. A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable.</p>
</blockquote>
<p>意思就是说，如果一个变量加了volatile关键字，就会告诉编译器和JVM的内存模型：这个变量是对所有线程共享的、可见的，每次jvm都会读取最新写入的值并使其最新值在所有CPU可见。<strong>volatile似乎是有时候可以代替简单的锁，似乎加了volatile关键字就省掉了锁。但又说volatile不能保证原子性（java程序员很熟悉这句话：volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性）</strong>。这不是互相矛盾吗？</p>
<blockquote>
<p>不要将volatile用在getAndOperate场合，仅仅set或者get的场景是适合volatile的</p>
</blockquote>
<p><strong>不要将volatile用在getAndOperate场合（这种场合不原子，需要再加锁），仅仅set或者get的场景是适合volatile的。</strong></p>
<blockquote>
<p>volatile没有原子性举例：AtomicInteger自增</p>
</blockquote>
<p>例如你让一个volatile的integer自增（i++），其实要分成3步：1）读取volatile变量值到local； 2）增加变量的值；3）把local的值写回，让其它的线程可见。这3步的jvm指令为：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">mov    <span class="number">0</span>xc(<span class="built_in">%r</span>10),<span class="built_in">%r</span>8d <span class="comment">; Load</span></span><br><span class="line">inc    <span class="built_in">%r</span>8d           <span class="comment">; Increment</span></span><br><span class="line">mov    <span class="built_in">%r</span>8d,<span class="number">0</span>xc(<span class="built_in">%r</span>10) <span class="comment">; Store</span></span><br><span class="line"><span class="keyword">lock</span> addl $<span class="number">0</span>x0,(<span class="built_in">%rsp</span>) <span class="comment">; StoreLoad Barrier</span></span><br></pre></td></tr></table></figure>
<p>注意最后一步是内存屏障。</p>
<blockquote>
<p>什么是内存屏障（Memory Barrier）？</p>
</blockquote>
<p>内存屏障（memory barrier）是一个CPU指令。基本上，它是这样一条指令： a) 确保一些特定操作执行的顺序； b) 影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。</p>
<p>内存屏障（memory barrier）和volatile什么关系？上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</p>
<blockquote>
<p>volatile为什么没有原子性?</p>
</blockquote>
<p>明白了内存屏障（memory barrier）这个CPU指令，回到前面的JVM指令：从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，但中间的几步（从Load到Store）是不安全的，中间如果其他的CPU修改了值将会丢失。下面的测试代码可以实际测试voaltile的自增没有原子性：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">long</span> _longVal = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopVolatile</span> <span class="keyword">implements</span> <span class="title">Runnable</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">            <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (val &lt; <span class="number">10000000</span>L) &#123;</span><br><span class="line">                _longVal++;</span><br><span class="line">                val++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoopVolatile2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> &#123;</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">            <span class="keyword">long</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (val &lt; <span class="number">10000000</span>L) &#123;</span><br><span class="line">                _longVal++;</span><br><span class="line">                val++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">void</span> testVolatile()&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopVolatile());</span><br><span class="line">        t1.start();</span><br><span class="line">         </span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> LoopVolatile2());</span><br><span class="line">        t2.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">"final val is: "</span> + _longVal);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="string">Output:</span>-------------</span><br><span class="line">     </span><br><span class="line"><span class="keyword">final</span> val <span class="string">is:</span> <span class="number">11223828</span></span><br><span class="line"><span class="keyword">final</span> val <span class="string">is:</span> <span class="number">17567127</span></span><br><span class="line"><span class="keyword">final</span> val <span class="string">is:</span> <span class="number">12912109</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>volatile没有原子性举例：singleton单例模式实现</p>
</blockquote>
<p>这是一段线程不安全的singleton（单例模式）实现，尽管使用了volatile：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">wrongsingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> wrongsingleton _instance = <span class="literal">null</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">wrongsingleton</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> wrongsingleton <span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> wrongsingleton();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的测试代码可以测试出是线程不安全的：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">wrongsingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> volatile wrongsingleton _instance = <span class="literal">null</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> wrongsingleton() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> wrongsingleton getInstance() &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (_instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> <span class="type">wrongsingleton</span>();</span><br><span class="line">            System.out.println(<span class="string">"--initialized once."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> void testInit()&#123;</span><br><span class="line">         </span><br><span class="line">        Thread t1 = <span class="keyword">new</span> <span class="type">Thread</span>(<span class="keyword">new</span> <span class="type">LoopInit</span>());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> <span class="type">Thread</span>(<span class="keyword">new</span> <span class="type">LoopInit2</span>());</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> <span class="type">Thread</span>(<span class="keyword">new</span> <span class="type">LoopInit</span>());</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> <span class="type">Thread</span>(<span class="keyword">new</span> <span class="type">LoopInit2</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span> (t1.isAlive() || t2.isAlive() || t3.isAlive()|| t4.isAlive()) &#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">输出：有时输出<span class="string">"--initialized once."</span>一次，有时输出好几次</span><br></pre></td></tr></table></figure>
<p>原因自然和上面的例子是一样的。<strong>因为volatile保证变量对线程的可见性，但不保证原子性。</strong></p>
<p>附：正确线程安全的单例模式写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeLazyInitialization</span> </span>&#123; </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Resource resource; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Resource <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="keyword">if</span> (resource == <span class="keyword">null</span>) </span><br><span class="line">          resource = <span class="keyword">new</span> Resource(); </span><br><span class="line">      <span class="keyword">return</span> resource; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerInitialization</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Resource resource = <span class="keyword">new</span> Resource(); </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getResource</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> resource; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>延迟初始化的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFactory</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceHolder</span> </span>&#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Resource resource = <span class="keyword">new</span> Resource(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Resource <span class="title">getResource</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> ResourceHolder.resource ; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二次检查锁定/Double Checked Locking的写法（反模式）</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">public class SingletonDemo &#123;</span><br><span class="line">   <span class="keyword"> private</span><span class="keyword"> static</span> volatile SingletonDemo<span class="built_in"> instance </span>= null;//注意需要volatile</span><br><span class="line">  </span><br><span class="line">   <span class="keyword"> private</span> SingletonDemo() &#123;   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword"> public</span><span class="keyword"> static</span> SingletonDemo getInstance() &#123;</span><br><span class="line">       <span class="built_in"> if </span>(instance == null) &#123; //二次检查，比直接用独占锁效率高</span><br><span class="line">               synchronized (SingletonDemo .class)&#123;</span><br><span class="line">                   <span class="built_in"> if </span>(instance == null) &#123;</span><br><span class="line">                              <span class="built_in"> instance </span>=<span class="built_in"> new </span>SingletonDemo (); </span><br><span class="line">                    &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="built_in"> return </span>instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么AtomicXXX具有原子性和可见性？</p>
</blockquote>
<p>就拿AtomicLong来说，它既解决了上述的volatile的原子性没有保证的问题，又具有可见性。它是如何做到的？CAS（比较并交换）指令。 其实AtomicLong的源码里也用到了volatile，但只是用来读取或写入，见源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicLong with the given initial value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">(<span class="keyword">long</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicLong with initial value &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其CAS源码核心代码为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> compare_and_swap (<span class="keyword">int</span>* <span class="keyword">reg</span>, <span class="keyword">int</span> oldval, <span class="keyword">int</span> newval) </span><br><span class="line">&#123;</span><br><span class="line">  ATOMIC();</span><br><span class="line">  <span class="keyword">int</span> old_reg_val = *<span class="keyword">reg</span>;</span><br><span class="line">  <span class="keyword">if</span> (old_reg_val == oldval) </span><br><span class="line">     *<span class="keyword">reg</span> = newval;</span><br><span class="line">  END_ATOMIC();</span><br><span class="line">  <span class="keyword">return</span> old_reg_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚拟机指令为：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">mov    <span class="number">0</span>xc(<span class="built_in">%r</span>11),<span class="built_in">%eax</span>       <span class="comment">; Load</span></span><br><span class="line">mov    <span class="built_in">%eax</span>,<span class="built_in">%r</span>8d            </span><br><span class="line">inc    <span class="built_in">%r</span>8d                 <span class="comment">; Increment</span></span><br><span class="line"><span class="keyword">lock</span> cmpxchg <span class="built_in">%r</span>8d,<span class="number">0</span>xc(<span class="built_in">%r</span>11) <span class="comment">; Compare and exchange</span></span><br></pre></td></tr></table></figure>
<p>因为CAS是基于乐观锁的，也就是说当写入的时候，如果寄存器旧值已经不等于现值，说明有其他CPU在修改，那就继续尝试。所以这就保证了操作的原子性。</p>
<p> <img src="http://images.cnitblog.com/blog/28306/201402/191824486252285.png " width="400" height="300" alt="图片名称" align="center"></p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统分层优化</title>
    <url>/2017/02/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B1%82%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>网上有丰富的数据库优化方案，但是大多都是零零碎碎，系统地介绍数据库优化的很少。笔者根据自己的经验，以及参考了其他高手的优化文章，整理一份系统的优化方案。</p>
<p>数据库优化的目的是提高DB的工作效率，减少响应时间。基于此，笔者认为应该从如下四个层次来优化数据库性能。<br><a id="more"></a></p>
<p><li>硬件层面优化</li></p>
<p><li>操作系统/DBMS层面优化</li></p>
<p><li>DB设计层面优化</li></p>
<p><li>程序设计层面的优化</li></p>
<blockquote>
<ol>
<li>硬件层面优化<br>该层面的优化是最底层的，包括内存、CPU、磁盘/磁盘阵列等硬件的优化。虽然可优化的点并不多，但是在整个数据库优化中不可或缺。</li>
<li>操作系统/DBMS层面的优化<br>包括DBMS的选择、缓存的设置、数据文件的存储位置及方法(连续存储/随机存储)、存储引擎的选择(MySQL里面会有多个引擎)、I/O优化(磁盘I/O、逻辑I/O)。该层面的优化内容相对不多，但是数据库优化的瓶颈一般都在这里。</li>
<li>DB设计层面优化<br>该层面可优化的点很多，包括数据库范式、数据表结构、数据类型、视图、索引、表/字段冗余、表分割(水平分割及垂直分割、分类分割)、表触发器、命名等多方面，而且每个方面又有很多的知识点，这是数据库优化的基础。</li>
<li>程序设计层面优化<br>这里由程序员控制层面的优化。包括SQL语句、存储过程、临时表、业务逻辑、算法设计、运算符、条件顺序、数据库函数。这层的知识点比较散，而且多。程序员应该下功夫的地方。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>数据库那点事</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序</title>
    <url>/2017/02/20/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>希尔排序，也称<strong>递减增量排序算法</strong>，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<p><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li></p>
<p><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位<br><a id="more"></a><br>原始的算法实现在最坏的情况下需要进行O(n2)的比较和交换。之后对算法进行了少量修改，可以使得性能提升至O(n log2 n)。这比最好的比较算法的O(n log n)要差一些。</li></p>
<p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<p>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p>
<p>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用<code>i += step_size</code>而不是<code>i++</code>）。</p>
<p>例如，假设有这样一组数<code>[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]</code>，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<blockquote>
<p>13 14 94 33 82<br>25 59 94 65 23<br>45 27 73 25 39<br>10</p>
</blockquote>
<p>然后我们对每列进行排序：</p>
<blockquote>
<p>10 14 73 25 23<br>13 27 94 33 39<br>25 59 94 65 82<br>45</p>
</blockquote>
<p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<blockquote>
<p>10 14 73<br>25 23 13<br>27 94 33<br>39 25 59<br>94 65 82<br>45</p>
</blockquote>
<p>排序之后变为：</p>
<blockquote>
<p>10 14 13<br>25 23 33<br>27 25 59<br>39 65 73<br>45 94 82<br>94</p>
</blockquote>
<p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</p>
<p>该算法最初建议步长选择为n/2并且对步长取半直到步长达到1。虽然这样取可以比O(n’2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。</p>
<p>比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。</p>
<p><strong>实现：</strong><br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">shell_sort(int[]</span> <span class="string">arr)</span> <span class="string">&#123;</span></span><br><span class="line">	<span class="string">int</span> <span class="string">gap</span> <span class="string">=</span> <span class="number">1</span><span class="string">,</span> <span class="string">i,</span> <span class="string">j,</span> <span class="string">len</span> <span class="string">=</span> <span class="string">arr.length;</span></span><br><span class="line">	<span class="string">int</span> <span class="string">temp;</span></span><br><span class="line">	<span class="string">while</span> <span class="string">(gap</span> <span class="string">&lt;</span> <span class="string">len</span> <span class="string">/</span> <span class="number">3</span><span class="string">)</span></span><br><span class="line">		<span class="string">gap</span> <span class="string">=</span> <span class="string">gap</span> <span class="string">*</span> <span class="number">3</span> <span class="string">+</span> <span class="number">1</span><span class="string">;</span> <span class="string">//</span> <span class="number">1</span><span class="string">,</span> <span class="number">4</span><span class="string">,</span> <span class="number">13</span><span class="string">,</span> <span class="number">40</span><span class="string">,</span> <span class="number">121</span><span class="string">,</span> <span class="string">...</span></span><br><span class="line">	<span class="string">for</span> <span class="string">(;</span> <span class="string">gap</span> <span class="string">&gt;</span> <span class="number">0</span><span class="string">;</span> <span class="string">gap</span> <span class="string">/=</span> <span class="number">3</span><span class="string">)</span></span><br><span class="line">		<span class="string">for</span> <span class="string">(i</span> <span class="string">=</span> <span class="string">gap;</span> <span class="string">i</span> <span class="string">&lt;</span> <span class="string">len;</span> <span class="string">i++)</span> <span class="string">&#123;</span></span><br><span class="line">			<span class="string">temp</span> <span class="string">=</span> <span class="string">arr[i];</span></span><br><span class="line">			<span class="string">for</span> <span class="string">(j</span> <span class="string">=</span> <span class="string">i</span> <span class="bullet">-</span> <span class="string">gap;</span> <span class="string">j</span> <span class="string">&gt;=</span> <span class="number">0</span> <span class="string">&amp;&amp;</span> <span class="string">arr[j]</span> <span class="string">&gt;</span> <span class="string">temp;</span> <span class="string">j</span> <span class="string">-=</span> <span class="string">gap)</span></span><br><span class="line">				<span class="string">arr[j</span> <span class="string">+</span> <span class="string">gap]</span> <span class="string">=</span> <span class="string">arr[j];</span></span><br><span class="line">			<span class="string">arr[j</span> <span class="string">+</span> <span class="string">gap]</span> <span class="string">=</span> <span class="string">temp;</span></span><br><span class="line">		<span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库30条军规解读</title>
    <url>/2017/02/18/58%E5%88%B0%E5%AE%B6%E6%95%B0%E6%8D%AE%E5%BA%9330%E6%9D%A1%E5%86%9B%E8%A7%84%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>军规适用场景：并发量大、数据量大的互联网业务<br><br>军规：介绍内容<br><br>解读：讲解原因，解读比军规更重要<br> <a id="more"></a><br>一、基础规范</p>
<p>（1）必须使用InnoDB存储引擎</p>
<blockquote>
<p>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</p>
</blockquote>
<p><br>（2）必须使用UTF8字符集</p>
<blockquote>
<p>解读：万国码，无需转码，无乱码风险，节省空间</p>
</blockquote>
<p><br>（3）数据表、数据字段必须加入中文注释</p>
<blockquote>
<p>解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的</p>
</blockquote>
<p><br>（4）禁止使用存储过程、视图、触发器、Event</p>
<blockquote>
<p>解读：高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU计算还是上移吧</p>
</blockquote>
<p><br>（5）禁止存储大文件或者大照片</p>
<blockquote>
<p>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI多好</p>
</blockquote>
<p><br>二、命名规范</p>
<p>（6）只允许使用内网域名，而不是ip连接数据库</p>
<p>（7）线上环境、开发环境、测试环境数据库内网域名遵循命名规范</p>
<blockquote>
<p>业务名称：xxx<br>线上环境：dj.xxx.db<br>开发环境：dj.xxx.rdb<br>测试环境：dj.xxx.tdb<br>从库在名称后加-s标识，备库在名称后加-ss标识<br>线上从库：dj.xxx-s.db<br>线上备库：dj.xxx-sss.db</p>
</blockquote>
<p><br>（8）库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用</p>
<p>（9）表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</p>
<p>三、表设计规范</p>
<p>（10）单实例表数目必须小于500</p>
<p>（11）单表列数目必须小于30</p>
<p>（12）表必须有主键，例如自增主键</p>
<blockquote>
<p>解读：<br>a）主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用<br>b）主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率<br>c） 无主键的表删除，在row模式的主从架构，会导致备库夯住</p>
</blockquote>
<p><br>（13）禁止使用外键，如果有外键完整性约束，需要应用程序控制</p>
<blockquote>
<p>解读：外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先</p>
</blockquote>
<p><br>四、字段设计规范</p>
<p><br>（14）必须把字段定义为NOT NULL并且提供默认值</p>
<blockquote>
<p>解读：<br>a）null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化<br>b）null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多<br>c）null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识<br>d）对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录</p>
</blockquote>
<p><br>（15）禁止使用TEXT、BLOB类型</p>
<blockquote>
<p>解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能</p>
</blockquote>
<p><br>（16）禁止使用小数存储货币</p>
<blockquote>
<p>解读：使用整数吧，小数容易导致钱对不上</p>
</blockquote>
<p><br>（17）必须使用varchar(20)存储手机号</p>
<blockquote>
<p>解读：<br>a）涉及到区号或者国家代号，可能出现+-()<br>b）手机号会去做数学运算么？<br>c）varchar可以支持模糊查询，例如：like“138%”</p>
</blockquote>
<p><br>（18）禁止使用ENUM，可使用TINYINT代替</p>
<blockquote>
<p>解读：<br>a）增加新的ENUM值要做DDL操作<br>b）ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</p>
</blockquote>
<p><br>五、索引设计规范</p>
<p>（19）单表索引建议控制在5个以内</p>
<p>（20）单索引字段数不允许超过5个</p>
<blockquote>
<p>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</p>
</blockquote>
<p><br>（21）禁止在更新十分频繁、区分度不高的属性上建立索引</p>
<blockquote>
<p>解读：<br>a）更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能<br>b）“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似</p>
</blockquote>
<p><br>（22）建立组合索引，必须把区分度高的字段放在前面</p>
<blockquote>
<p>解读：能够更加有效的过滤数据</p>
</blockquote>
<p><br>六、SQL使用规范</p>
<p>（23）禁止使用SELECT *，只获取必要的字段，需要显示说明列属性</p>
<blockquote>
<p>解读：<br>a）读取不需要的列会增加CPU、IO、NET消耗<br>b）不能有效的利用覆盖索引<br>c）使用SELECT *容易在增加或者删除字段后出现程序BUG</p>
</blockquote>
<p><br>（24）禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</p>
<blockquote>
<p>解读：容易在增加或者删除字段后出现程序BUG</p>
</blockquote>
<p><br>（25）禁止使用属性隐式转换</p>
<blockquote>
<p>解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中phone索引，猜猜为什么？（这个线上问题不止出现过一次）</p>
</blockquote>
<p><br>（26）禁止在WHERE条件的属性上使用函数或者表达式</p>
<blockquote>
<p>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描<br>正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</p>
</blockquote>
<p><br>（27）禁止负向查询，以及%开头的模糊查询</p>
<blockquote>
<p>解读：<br>a）负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描<br>b）%开头的模糊查询，会导致全表扫描</p>
</blockquote>
<p><br>（28）禁止大表使用JOIN查询，禁止大表使用子查询</p>
<blockquote>
<p>解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能</p>
</blockquote>
<p><br>（29）禁止使用OR条件，必须改为IN查询</p>
<blockquote>
<p>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？</p>
</blockquote>
<p><br>（30）应用程序必须捕获SQL异常，并有相应处理</p>
<p>总结：大数据量高并发的互联网业务，极大影响数据库性能的都不让用，不让用哟。<br>==【完】==</p>
]]></content>
      <categories>
        <category>数据库那点事</category>
      </categories>
      <tags>
        <tag>军规</tag>
      </tags>
  </entry>
  <entry>
    <title>apache poi操作(适用于word 2007)</title>
    <url>/2017/02/18/apache-poi%E6%93%8D%E4%BD%9C-%E9%80%82%E7%94%A8%E4%BA%8Eword-2007/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>适用于word 2007 poi 版本 3.7<br><a id="more"></a><br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.poi.POIXMLDocument;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.openxml4j.opc.OPCPackage;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFDocument;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFParagraph;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFRun;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFTable;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFTableCell;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFTableRow;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适用于word 2007 poi 版本 3.7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class WordPoiUtil &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据指定的参数值、模板，生成 word 文档</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param param</span></span><br><span class="line"><span class="comment">     *            需要替换的变量</span></span><br><span class="line"><span class="comment">     * @param template</span></span><br><span class="line"><span class="comment">     *            模板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> XWPFDocument generateWord(Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; param,</span><br><span class="line">            <span class="keyword">String</span> template) &#123;</span><br><span class="line">        XWPFDocument doc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OPCPackage pack = POIXMLDocument.openPackage(template);</span><br><span class="line">            doc = <span class="keyword">new</span> XWPFDocument(pack);</span><br><span class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; param.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理段落</span></span><br><span class="line">                List&lt;XWPFParagraph&gt; paragraphList = doc.getParagraphs();</span><br><span class="line">                processParagraphs(paragraphList, param, doc);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理表格</span></span><br><span class="line">                Iterator&lt;XWPFTable&gt; it = doc.getTablesIterator();</span><br><span class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                    XWPFTable table = it.next();</span><br><span class="line">                    List&lt;XWPFTableRow&gt; rows = table.getRows();</span><br><span class="line">                    <span class="keyword">for</span> (XWPFTableRow row : rows) &#123;</span><br><span class="line">                        List&lt;XWPFTableCell&gt; cells = row.getTableCells();</span><br><span class="line">                        <span class="keyword">for</span> (XWPFTableCell cell : cells) &#123;</span><br><span class="line">                            List&lt;XWPFParagraph&gt; paragraphListTable = cell</span><br><span class="line">                                    .getParagraphs();</span><br><span class="line">                            processParagraphs(paragraphListTable, param, doc);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理段落</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param paragraphList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> processParagraphs(List&lt;XWPFParagraph&gt; paragraphList,</span><br><span class="line">            Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; param, XWPFDocument doc) &#123;</span><br><span class="line">        <span class="keyword">if</span> (paragraphList != <span class="keyword">null</span> &amp;&amp; paragraphList.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (XWPFParagraph paragraph : paragraphList) &#123;</span><br><span class="line">                <span class="built_in">boolean</span> addReplace = <span class="keyword">false</span>;</span><br><span class="line">                List&lt;XWPFRun&gt; runs = paragraph.getRuns();</span><br><span class="line">                <span class="comment">//每个需要替换的key的run的位置的集合</span></span><br><span class="line">                List&lt;Integer&gt; replaceRuns = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="comment">//每个段落的所有的key run的集合</span></span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; perReplaceRunList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i&lt; runs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">String</span> <span class="built_in">text</span> = runs.<span class="built_in">get</span>(i).getText(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(addReplace)&#123;</span><br><span class="line">                        replaceRuns.<span class="built_in">add</span>(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">text</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">text</span>.contains(<span class="string">"#"</span>))&#123;</span><br><span class="line">                        addReplace = <span class="keyword">true</span>;</span><br><span class="line">                        replaceRuns.<span class="built_in">add</span>(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">text</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">text</span>.contains(<span class="string">"&#125;"</span>))&#123;</span><br><span class="line">                        addReplace = <span class="keyword">false</span>;</span><br><span class="line">                        perReplaceRunList.<span class="built_in">add</span>(replaceRuns);</span><br><span class="line">                        replaceRuns = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;perReplaceRunList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    List&lt;Integer&gt; runsList = perReplaceRunList.<span class="built_in">get</span>(i);</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"=========================="</span>);</span><br><span class="line">                    StringBuffer textSb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;j&lt;runsList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        System.out.<span class="built_in">println</span>(<span class="string">"============replace_runs"</span>+runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).getText(<span class="number">0</span>));</span><br><span class="line">                        textSb.<span class="built_in">append</span>(runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).getText(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">String</span> replaceStr = textSb.toString();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j&lt;runsList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        <span class="keyword">for</span> (Entry&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; entry : param.entrySet()) &#123;</span><br><span class="line">                            <span class="keyword">String</span> <span class="built_in">key</span> = entry.getKey();</span><br><span class="line">                            <span class="keyword">if</span> (replaceStr.indexOf(<span class="built_in">key</span>) != <span class="number">-1</span>) &#123;</span><br><span class="line">                                <span class="keyword">Object</span> value = entry.getValue();</span><br><span class="line">                                <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="keyword">String</span>) &#123;<span class="comment">// 文本替换</span></span><br><span class="line">                                    replaceStr = replaceStr.replace(<span class="built_in">key</span>, value.toString());</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"==========="</span>+replaceStr);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;j&lt;runsList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                            runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).setText(replaceStr, <span class="number">0</span>);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).setText(<span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;j&lt;runsList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        System.out.<span class="built_in">println</span>(<span class="string">"============转换后"</span>+runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).getText(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">String</span>&gt; getReplaceFields(<span class="keyword">String</span> template)&#123;</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; replaceFields = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">        XWPFDocument doc = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            OPCPackage pack = POIXMLDocument.openPackage(template);</span><br><span class="line">            doc = <span class="keyword">new</span> XWPFDocument(pack);</span><br><span class="line">            <span class="comment">// 处理段落</span></span><br><span class="line">            List&lt;XWPFParagraph&gt; paragraphList = doc.getParagraphs();</span><br><span class="line">            replaceFields.addAll(getFields(paragraphList));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理表格</span></span><br><span class="line">            Iterator&lt;XWPFTable&gt; it = doc.getTablesIterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                XWPFTable table = it.next();</span><br><span class="line">                List&lt;XWPFTableRow&gt; rows = table.getRows();</span><br><span class="line">                <span class="keyword">for</span> (XWPFTableRow row : rows) &#123;</span><br><span class="line">                    List&lt;XWPFTableCell&gt; cells = row.getTableCells();</span><br><span class="line">                    <span class="keyword">for</span> (XWPFTableCell cell : cells) &#123;</span><br><span class="line">                        List&lt;XWPFParagraph&gt; paragraphListTable = cell</span><br><span class="line">                                .getParagraphs();</span><br><span class="line">                        replaceFields.addAll(getFields(paragraphListTable));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> replaceFields;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取段落的需要替换的字段</span></span><br><span class="line"><span class="comment">     * @param paragraphList</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">String</span>&gt; getFields(List&lt;XWPFParagraph&gt; paragraphList) &#123;</span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; fieldList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">        <span class="keyword">if</span> (paragraphList != <span class="keyword">null</span> &amp;&amp; paragraphList.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (XWPFParagraph paragraph : paragraphList) &#123;</span><br><span class="line">                <span class="built_in">boolean</span> addReplace = <span class="keyword">false</span>;</span><br><span class="line">                List&lt;XWPFRun&gt; runs = paragraph.getRuns();</span><br><span class="line">                <span class="comment">//每个需要替换的key的run的位置的集合</span></span><br><span class="line">                List&lt;Integer&gt; replaceRuns = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="comment">//每个段落的所有的key run的集合</span></span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; perReplaceRunList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i&lt; runs.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    <span class="keyword">String</span> <span class="built_in">text</span> = runs.<span class="built_in">get</span>(i).getText(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(addReplace)&#123;</span><br><span class="line">                        replaceRuns.<span class="built_in">add</span>(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">text</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">text</span>.contains(<span class="string">"#"</span>))&#123;</span><br><span class="line">                        addReplace = <span class="keyword">true</span>;</span><br><span class="line">                        replaceRuns.<span class="built_in">add</span>(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">text</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">text</span>.contains(<span class="string">"&#125;"</span>))&#123;</span><br><span class="line">                        addReplace = <span class="keyword">false</span>;</span><br><span class="line">                        perReplaceRunList.<span class="built_in">add</span>(replaceRuns);</span><br><span class="line">                        replaceRuns = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;perReplaceRunList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                    List&lt;Integer&gt; runsList = perReplaceRunList.<span class="built_in">get</span>(i);</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"=========================="</span>);</span><br><span class="line">                    StringBuffer textSb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;j&lt;runsList.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                        System.out.<span class="built_in">println</span>(<span class="string">"============replace_runs"</span>+runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).getText(<span class="number">0</span>));</span><br><span class="line">                        textSb.<span class="built_in">append</span>(runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).getText(<span class="number">0</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">String</span> replaceStr = textSb.toString().<span class="built_in">trim</span>();</span><br><span class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"====replaceStr="</span> + replaceStr.substring(replaceStr.indexOf(<span class="string">"#"</span>)+<span class="number">2</span>,replaceStr.length()<span class="number">-1</span>));</span><br><span class="line"><span class="comment">//                  System.out.println(replaceStr.substring(2,replaceStr.length()-1));</span></span><br><span class="line">                    fieldList.<span class="built_in">add</span>(replaceStr.substring(replaceStr.indexOf(<span class="string">"#"</span>)+<span class="number">2</span>,replaceStr.length()<span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fieldList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度和空间复杂度详解</title>
    <url>/2017/02/18/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote>
<p>没有挤公交来上班过，就不知道生活的压力有多大。</p>
</blockquote>
<a id="more"></a>
<p>算法的时间复杂度和空间复杂度合称为算法的复杂度。<br><br>1.时间复杂度<br>（1）时间频度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。<br><br>（2）时间复杂度 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。<br><br>     时间频度不同，但时间复杂度可能相同。如：T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。<br><br>    按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。<br><br> （3）最坏时间复杂度和平均时间复杂度 　最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。<br><br>     在最坏情况下的时间复杂度为T(n)=0(n)，它表示对于任何输入实例,该算法的运行时间不可能大于0(n)。 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。<br><br>    指数阶0(2n)，显然，时间复杂度为指数阶0(2n)的算法效率极低，当n值稍大时就无法应用。<br><br>（4）求时间复杂度<br><br>【1】如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。<br></p>
<blockquote>
<p>x=91; y=100;<br>while(y&gt;0) if(x&gt;100) {x=x-10;y–;} else x++;</p>
</blockquote>
<p>解答： T(n)=O(1)，<br>这个程序看起来有点吓人，总共循环运行了1100次，但是我们看到n没有?<br>没。这段程序的运行是和n无关的，<br>就算它再循环一万年，我们也不管他，只是一个常数阶的函数</p>
<p>【2】当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。</p>
<blockquote>
<p>x=1;<br>for(i=1;i&lt;=n;i++)<br>        for(j=1;j&lt;=i;j++)<br>           for(k=1;k&lt;=j;k++)<br>               x++; 　</p>
</blockquote>
<p>该程序段中频度最大的语句是(5)，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析语句(5)的执行次数：  则该程序段的时间复杂度为T(n)=O(n3/6+低次项)=O(n3)</p>
<p>【3】算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。<br>在数值A[0..n-1]中查找给定值K的算法大致如下： </p>
<blockquote>
<p>i=n-1;<br>while(i&gt;=0&amp;&amp;(A[i]!=k))<br>      i–;<br>return i;      </p>
</blockquote>
<p>此算法中的语句(3)的频度不仅与问题规模n有关，还与输入实例中A的各元素取值及K的取值有关: ①若A中没有与K相等的元素，则语句(3)的频度f(n)=n； ②若A的最后一个元素等于K,则语句(3)的频度f(n)是常数0。<br>（5）时间复杂度评价性能<br>有两个算法A1和A2求解同一问题，时间复杂度分别是T1(n)=100n2，T2(n)=5n3。（1）当输入量n＜20时，有T1(n)＞T2(n)，后者花费的时间较少。（2）随着问题规模n的增大，两个算法的时间开销之比5n3/100n2=n/20亦随着增大。即当问题规模较大时，算法A1比算法A2要有效地多。它们的渐近时间复杂度O(n2)和O(n3)从宏观上评价了这两个算法在时间方面的质量。在算法分析时，往往对算法的时间复杂度和渐近时间复杂度不予区分，而经常是将渐近时间复杂度T(n)=O(f(n))简称为时间复杂度，其中的f(n)一般是算法中频度最大的语句频度。</p>
<p>2.空间复杂度<br>一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。　</p>
<p>（1）固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。<br><br>（2）可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。<br><br>一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))　　其中n为问题的规模，S(n)表示空间复杂度。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>2016年总结</title>
    <url>/2017/02/18/2016%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2>在2016这一年</h2>

<p>技术长进了。</p>
<p>Java:从SSH框架转到SSM，并且见识了基于Spring boot的威力，补了一下Java基础，正在接触算法。</p>
<p>Linux:记住了越来的越多的Linux命令，能独立维护并处理部分服务问题了。</p>
<p>Python:终于算是入门了，入门了却没看到出门在哪里。<br><a id="more"></a></p>
<p>JS&amp;HTML&amp;CSS3:这似乎不是我该关注的问题，能独立解决UI上的问题已经够了。</p>
<p>完成了至少三个项目，从pc端到web端到微信端到hybridApp。</p>
<p>项目是最好的导师，边学边做，边学边用，虽然不能用到最好，但这确实是很有效的学习途径，先实现再优化。</p>
<p>有毅力和活力，天生乐观派。认定了的事情一定要去完成，本职工作必须要做到尽职尽责。</p>
<p><strong>不足：</strong></p>
<p>发现的自己实力还是离自己的期望的差了很多。</p>
<p>纠结综合症。</p>
<p>强迫症。</p>
<h2>展望2017！</h2>

<p>有想法</p>
<p>想法一：继续补课</p>
<p>实习大半年后，发现在大学期间没有好好学习Java基础，也没有学的特别扎实！很多东西自己还不知道，需要补课！现在也算是个半吊子的Java程序员，虽然看了一遍的Java核心技术，但是还是要继续巩固，不同阶段相信有不同的理解，以后还会买更多的书回来，继续学习。</p>
<p>想法二：学习框架和算法</p>
<p>完成了基本的基础学习，开始着手框架，从Spring开始学起，了解框架底层原理，并且模仿造几个轮子。</p>
<p>大学只掌握了一些基础的数据结构知识，想要进大企业，算法也不能落下，不过这种东西不是可以快速见到成效的，所以静下心，慢慢来！</p>
<p>想法三：改</p>
<p>现在的写的代码用一个字形容——乱。</p>
<p>SVN没有发挥它该有的作用，SVN上的代码都不是最新的。</p>
<p>缺少一个完整的项目管理软件，BUG没有任何追踪记录，解决了？！没解决？！进度走到哪里了？！后续是关注还是下放到下一个版本解决？！项目的开发进度完成了吗？！</p>
<p>有计划</p>
<p>计划一:读书计划。</p>
<p>读完至少6本技术书籍，以下为计划书单：</p>
<p>1.《Java核心技术 卷一》 再读</p>
<p>2.《Java核心技术 卷二》 也可选择《java编程思想》</p>
<p>3.《Effective Java》</p>
<p>4.《深入理解Java虚拟机：JVM高级特性与最佳实践》</p>
<p>5.《大型网站技术架构 核心原理与案例分析》</p>
<p>6.《Java并发编程的艺术》</p>
<p>7.《算法第四版》</p>
<p>计划二：工作计划</p>
<p>1.2017年，继续坚持现有的工作状态。</p>
<p>2.加强自己的业务代码能力。</p>
<p>3.接触新项目（不同领域）。</p>
<p>4.自己做点外包。</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk1.8的HashMap和ConcurrentHashMap</title>
    <url>/2017/02/18/jdk1-8%E7%9A%84HashMap%E5%92%8CConcurrentHashMap/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本文针对jdk1.8的ConcurrentHashMap</p>
<h1>1.8的HashMap设计</h1>

<h2>1.1 整体概览</h2>

<p>HashMap采用的是<strong>数组+链表+红黑树</strong>的形式。</p>
<p>数组是可以扩容的，链表也是转化为红黑树的，这2种方式都可以承载更多的数据。</p>
<p>用户可以设置的参数：初始总容量默认16，默认的加载因子0.75</p>
<p>初始的数组个数默认是16（用户不能设置的）</p>
<p>容量X加载因子=阈值</p>
<p>一旦目前容量超过该阈值，则执行扩容操作。<a id="more"></a></p>
<p><strong>什么时候扩容？</strong></p>
<p><li>当前容量超过阈值</li></p>
<p><li>当链表中元素个数超过默认设定（8个），当数组的大小还未超过64的时候，此时进行数组的扩容，如果超过则将链表转化成红黑树</li></p>
<p><strong>什么时候链表转化为红黑树？（上面已经提到了）</strong></p>
<p><li>当数组大小已经超过64并且链表中的元素个数超过默认设定（8个）时，将链表转化为红黑树</li></p>
<p>目前形象的表示数组中的一个元素称为一个桶</p>
<h2>1.2 put过程</h2>

<p><li>根据key计算出hash值</li></p>
<p><li>hash值&amp;（数组长度-1）得到所在数组的index</li></p>
<pre><code>如果该index位置的Node元素不存在，则直接创建一个新的Node
如果该index位置的Node元素是TreeNode类型即红黑树类型了，则直接按照红黑树的插入方式进行插入
如果该index位置的Node元素是非TreeNode类型则，则按照链表的形式进行插入操作
</code></pre><p>链表插入操作完成后，判断是否超过阈值TREEIFY_THRESHOLD（默认是8），超过则要么数组扩容要么链表转化成红黑树</p>
<p><li>判断当前总容量是否超出阈值，如果超出则执行扩容</li></p>
<p>源码如下：</p>
<p><img src="http://img.blog.csdn.net/20170107004609227" alt="这里写图片描述"></p>
<p>下面来说说这个扩容的过程</p>
<h2>1.3 扩容过程</h2>

<p>按照2倍扩容的方式，那么就需要将之前的所有元素全部重新按照2倍桶的长度重新计算所在桶。这里为啥是2倍？</p>
<p>因为2倍的话，更加容易计算他们所在的桶，并且各自不会相互干扰。如原桶长度是4，现在桶长度是8，那么</p>
<pre><code>桶0中的元素会被分到桶0和桶4中
桶1中的元素会被分到桶1和桶5中
桶2中的元素会被分到桶2和桶6中
桶3中的元素会被分到桶3和桶7中
</code></pre><p>为啥是这样呢？</p>
<p>桶0中的元素的hash值后2位必然是00，这些hash值可以根据后3位000或者100分成2类数据。他们分别&amp;（8-1）即&amp;111,则后3位为000的在桶0中，后3位为100的必然在桶4中。其他同理，也就是说桶4和桶0重新瓜分了原来桶0中的元素。</p>
<p>如果换成其他倍数，那么瓜分就比较混乱了。</p>
<p>这样在瓜分这些数据的时候，只需要先把这些数据分类，如上述桶0中分成000和100 2类，然后直接构成新的链表，分类完毕后，直接将新的链表挂在对应的桶下即可，源码如下：</p>
<p><img src="http://img.blog.csdn.net/20170107004911697" alt="这里写图片描述"></p>
<p>上述 (e.hash &amp; oldCap) == 0 即可将原桶中的数据分成2类</p>
<p>上述是对于链表情况下的重新移动，而针对红黑树情况下：</p>
<p>则需要考虑分类之后是否还需要依然保持红黑树，如果个数少则直接使用链表即可。</p>
<h2>1.4 get过程</h2>

<p>get过程比较简单</p>
<p><li>根据key计算出hash值</li></p>
<p><li>hash值&amp;（数组长度-1）得到所在数组的index        </li></p>
<pre><code>如果要找的key就是上述数组index位置的元素，直接返回该元素的值
如果该数组index位置元素是TreeNode类型，则按照红黑树的查询方式来进行查找
如果该数组index位置元素非TreeNode类型，则按照链表的方式来进行遍历查询
</code></pre><p>源码如下：</p>
<p><img src="http://img.blog.csdn.net/20170107005249311" alt="这里写图片描述"></p>
<h1>1.7的ConcurrentHashMap设计</h1>

<p>ConcurrentHashMap是线程安全，通过分段锁的方式提高了并发度。分段是一开始就确定的了，后期不能再进行扩容的。</p>
<p>其中的段Segment继承了重入锁ReentrantLock，有了锁的功能，同时含有类似HashMap中的数组加链表结构（这里没有使用红黑树）</p>
<p>虽然Segment的个数是不能扩容的，但是单个Segment里面的数组是可以扩容的。</p>
<h2>2.1 整体概览</h2>

<p>ConcurrentHashMap有3个参数：</p>
<pre><code>initialCapacity：初始总容量，默认16
loadFactor：加载因子，默认0.75
concurrencyLevel：并发级别，默认16
</code></pre><p>然后我们需要知道的是：</p>
<p><li>segment的个数即ssize</li></p>
<p>取大于等于并发级别的最小的2的幂次。如concurrencyLevel=16，那么sszie=16,如concurrencyLevel=10，那么ssize=16</p>
<p><li>单个segment的初始容量cap</li></p>
<p>c=initialCapacity/ssize,并且可能需要+1。如15/7=2，那么c要取3，如16/8=2，那么c取2</p>
<p>c可能是一个任意值，那么同上述一样，cap取的值就是大于等于c的最下2的幂次。最小值要求是2</p>
<p><li>单个segment的阈值threshold</li></p>
<p>cap*loadFactor</p>
<p>所以默认情况下，segment的个数sszie=16,每个segment的初始容量cap=2，单个segment的阈值threshold=1</p>
<h2>2.2 put过程</h2>

<p><li>首先根据key计算出一个hash值，找到对应的Segment</li></p>
<p><li>调用Segment的lock方法，为后面的put操作加锁</li></p>
<p><li>根据key计算出hash值，找到Segment中数组中对应index的链表，并将该数据放置到该链表中</li></p>
<p><li>判断当前Segment包含元素的数量大于阈值，则Segment进行扩容</li></p>
<p>整体代码逻辑见如下源码：</p>
<p><img src="http://img.blog.csdn.net/20170107005617154" alt="这里写图片描述"></p>
<p>其中上述Segment的put过程源码如下：</p>
<p><img src="http://img.blog.csdn.net/20170107005641091" alt="这里写图片描述"></p>
<h2>2.3 扩容过程</h2>

<p>这个扩容是在Segment的锁的保护下进行扩容的，不需要关注并发问题。</p>
<p><img src="http://img.blog.csdn.net/20170107005716473" alt="这里写图片描述"></p>
<p>这里的重点就是：</p>
<p>首先找到一个lastRun，lastRun之后的元素和lastRun是在同一个桶中，所以后面的不需要进行变动。</p>
<p>然后对开始到lastRun部分的元素，重新计算下设置到newTable中，每次都是将当前元素作为newTable的首元素，之前老的链表作为该首元素的next部分。</p>
<h2>2.4 get过程</h2>

<p><li>根据key计算出对应的segment</li></p>
<p><li>再根据key计算出对应segment中数组的index</li></p>
<p><li>最终遍历上述index位置的链表，查找出对应的key的value</li></p>
<p>源码如下：</p>
<p><img src="http://img.blog.csdn.net/20170107005803333" alt="这里写图片描述"></p>
<h1>1.8的ConcurrentHashMap设计</h1>

<p>1.8的ConcurrentHashMap摒弃了1.7的segment设计，而是在1.8HashMap的基础上实现了线程安全的版本，即也是采用<strong>数组+链表+红黑树</strong>的形式。</p>
<p>数组可以扩容，链表可以转化为红黑树</p>
<h2>3.1 整体概览</h2>

<p>有一个重要的参数sizeCtl，代表数组的大小（但是还有其他取值及其含义，后面再详细说到）</p>
<p>用户可以设置一个初始容量initialCapacity给ConcurrentHashMap</p>
<p>sizeCtl=大于（1.5倍initialCapacity+1）的最小的2的幂次。</p>
<p>即initialCapacity=20，则sizeCtl=32,如initialCapacity=24，则sizeCtl=64。</p>
<p>初始化的时候，会按照sizeCtl的大小创建出对应大小的数组</p>
<h2>3.2 put过程</h2>

<p>源码如下所示：</p>
<p><img src="http://img.blog.csdn.net/20170107005911460" alt="这里写图片描述"></p>
<p><li>如果数组还未初始化，那么进行初始化，这里会通过一个CAS操作将sizeCtl设置为-1，设置成功的，可以进行初始化操作</li></p>
<p><li>根据key的hash值找到对应的桶，如果桶还不存在，那么通过一个CAS操作来设置桶的第一个元素，失败的继续执行下面的逻辑即向桶中插入或更新</li></p>
<p><li>如果找到的桶存在，但是桶中第一个元素的hash值是-1，说明此时该桶正在进行迁移操作，这一块会在下面的扩容中详细谈及。</li></p>
<p><li>如果找到的桶存在，那么要么是链表结构要么是红黑树结构，此时需要获取该桶的锁，在锁定的情况下执行链表或者红黑树的插入或更新</li></p>
<pre><code>如果桶中第一个元素的hash值大于0，说明是链表结构，则对链表插入或者更新
如果桶中的第一个元素类型是TreeBin，说明是红黑树结构，则按照红黑树的方式进行插入或者更新
</code></pre><p><li>在锁的保护下插入或者更新完毕后，如果是链表结构，需要判断链表中元素的数量是否超过8（默认），一旦超过就要考虑进行数组扩容或者是链表转红黑树</li></p>
<p><strong>下面就来重点看看这个扩容过程</strong></p>
<h2>3.3 扩容过程</h2>

<p>一旦链表中的元素个数超过了8个，那么可以执行数组扩容或者链表转为红黑树，这里依据的策略跟HashMap依据的策略是一致的。</p>
<p>当数组长度还未达到64个时，优先数组的扩容，否则选择链表转为红黑树。</p>
<p>源码如下所示：</p>
<p><img src="http://img.blog.csdn.net/20170107010024665" alt="这里写图片描述"></p>
<p>重点来看看这个扩容过程，即看下上述tryPresize方法，也可以看到上述是2倍扩容的方式</p>
<p><img src="http://img.blog.csdn.net/20170107010051374" alt="这里写图片描述"></p>
<p>第一个执行的线程会首先设置sizeCtl属性为一个负值，然后执行transfer(tab, null)，其他晚进来的线程会检查当前扩容是否已经完成，没完成则帮助进行扩容，完成了则直接退出。</p>
<p>该ConcurrentHashMap的扩容操作可以允许多个线程并发执行，那么就要处理好任务的分配工作。每个线程获取一部分桶的迁移任务，如果当前线程的任务完成，查看是否还有未迁移的桶，若有则继续领取任务执行，若没有则退出。在退出时需要检查是否还有其他线程在参与迁移工作，如果有则自己什么也不做直接退出，如果没有了则执行最终的收尾工作。</p>
<p><strong>问题1：当前线程如何感知其他线程也在参与迁移工作？</strong></p>
<p>靠sizeCtl的值，它初始值是一个负值=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，每当一个线程参与进来执行迁移工作，则该值进行CAS自增，该线程的任务执行完毕要退出时对该值进行CAS自减操作，所以当sizeCtl的值等于上述初值则说明了此时未有其他线程还在执行迁移工作，可以去执行收尾工作了。见如下代码</p>
<p><img src="http://img.blog.csdn.net/20170107010125312" alt="这里写图片描述"></p>
<p><strong>问题2：任务按照何规则进行分片？</strong></p>
<p><img src="http://img.blog.csdn.net/20170107010151062" alt="这里写图片描述"></p>
<p>上述stride即是每个分片的大小，目前有最低要求16，即每个分片至少需要16个桶。stride的计算依赖于CPU的核数，如果只有1个核，那么此时就不用分片，即stride=n。其他情况就是 (n &gt;&gt;&gt; 3) / NCPU。</p>
<p><strong>问题3：如何记录目前已经分出去的任务？</strong></p>
<p>ConcurrentHashMap含有一个属性transferIndex（初值为最后一个桶），表示从transferIndex开始到后面所有的桶的迁移任务已经被分配出去了。所以每次线程领取扩容任务，则需要对该属性进行CAS的减操作，即一般是transferIndex-stride。</p>
<p><strong>问题4：每个线程如何处理分到的部分桶的迁移工作</strong></p>
<p>第一个获取到分片的线程会创建一个新的数组，容量是之前的2倍。</p>
<p>遍历自己所分到的桶：</p>
<pre><code>桶中元素不存在，则通过CAS操作设置桶中第一个元素为ForwardingNode，其Hash值为MOVED（-1）,同时该元素含有新的数组引用

此时若其他线程进行put操作，发现第一个元素的hash值为-1则代表正在进行扩容操作（并且表明该桶已经完成扩容操作了，可以直接在新的数组中重新进行hash和插入操作），该线程就可以去参与进去，或者没有任务则不用参与，此时可以去直接操作新的数组了

桶中元素存在且hash值为-1，则说明该桶已经被处理了（本不会出现多个线程任务重叠的情况，这里主要是该线程在执行完所有的任务后会再次进行检查，再次核对）

桶中为链表或者红黑树结构，则需要获取桶锁，防止其他线程对该桶进行put操作，然后处理方式同HashMap的处理方式一样，对桶中元素分为2类，分别代表当前桶中和要迁移到新桶中的元素。设置完毕后代表桶迁移工作已经完成，旧数组中该桶可以设置成ForwardingNode了
</code></pre><p>下面来看下详细的代码：</p>
<p><img src="http://img.blog.csdn.net/20170107010302919" alt="这里写图片描述"></p>
<h2>3.4 get过程</h2>

<p><li>根据k计算出hash值，找到对应的数组index</li></p>
<p><li>如果该index位置无元素则直接返回null</li></p>
<p><li>如果该index位置有元素</li></p>
<pre><code>如果第一个元素的hash值小于0，则该节点可能为ForwardingNode或者红黑树节点TreeBin

如果是ForwardingNode（表示当前正在进行扩容），使用新的数组来进行查找

如果是红黑树节点TreeBin，使用红黑树的查找方式来进行查找

如果第一个元素的hash大于等于0，则为链表结构，依次遍历即可找到对应的元素
</code></pre><p>详细代码如下</p>
<p><img src="http://img.blog.csdn.net/20170107010356702" alt="这里写图片描述"></p>
<p>至此，ConcurrentHashMap主要的操作都粗略的介绍完毕了，其他一些操作靠各位自行去看了。</p>
<p>下面针对一些问题来进行解答</p>
<p></p><h1>问题分析<h1><p></p>
<h2>4.1 ConcurrentHashMap读为什么不需要锁？</h2>

<p>我们通常使用读写锁来保护对一堆数据的读写操作。读时加读锁，写时加写锁。在什么样的情况下可以不需要读锁呢？</p>
<p>如果对数据的读写是一个原子操作，那么此时是可以不需要读锁的。如ConcurrentHashMap对数据的读写，写操作是不需要分2次写的（没有中间状态），读操作也是不需要2次读取的。假如一个写操作需要分多次写，必然会有中间状态，如果读不加锁，那么可能就会读到中间状态，那就不对了。</p>
<p>假如ConcurrentHashMap提供put(key1,value1,key2,value2)，写入的时候必然会存在中间状态即key1写完成，但是key2还未写，此时如果读不加锁，那么就可能读到key1是新数据而key2是老数据的中间状态。</p>
<p>虽然ConcurrentHashMap的读不需要锁，但是需要保证能读到最新数据，所以必须加volatile。即数组的引用需要加volatile，同时一个Node节点中的val和next属性也必须要加volatile。</p>
<h2>4.2 ConcurrentHashMap是否可以在无锁的情况下进行迁移？</h2>

<p>目前1.8的ConcurrentHashMap迁移是在锁定旧桶的前提下进行迁移的，然而并没有去锁定新桶。那么就可能提出如下问题：</p>
<p><li>在某个桶的迁移过程中，别的线程想要对该桶进行put操作怎么办？</li></p>
<p>一旦某个桶在迁移过程中了，必然要获取该桶的锁，所以其他线程的put操作要被阻塞，一旦迁移完毕，该桶中第一个元素就会被设置成ForwardingNode节点，所以其他线程put时需要重新判断下桶中第一个元素是否被更改了，如果被改了重新获取重新执行逻辑，如下代码</p>
<p><img src="http://img.blog.csdn.net/20170107010526876" alt="这里写图片描述"></p>
<p><li>某个桶已经迁移完成（其他桶还未完成），别的线程想要对该桶进行put操作怎么办？</li></p>
<p>该线程会首先检查是否还有未分配的迁移任务，如果有则先去执行迁移任务，如果没有即全部任务已经分发出去了，那么此时该线程可以直接对新的桶进行插入操作（映射到的新桶必然已经完成了迁移，所以可以放心执行操作）</p>
<p>从上面看到我们在迁移的时候还是需要对旧桶锁定的，能否在无锁的情况下实现迁移？</p>
<p>可以参考参考这篇论文Split-Ordered Lists: Lock-Free Extensible Hash Tables</p>
<p>一旦扩容就涉及到迁移桶中元素的操作，将一个桶中的元素迁移到另一个桶中的操作不是一个原子操作，所以需要在锁的保护下进行迁移。如果扩容操作是移动桶的指向，那么就可以通过一个CAS操作来完成扩容操作。上述Split-Ordered Lists就是把所有元素按照一定的顺序进行排列。该list被分成一段一段的，每一段都代表某个桶中的所有元素。每个桶中都有一个指向第一个元素的指针，如下图结构所示：</p>
<p><img src="http://img.blog.csdn.net/20170107010603392" alt="这里写图片描述"></p>
<p>每一段其实也是分成2类的，如同前面所说的HashMap在扩容是分成2类的情况是一样的，此时Split-Ordered Lists在扩容时就只需要将新桶的指针指向这2类的分界点即可。</p>
<p>这一块之后再详细说明吧。</p>
<h2>4.3 ConcurrentHashMap曾经的弱一致性</h2>

<p>具体详见这篇针对老版本的ConcurrentHashMap的说明文章<a href="http://ifeve.com/concurrenthashmap-weakly-consistent/" target="_blank" rel="noopener">为什么ConcurrentHashMap是弱一致的</a></p>
<p>文中已经解释到：对数组的引用是volatile来修饰的，但是数组中的元素并不是。即读取数组的引用总是能读取到最新的值，但是读取数组中某一个元素的时候并不一定能读到最新的值。所以说是弱一致性的。</p>
<p>我觉得这个只需要稍微改动下就可以实现强一致性：</p>
<p><li>对于新加的key，通过写入到链表的末尾即可。因为一个元素的next属性是volatile的，可以保证写入后立马看的到，如下1.8的方式</li></p>
<p><li>或者对数组中元素的更新采用volatile写的方式，如下1.7的形式</li></p>
<p>但是现在1.7版本的ConcurrentHashMap对于数组中元素的写也是加了volatile的，如下代码</p>
<p><img src="http://img.blog.csdn.net/20170107010723393" alt="这里写图片描述"></p>
<p>1.8的方式就是：直接将新加入的元素写入next属性（含有volatile修饰）中而不是修改桶中的第一个元素。</p>
<p><img src="http://img.blog.csdn.net/20170107010744786" alt="这里写图片描述"></p>
<p>所以在1.7和1.8版本的ConcurrentHashMap中不再是弱一致性，写入的数据是可以立马本读到的。</p>
</h1></h1>]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>cordova中与inBrowser的通讯</title>
    <url>/2017/02/18/Browser%E7%9A%84%E9%80%9A%E8%AE%AF%E2%80%9D/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>为了把我的练琴记录仪改成多用户App，我需要做一个Weibo OAuth功能，因为练琴记录仪是Single Page App，我不愿意直接跳转到OAuth页面，那样会打断我的应用状态，于是我打算打开一个新窗口来完成OAuth。</p>
<p>这样一来，问题自然就转换为跨窗口通讯问题了。<br><a id="more"></a><br>窗口间通讯毫无疑问首选是 window.postMessage ，在cordova当中，原生 window.open 是不能用的，官方给的方案是使用 cordova-plugin-inappbrowser 插件所提供的 cordova.InAppBrowser.open(url, target, options) 来取代 window.open ，这两者基本上API差不多一致。</p>
<p>但是IAB插件所返回的对象并不是真正的 window ，它没有 postMessage 功能，并且在IAB所打开的页面中，也没有 window.opener ，于是只能另辟蹊径，找点不靠谱的挫方法来试试了。</p>
<p>OAuth基本流程</p>
<p>OAuth的基本流程这里就不赘述了，简单描述一下</p>
<p>Client需要授权，把自己（由服务商分配的） client_id ——也称 app key 以及在服务商注册的 redirect_url 拼在一起，让用户去访问服务商的 authorize 地址。<br>服务商会询问用户是否对这个 client_id 授权自己的账号，如果是，会跳转到 redirect_url?code=xxxxxx 。<br>应用的服务端接收到 redirect_url 的访问，用URL参数中的 code 和自己的 client_id 以及 app secret （相当于密码）去请求服务商的 access_token 接口，得到 access_token ，这个就是此应用对于这个用户账号的访问凭条。<br>redirect_url 页面根据应用自身需要把获得的 access_token 传回应用，完成授权过程。<br>使用 window.open 时的流程</p>
<p>客户端 var win = window.open(oauth_url) 。<br>完成OAuth授权，跳转到 redirect_url 。<br>在 redirect_url 上，把 access_token 用 window.opener.postMessage 的方式发给应用。<br>应用监听 win 的 onmessage 事件，一旦收到了 access_token 就完成授权，可以 win.close() 了。<br>然后我先把它写成了一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crossWindowViaBrowser</span>(<span class="params">url, target, opts, key, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> defer = <span class="built_in">Promise</span>.defer()</span><br><span class="line">  <span class="keyword">let</span> resolve = defer.resolve.bind(defer)</span><br><span class="line">  <span class="keyword">let</span> reject = defer.reject.bind(defer)</span><br><span class="line">  <span class="keyword">let</span> promise = defer.promise</span><br><span class="line">  <span class="keyword">let</span> timing</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> win = <span class="built_in">window</span>.open(url, target, utils.buildOpenWindowOptions(opts))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> onMessage = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = e.data || &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (data.type === <span class="string">'cross-window'</span> &amp;&amp; data.key === key) &#123;</span><br><span class="line">      parseResult(data.result, resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// close（貌似）没有可用的事件，`win.addEventListener('close')`没用的样子</span></span><br><span class="line">  <span class="comment">// `win.addEventListener`不好用的问题也可能是因为跨域，真是蛋疼啊</span></span><br><span class="line">  <span class="comment">// 于是轮询`closed`属性吧</span></span><br><span class="line">  <span class="keyword">let</span> pollingClosed = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (win.closed) &#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(ErrorType.CANCELED))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, POLLING_INTERVAL)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, onMessage, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超时`reject`</span></span><br><span class="line">  <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    timing = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(ErrorType.TIMEOUT))</span><br><span class="line">    &#125;, timeout)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// clean up</span></span><br><span class="line">    clearInterval(pollingClosed)</span><br><span class="line">    clearTimeout(timing)</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'message'</span>, onMessage)</span><br><span class="line">    win.close()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 cordova.InAppBrowser.open 时的流程</p>
<p>客户端 var win = cordova.InAppBrowser.open(oauth_url) 。<br>客户端开始对 win.executeScript 并进行轮询，其内容是尝试读取 localStorage.getItem(key) 。<br>redirect_url 页面把获取到的 access_token 写到 localStorage.setItem(key, access_token) 。<br>客户端一旦轮询到 localStorage.getItem(key) 有值，就可以得到 access_token ，然后就可以 localStorage.removeItem(key) ，完成授权， win.close() 。<br>然后我也单独写了一个函数</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crossWindowViaCordovaIAB</span><span class="params">(url, target, opts, key, timeout)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> defer = Promise.defer()</span><br><span class="line">  <span class="keyword">let</span> resolve = defer.resolve.bind(defer)</span><br><span class="line">  <span class="keyword">let</span> reject = defer.reject.bind(defer)</span><br><span class="line">  <span class="keyword">let</span> promise = defer.promise</span><br><span class="line">  <span class="keyword">let</span> timing</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> win = cordova.InAppBrowser.open(url, target, utils.buildOpenWindowOptions(opts))</span><br><span class="line">  <span class="comment">// cordova的InAppBrowser没有window.opener对象，只能使用轮询罢。。</span></span><br><span class="line">  <span class="keyword">const</span> code = `(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> key = <span class="string">'$&#123;key&#125;'</span></span><br><span class="line">    <span class="keyword">var</span> data = localStorage.getItem(key)</span><br><span class="line">    <span class="keyword">if</span> (data !== <span class="keyword">null</span>) &#123;</span><br><span class="line">      localStorage.removeItem(key)</span><br><span class="line">      <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">  &#125;)()`</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> poll = () =&gt; &#123;</span><br><span class="line">    win.executeScript(&#123; code: code &#125;, ret =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (ret[<span class="number">0</span>] === <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearInterval(pollingData)</span><br><span class="line">        parseResult(ret[<span class="number">0</span>], resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> pollingData = setInterval(poll, POLLING_INTERVAL)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 窗口关闭时`reject`</span></span><br><span class="line">  <span class="comment">// 正常流程上面`resolve`后才会`win.close()`，所以这里再`reject`也不会有影响</span></span><br><span class="line">  win.addEventListener(<span class="string">'exit'</span>, e =&gt; &#123;</span><br><span class="line">    reject(<span class="keyword">new</span> Error(ErrorType.CANCELED))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超时`reject`</span></span><br><span class="line">  <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    timing = setTimeout(() =&gt; &#123;</span><br><span class="line">      reject(<span class="keyword">new</span> Error(ErrorType.TIMEOUT))</span><br><span class="line">    &#125;, timeout)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  promise.<span class="keyword">finally</span>(() =&gt; &#123;</span><br><span class="line">    <span class="comment">// clean up</span></span><br><span class="line">    clearInterval(pollingData)</span><br><span class="line">    clearTimeout(timing)</span><br><span class="line">    win.close()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整合</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">crossWindow</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (window.cordova !== <span class="literal">undefined</span> &amp;&amp; cordova.InAppBrowser !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> crossWindowViaCordovaIAB(...args)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> crossWindowViaBrowser(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端</p>
<p>服务端的Redirect Page我是用PHP写的，涉及到上面的 cross-browser 的部分大概是：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">window.onload = function() </span><span class="xquery">&#123;</span></span><br><span class="line"><span class="xquery">  var<span class="built_in"> key</span> = &lt;?= json_encode(<span class="variable">$key</span>) ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xquery">  var result = &lt;?= json_encode(<span class="variable">$output</span>) ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="xquery">  localStorage.setItem<span class="built_in">(key</span>, result)</span></span><br><span class="line"><span class="xquery">  <span class="keyword">if</span> (<span class="keyword">window</span>.opener) &#123;</span></span><br><span class="line"><span class="xquery">    <span class="keyword">window</span>.opener.postMessage(&#123;</span></span><br><span class="line"><span class="xquery">      type: <span class="string">'cross-window'</span>,</span></span><br><span class="line"><span class="xquery">     <span class="built_in"> key</span>:<span class="built_in"> key</span>,</span></span><br><span class="line"><span class="xquery">      result: result</span></span><br><span class="line"><span class="xquery">    &#125;</span><span class="xml">, '*')</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>其中 $output 是对 access_token 接口 curl 得到的返回值，虽然微博给的返回值理论上说都是合法的JSON，但出于通用考虑我还是直接把它当字符串传递，让客户端自己在 parse 的时候进行 try/catch ，而且这样对 localStorage 也比较直接。</p>
]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title>高级for循环使用remove/add 问题</title>
    <url>/2017/02/18/%E9%AB%98%E7%BA%A7for%E5%BE%AA%E7%8E%AF%E4%BD%BF%E7%94%A8remove-add-%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天在高级for循环中用了一下remove发现报错，写了个demo测试看：<br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; a = <span class="literal">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line"> a.add(<span class="string">"1"</span>);</span><br><span class="line"> a.add(<span class="string">"2"</span>);</span><br><span class="line"> for (<span class="built_in">String</span> temp : a) &#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="string">"1"</span>.<span class="keyword">equals</span>(temp))&#123;</span><br><span class="line">         a.remove(temp);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>此时代码是没有问题的，运行正常；但是把”1”.equals(temp)换成”2”.equals(temp)之后，问题就出来了！</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.util</span>.ConcurrentModificationException</span><br><span class="line">	at java<span class="selector-class">.util</span>.ArrayList<span class="variable">$Itr</span>.checkForComodification(ArrayList<span class="selector-class">.java</span>:<span class="number">901</span>)</span><br><span class="line">	at java<span class="selector-class">.util</span>.ArrayList<span class="variable">$Itr</span>.next(ArrayList<span class="selector-class">.java</span>:<span class="number">851</span>)</span><br><span class="line">	at main<span class="selector-class">.exam</span><span class="selector-class">.ForeachTest</span>.main(ForeachTest<span class="selector-class">.java</span>:<span class="number">15</span>)</span><br><span class="line">	at sun<span class="selector-class">.reflect</span><span class="selector-class">.NativeMethodAccessorImpl</span>.invoke0(Native Method)</span><br><span class="line">	at sun<span class="selector-class">.reflect</span><span class="selector-class">.NativeMethodAccessorImpl</span>.invoke(NativeMethodAccessorImpl<span class="selector-class">.java</span>:<span class="number">62</span>)</span><br><span class="line">	at sun<span class="selector-class">.reflect</span><span class="selector-class">.DelegatingMethodAccessorImpl</span>.invoke(DelegatingMethodAccessorImpl<span class="selector-class">.java</span>:<span class="number">43</span>)</span><br><span class="line">	at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span>.invoke(Method<span class="selector-class">.java</span>:<span class="number">497</span>)</span><br><span class="line">	at com<span class="selector-class">.intellij</span><span class="selector-class">.rt</span><span class="selector-class">.execution</span><span class="selector-class">.application</span><span class="selector-class">.AppMain</span>.main(AppMain<span class="selector-class">.java</span>:<span class="number">147</span>)</span><br></pre></td></tr></table></figure>
<p> 报了这么一堆异常。</p>
<p>自己想了想画了个图：</p>
<p><img src="http://img.blog.csdn.net/20161229172604530" alt="这里写图片描述"></p>
<p>看图就明白了，<strong>该list每当删除一个元素时，集合的size方法的值都会减小1,这将直接导致集合中元素的索引重新排序</strong>，进一步说，就是剩余所有元素的索引值都减1，正如上图所示，而for循环语句的局部变量i仍然在递增，这将导致删除操作发生跳跃。从而导致上述代码还有删除的问题。</p>
<p>所以<font color="red">不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。</font>如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Iterator&lt;String&gt; </span><span class="keyword">it </span>= a.<span class="keyword">iterator(); </span><span class="meta">while</span>(<span class="keyword">it.hasNext())&#123;</span></span><br><span class="line"><span class="keyword">String </span>temp = <span class="keyword">it.next(); </span><span class="meta">if</span>(删除元素的条件)&#123;</span><br><span class="line">        <span class="keyword">it.remove();</span></span><br><span class="line"><span class="keyword"> </span>      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap面试题总结！</title>
    <url>/2017/02/18/HashMap%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%81/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><strong>HashTable和HashMap的区别有哪些？</strong></p>
<p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p>
<p>理解HashMap是Hashtable的轻量级实现（非线程安全的实现，hashtable是非轻量级，线程安全的），都实现Map接口，主要区别在于：<br><a id="more"></a><br>1、由于HashMap非线程安全，在只有一个线程访问的情况下，效率要高于HashTable</p>
<p>2、HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</p>
<p>3、HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey。因为contains方法容易让人引起误解。</p>
<p>4、Hashtable继承自陈旧的Dictionary类，而HashMap是Java1.2引进的Map 的一个实现。</p>
<p>5、Hashtable和HashMap扩容的方法不一样，HashTable中hash数组默认大小11，扩容方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数，增加为原来的2倍，没有加1。</p>
<p>6、两者通过hash值散列到hash表的算法不一样，HashTbale是古老的除留余数法，直接使用hashcode，而后者是强制容量为2的幂，重新根据hashcode计算hash值，在使用hash 位与 （hash表长度 – 1），也等价取膜，但更加高效，取得的位置更加分散，偶数，奇数保证了都会分散到。前者就不能保证。</p>
<p>7、另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</p>
<li>fail-fast和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。</li>

<li>结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</li>

<p><li>该条说白了就是在使用迭代器的过程中有其他线程在结构上修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</li><br><br><br><strong>为什么HashMap是线程不安全的，实际会如何体现？</strong></p>
<p>第一，如果多个线程同时使用put方法添加元素</p>
<p>假设正好存在两个put的key发生了碰撞(hash值一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。</p>
<p>第二，如果多个线程同时检测到元素个数超过数组大小*loadFactor</p>
<p>这样会发生多个线程同时对hash数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。且会引起死循环的错误。</p>
<p>具体细节上的原因，可以参考：<a href="http://ifeve.com/hashmap-infinite-loop/" target="_blank" rel="noopener">不正当使用HashMap导致cpu 100%的问题追究</a></p>
<p><br><br><strong>能否让HashMap实现线程安全，如何做？</strong></p>
<p>1、直接使用Hashtable，但是当一个线程访问HashTable的同步方法时，其他线程如果也要访问同步方法，会被阻塞住。举个例子，当一个线程使用put方法时，另一个线程不但不可以使用put方法，连get方法都不可以，效率很低，现在基本不会选择它了。</p>
<p>2、HashMap可以通过下面的语句进行同步：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Collections.synchronizeMap(hashMap)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>3、直接使用JDK 5 之后的 ConcurrentHashMap，如果使用Java 5或以上的话，请使用ConcurrentHashMap。</p>
<p><br><br><strong>Collections.synchronizeMap(hashMap);又是如何保证了HashMap线程安全？</strong></p>
<p>直接分析源码吧</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// synchronizedMap方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// SynchronizedMap类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> class SynchronizedMap&lt;K,V&gt;</span><br><span class="line">       implements Map&lt;K,V&gt;, Serializable &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1978198479659022715</span>L;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">Object</span>      mutex;        <span class="comment">// Object on which to synchronize</span></span><br><span class="line"> </span><br><span class="line">       SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">           <span class="keyword">this</span>.m = Objects.requireNonNull(m);</span><br><span class="line">           mutex = <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       SynchronizedMap(Map&lt;K,V&gt; m, <span class="keyword">Object</span> mutex) &#123;</span><br><span class="line">           <span class="keyword">this</span>.m = m;</span><br><span class="line">           <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">int</span> <span class="built_in">size</span>() &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.<span class="built_in">size</span>();&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">boolean</span> isEmpty() &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.isEmpty();&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">boolean</span> containsKey(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsKey(<span class="built_in">key</span>);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">boolean</span> containsValue(<span class="keyword">Object</span> value) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsValue(value);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.<span class="built_in">get</span>(<span class="built_in">key</span>);&#125;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(<span class="built_in">key</span>, value);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> V remove(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.remove(<span class="built_in">key</span>);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 省略其他方法</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从源码中看出 synchronizedMap()方法返回一个SynchronizedMap类的对象，而在SynchronizedMap类中使用了synchronized来保证对Map的操作是线程安全的，故效率其实也不高。</p>
<p><br><br><strong>为什么HashTable的默认大小和HashMap不一样？</strong></p>
<p>前面分析了，Hashtable 的扩容方法是乘2再+1，不是简单的乘2，故hashtable保证了容量永远是奇数，结合之前分析hashmap的重算hash值的逻辑，就明白了，因为在数据分布在等差数据集合(如偶数)上时，如果公差与桶容量有公约数 n，则至少有(n-1)/n 数量的桶是利用不到的，故之前的hashmap 会在取模（使用位与运算代替）哈希前先做一次哈希运算，调整hash值。这里hashtable比较古老，直接使用了除留余数法，那么就需要设置容量起码不是偶数（除（近似）质数求余的分散效果好）。而JDK开发者选了11。</p>
<font color="red">感觉针对Java的hashmap和hashtable面试，或者理解，到这里就可以了，具体就是多写代码实践。</font>]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈HashMap</title>
    <url>/2017/02/18/%E6%B5%85%E8%B0%88HashMap/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><strong>什么是Map?</strong></p>
<font color="#008080">Map用于保存具有key-value映射关系的数据</font><br><a id="more"></a><br>首先看图！<br><br><img src="http://img.blog.csdn.net/20161224234534698" alt="这里写图片描述"><br><br>可以看出Java 中有四种常见的Map实现——HashMap, TreeMap, Hashtable和LinkedHashMap：<br><br>·HashMap就是一张hash表，键和值都没有排序。<br><br>·TreeMap以红黑树结构为基础，键值可以设置按某种顺序排列。<br><br>·LinkedHashMap保存了插入时的顺序。<br><br>·Hashtable是同步的(而HashMap是不同步的)。所以如果在线程安全的环境下应该多使用HashMap，而不是Hashtable，因为Hashtable对同步有额外的开销。<br><br><br><strong>我们在这里简单的说说HashMap：</strong><br><br>(1)HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。<br><br>(2)HashMap是非线程安全的，只用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。<br><br>(3)HashMap 实现了Serializable接口，因此它支持序列化。<br><br>(4)HashMap还实现了Cloneable接口，故能被克隆。<br><br><br><br>先从<strong>HashMap的存储结构</strong>说起：<br><br><img src="http://img.blog.csdn.net/20161224235308725" alt="这里写图片描述"><br><br>蓝色部分即代表哈希表本身（其实是一个数组），数组的每个元素都是一个单链表的头节点，链表是用来解决hash地址冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中保存。<br><br><strong>HashMap的构造方法中有两个很重要的参数：</strong><font color="#008080">初始容量和加载因子</font>

<p>这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（默认为16），加载因子是哈希表当前key的数量和容量的比值，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表提前进行 resize 操作（即扩容）。如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），严重浪费。</p>
<p>JDK开发者规定的默认加载因子为0.75，因为这是一个比较理想的值。另外，无论指定初始容量为多少，构造方法都会将实际容量设为不小于指定容量的2的幂次方，且最大值不能超过2的30次方。</p>
<p><strong>我们来分析一下HashMap中用的最多的两个方法put和get的源码</strong></p>
<blockquote>
<p>get()：</p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取key对应的value</span></span><br><span class="line">    <span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        <span class="comment">// 获取key的hash值</span></span><br><span class="line">        <span class="built_in">int</span> hash = hash(<span class="built_in">key</span>.hashCode());</span><br><span class="line">        <span class="comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">Object</span> k;</span><br><span class="line">            <span class="comment">// 判断key是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || <span class="built_in">key</span>.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到则返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取“key为null”的元素的值，HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！</span></span><br><span class="line">    <span class="keyword">private</span> V getForNullKey() &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.<span class="built_in">key</span> == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。如果key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值对的key与目标key相等，有就返回对应的value，没有则返回null。</p>
<blockquote>
<p>put()：<br></p>
</blockquote>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">// 将<span class="built_in">“key</span>-<span class="keyword">value</span>”添加到HashMap中</span><br><span class="line">    public V put(K<span class="built_in"> key</span>, V <span class="keyword">value</span>) &#123;</span><br><span class="line">        // 若<span class="built_in">“key</span>为null”，则将该键值对添加到table[<span class="number">0</span>]中。</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">(key</span> == null)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(<span class="keyword">value</span>);</span><br><span class="line">        // 若<span class="built_in">“key</span>不为null”，则计算<span class="built_in">该key</span>的哈希值，然后将其添加到该哈希值对应的链表中。</span><br><span class="line">        int hash = hash<span class="built_in">(key</span>.hashCode());</span><br><span class="line">        int i = indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.<span class="keyword">next</span>) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            // 若“<span class="built_in">该key</span>”对应的键值对已经存在，则用新的<span class="keyword">value</span>取代旧的<span class="keyword">value</span>。然后退出！</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e<span class="built_in">.key</span>) ==<span class="built_in"> key</span> ||<span class="built_in"> key</span>.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">                e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">                e.recordAccess(this);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 若“<span class="built_in">该key</span>”对应的键值对不存在，则将<span class="built_in">“key</span>-<span class="keyword">value</span>”添加到table中</span><br><span class="line">        modCount++;</span><br><span class="line">        // <span class="built_in">将key</span>-<span class="keyword">value</span>添加到table[i]处</span><br><span class="line">        addEntry(hash,<span class="built_in"> key</span>, <span class="keyword">value</span>, i);</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果key为null，则将其添加到table[0]对应的链表中，如果key不为null，则同样先求出key的hash值，根据hash值得出在table中的索引，而后遍历对应的单链表，如果单链表中存在与目标key相等的键值对，则将新的value覆盖旧的value，且将旧的value返回，如果找不到与目标key相等的键值对，或者该单链表为空，则将该键值对插入到单链表的头结点位置（每次新插入的节点都是放在头结点的位置），该操作是有addEntry方法实现的，它的源码如下：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span>(<span class="params"><span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>, <span class="keyword">int</span> bucketIndex</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 保存“bucketIndex”位置的值到“e”中</span></span><br><span class="line">        Entry&lt;K, V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">// 设置“bucketIndex”位置的元素为“新Entry”，</span></span><br><span class="line">        <span class="comment">// 设置“e”为“新Entry的下一个节点”</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K, V&gt;(hash, key, <span class="keyword">value</span>, e);</span><br><span class="line">        <span class="comment">// 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小</span></span><br><span class="line">        <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意这里倒数第三行的构造方法，将key-value键值对赋给table[bucketIndex]，并将其next指向元素e，这便将key-value放到了头结点中，并将之前的头结点接在了它的后面。该方法也说明，每次put键值对的时候，总是将新的该键值对放在table[bucketIndex]处（即头结点处）。两外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阀值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。</p>
<font color="#008080"><strong>接下来重点来分析下求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列。</strong></font>

<blockquote>
<p>由hash值找到对应索引的方法如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length<span class="number">-1</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>因为容量初始还是设定都会转化为2的幂次。故可以使用高效的位与运算替代模运算。</p>
<blockquote>
<p>计算hash值的方法如下:</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">static</span> int hash(int h) &#123;</span><br><span class="line">           <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt; <span class="number">20</span>)<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">           <span class="attribute">return</span> h<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">7</span>)<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>JDK 的 HashMap 使用了一个 hash 方法对hash值使用位的操作，使hash值的计算效率很高。为什么这样做？主要是因为如果直接使用hashcode值，那么这是一个int值（8个16进制数，共32位），int值的范围正负21亿多，但是hash表没有那么长，一般比如初始16，自然散列地址需要对hash表长度取模运算，得到的余数才是地址下标。假设某个key的hashcode是0AAA0000，hash数组长默认16，如果不经过hash函数处理，该键值对会被存放在hash数组中下标为0处，因为0AAA0000 &amp; (16-1) = 0。过了一会儿又存储另外一个键值对，其key的hashcode是0BBB0000，得到数组下标依然是0，这就说明这是个实现得很差的hash算法，因为hashcode的1位全集中在前16位了，导致算出来的数组下标一直是0。<font color="red">于是明明key相差很大的键值对，却存放在了同一个链表里，导致以后查询起来比较慢（蜕化为了顺序查找）。故JDK的设计者使用hash函数的若干次的移位、异或操作，把hashcode的“1位”变得“松散”，非常巧妙。</font></p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 基本入门(至今为止见过最好的 nginx 入门文章，没有之一。)</title>
    <url>/2017/02/18/nginx-%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8-%E8%87%B3%E4%BB%8A%E4%B8%BA%E6%AD%A2%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84-nginx-%E5%85%A5%E9%97%A8%E6%96%87%E7%AB%A0%EF%BC%8C%E6%B2%A1%E6%9C%89%E4%B9%8B%E4%B8%80%E3%80%82/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote>
<p>本文转自<a href="http://www.jianshu.com/p/93ac21161ac6" target="_blank" rel="noopener">StuQ</a> </p>
</blockquote>
<p><br><br>这篇教程简单介绍了 nginx 并且讲解了一些 nginx 可以解决的简单任务。这里，我们假设 nginx 已经安装在读者的机器上。如果没有，可以看一下如何安装 nginx。这篇教程主要讲解的是如果启用和停止 ngixn，和重新加载配置，描述配置文件的基本结构和怎样搭建一个 nginx 静态辅助器，怎样配置 nginx 作为一个代理服务器来。 nginx 有一个主进程和其他子进程。主进程的主要工作是加载和执行配置文件，并且驻留子进程。子进程用来作为实际的请求处理。nginx 采取基于事件的模型和 OS 依赖的机制，在多个子进程之间高效的分配请求。子进程的个数会直接写在配置文件中并且，对于给定的配置可以是固定的，或者根据可用的 CPU 核数自动的进行调整（参考子进程）。 nginx 和它模块的工作方式是在配置文件中写好的。默认情况下，这个配置文件通常命名为 nginx.conf 并且会放置在 /usr/local/nginx/conf，/etc/nginx，或者 /usr/local/etc/nginx。<br><a id="more"></a><br>启用，停止和重载配置</p>
<p>运行可执行文件就可以开启 nginx，比如:</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -c 为 nginx 的配置文件</span></span><br><span class="line"></span><br><span class="line">nginx -c/usr/<span class="keyword">local</span>/nginx/<span class="keyword">conf</span>/nginx.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>
<p>如果，nginx 已经开启，那么它就可以通过使用 -s 参数的可执行命令控制。使用下列格式：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">nginx -s <span class="keyword">signal</span><span class="string"></span></span><br></pre></td></tr></table></figure>
<p>signal 可以为下列命令之一：</p>
<p>stop — 直接关闭 nginx</p>
<p>quit — 会在处理完当前正在的请求后退出，也叫优雅关闭</p>
<p>reload — 重新加载配置文件，相当于重启</p>
<p>reopen — 重新打开日志文件 比如，等待当前子进程处理完正在执行的请求后，结束 nginx 进程，可以使用下列命令：</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line">nginx -<span class="keyword">s</span> <span class="keyword">quit</span></span><br></pre></td></tr></table></figure>
<p>执行该命令的用户需要和启动的 nginx 的用户一致。 如果重载配置文件的命令没有传递给 nginx 或者 nginx 没有重启，那么配置文件的改动是不会被使用的。重载配置文件的命令可以使用：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nginx -s reload</span></span><br></pre></td></tr></table></figure>
<p>一旦主进程接收到重载配置文件的命令后，它会先检查配置文件语法的合法性，如果没有错误，则会重新加载配置文件。如果成功，则主进程会重新创建一个子进程并且发送关闭请求给以前的子进程。如果没有成功，主进程会回滚改动并且继续使用以前的配置。老的子进程在接受关闭的命令后，会停止接受新的请求并且继续处理当前的请求，直到处理完毕。之后，该子进程就直接退出了。 在 Unix 工具的帮助下，比如使用 kill 工具，该信号会被发送给 nginx 进程。在这种情况下，信号会被直接发送给带有进程 ID 的进程。nginx 的主进程的进程 ID 是写死在 nginx.pid 文件中的。该文件通常放在 /usr/local/nginx/logs 或者 /var/run 目录下。比如，如果主进程的 ID 是 1628，为了发送 QUIT 信号来使 nginx 优雅退出，可以执行：kill -s QUIT 1628</p>
<p>为了得到所有正在运行的 nginx 进程，我们可能会使用到 ps 工具，比如，像下列的方式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">ps</span> <span class="string">-ax</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">nginx</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">结果为：（下面是单核</span> <span class="string">CPU</span> <span class="string">的情况）</span> </span><br><span class="line"></span><br><span class="line"><span class="number">516</span> <span class="string">pts/0</span>    <span class="string">D+</span>    <span class="number">0</span><span class="string">:00</span> <span class="string">grep</span> <span class="string">--color=auto</span> <span class="string">nginx</span> </span><br><span class="line"></span><br><span class="line"><span class="number">1156</span> <span class="string">?</span>        <span class="attr">S      1:22 nginx:</span> <span class="string">worker</span> <span class="string">process</span></span><br><span class="line"></span><br><span class="line"><span class="number">27999</span> <span class="string">?</span>        <span class="attr">Ss    0:00 nginx:</span> <span class="string">master</span> <span class="string">process</span> <span class="string">./nginx</span></span><br></pre></td></tr></table></figure>
<p>更多关于发送信号给 nginx，可以参考<a href="https://link.zhihu.com/?target=http://nginx.org/en/docs/ngx_core_module.html#worker_processes" target="_blank" rel="noopener">nginx 控制</a>。<br><br><br><strong><h2>配置文件结构</h2></strong></p>
<p>nginx 是由一些模块组成，我们一般在配置文件中使用一些具体的指令来控制它们。指令被分为简单指令和块级命令。一个简单的指令是由名字和参数组成，中间用空格分开，并以分号结尾。例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 简单指令</span><br><span class="line"></span><br><span class="line">root <span class="regexp">/data/</span>www;</span><br></pre></td></tr></table></figure>
<p>块级指令和简单指令一样有着类似的结构，但是末尾不是分号而是用 {和} 大括号包裹的额外指令集。如果一个块级指令的大括号里有其他指令，则它被叫做一个上下文（比如：<a href="http://nginx.org/en/docs/ngx_core_module.html#events" target="_blank" rel="noopener">events</a>，<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#httph" target="_blank" rel="noopener">Module ngx_http_core_module</a>，<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#servers" target="_blank" rel="noopener">server</a>，和<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location" target="_blank" rel="noopener">location</a>）。 在配置文件中，没有放在任何上下文中的指令都是处在主上下文中。events 和 http 的指令是放在主上下文中，server 放在 http 中, location 放在 server 中。</p>
<p>以 # 开头的行，会被当做注释。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># this is a comment</span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">4096</span>;  <span class="comment">## Default: 1024</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;    </span><br><span class="line"></span><br><span class="line">        <span class="section">server</span> &#123;          </span><br><span class="line"></span><br><span class="line">                <span class="attribute">listen</span>      <span class="number">80</span>;        </span><br><span class="line"></span><br><span class="line">                <span class="attribute">server_name</span>  domain1.com www.domain1.com;        </span><br><span class="line"></span><br><span class="line">                <span class="attribute">access_log</span>  logs/domain1.access.log  main;        </span><br><span class="line"></span><br><span class="line">                <span class="attribute">root</span>        html;        </span><br><span class="line"></span><br><span class="line">                <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;          </span><br><span class="line"></span><br><span class="line">                    <span class="attribute">fastcgi_pass</span>  <span class="number">127.0.0.1:1025</span>;        </span><br><span class="line"></span><br><span class="line">                &#125;    </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br><strong><h2>静态服务器</h2></strong></p>
<p>一个重要的网络服务器的任务是处理文件（比如图片或者静态 HTML 文件）。这里，你会实践一个例子，文件会从不同的目录中映射（取决于请求）：/data/www（放置 HTML 文件）和 /data/images（放置图片）。这需要配置一下文件，将带有两个 location 的指令的 server 的块级命令放在 server 指令中。 首先，创建一个 /data/www 目录，然后放置一个事先写好内容的 index.html 文件。接着，创建一个 /data/images 目录，然后放置一些图片。 下一步，打开配置文件。默认的配置文件已经包含了一些关于 server 指令的样式，大多数情况下直接把他们给注释掉。现在，注释掉其他的区块，然后写一个新的 server 区块：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">http &#123;    </span><br><span class="line"></span><br><span class="line">       <span class="built_in"> server </span>&#123;    </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，该配置文件可能会包含多个 server 指令。这些 server 指令监听不同的端口和服务器名。一旦 nginx 决定哪个服务进程处理请求，它会根据在 server 块级指令中定义好的 location 指令的参数，来匹配请求头中指定的 URI。 将下列 location 指令添加到 server 指令中：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">/ &#123;    </span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">        root</span> /data/www;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该 location 指令相对于请求中的 URI 执行了 “/” 的前缀。为了匹配请求，URI 会被添加到 root 命令指定的路径后，即 /data/www，得到本地文件系统中请求文件的路径。如果，有几个 location 匹配到，那么 nginx 会选择最长的前缀。上面的 location 提供了长度为 1 的前缀，所以，仅当其他的 location 匹配失败后，该指令才会使用。 接着，添加第二个 location 区块：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">/images</span>/ &#123;    </span><br><span class="line"></span><br><span class="line">        root /data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它会匹配到以 /images/ 开头的请求（location / 也会匹配到该请求，只是前缀更短） server 块级命令的配置结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">server &#123;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">location</span> <span class="title">/ &#123;       </span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">                root</span> /data/www;   </span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">location</span> <span class="title">/images</span>/ &#123;       </span><br><span class="line"></span><br><span class="line">                root /data;   </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这已经是一个可用的服务器配置，它监听标准的 80 端口并且可以在本地上通过 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> 访问。对于 URI 以 /images/ 开头的请求，服务器会从 /data/images 目录中，返回对应的文件。例如，nginx 会返回 /data/images/example.png 文件，当接收到 <a href="http://localhost/images/example.png" target="_blank" rel="noopener">http://localhost/images/example.png</a> 的请求响应时。如果该文件不存在，nginx 会返回一个 404 错误的响应。没有以 /images/ 开头的 URI 的请求，将会直接映射到 /data/www 目录中。比如，响应 <a href="http://localhost/some/example.html" target="_blank" rel="noopener">http://localhost/some/example.html</a> 的请求，nginx 会发送 /data/www/some/example.html 文件。 为了使用新的配置文件，如果还没开启 nginx 需要先开启，然后将重载信号发送给 nginx 的主进程，通过执行：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">nginx -s reload</span></span><br></pre></td></tr></table></figure>
<p>如果你发现有些地方出了问题，你可以在 /usr/local/nginx/logs 或者 /var/log/nginx 目录下的 access.log 和 error.log 文件中，找到原因。<br><br><br><strong><h2>搭建一个简易的代理服务</h2></strong></p>
<p>nginx 常常用来作为代理服务器，这代表着服务器接收请求，然后将它们传递给被代理服务器，得到请求的响应，再将它们发送给客户端。 我们将配置一个基本的代理服务器，它会处理本地图片文件的请求并返回其他的请求给被代理的服务器。在这个例子中，两个服务器都会定义在一个 nginx 实例中。 首先，通过在 nginx 配置文件中添加另一个 server 区块，来定义一个被代理的服务器，像下面的配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;   </span><br><span class="line"></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;   </span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span> /data/up1;   </span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;   </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是一个简单的服务器，它监听在 8080 端口（之前，listen 并没被定义，是因为默认监听的 80 端口）并且会映射所有的请求给 本地文件目录 /data/up1。创建该目录，然后添加 index.html 文件。注意，root 指令是放在 server 上下文中。当响应请求的 location 区块中，没有自己的 root 指令，上述的 root 指令才会被使用。 接着，使用前面章节中的 server 配置，然后将它改为一个代理服务配置。在第一个 location 区块中，放置已经添加被代理服务器的协议，名字和端口等参数的proxy_pass指令（在这里，就是 <a href="http://localhost:8080）" target="_blank" rel="noopener">http://localhost:8080）</a>:</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">server &#123;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">location</span> <span class="title">/ &#123;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">                proxy_pass</span> http://localhost:<span class="number">8080</span>;   </span><br><span class="line"></span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">location</span> <span class="title">/images</span>/ &#123;</span><br><span class="line"></span><br><span class="line">               root /data;   </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将修改第二个 location 区块，使他返回一些典型后缀的图片文件请求，现在它只会映射带有 /images/ 前缀的请求到 /data/images 目录下。修改后的 location 指令如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">location</span> <span class="title">~ \.(gif</span>|jpg|png)$&#123;</span><br><span class="line"></span><br><span class="line">        root/data/images;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该参数是一个正则表达式，它会匹配所有以 .gif，.jpg 或者 .png 结尾的 URIs。一个正则表达式需要以 ~ 开头。匹配到的请求会被映射到 /data/images 目录下。 当 nginx 在选择 location 去响应一个请求时，它会先检测带有前缀的 location 指令，记住先是检测带有最长前缀的 location，然后检测正则表达式。如果有一个正则的匹配的规则，nginx 会选择该 location，否则，会选择之前缓存的规则。 最终，一个代理服务器的配置结果如下：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">server&#123;</span><br><span class="line"></span><br><span class="line">        location<span class="class">/&#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="symbol">                proxy_passhttp:</span><span class="comment">//localhost:8080/;</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        location~\.(gif|jpg|png)$&#123;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">                root<span class="meta-keyword">/data/</span>images;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p>该服务器会选择以 .gif，.jpg，或者 .png 结束的请求并且映射到 /data/images 目录（通过添加 URI 给 root 指令的参数），接着将其他所有的请求映射到上述被代理的服务器。 为了使用新的配置，像前几个章节描述的一样，需要向 nginx 发送重载信号。 这还有很多<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">其他的指令</a>，可以用于进一步配置代理连接。</p>
]]></content>
      <categories>
        <category>WebWebWeb</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型总结</title>
    <url>/2017/02/18/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><strong>一. 我们为什么需要泛型？</strong></p>
<p>首先，我们看下下面这段简短的代码:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        List <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="string">"justdoit"</span>);</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="string">"core"</span>);</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">String</span> name = (<span class="keyword">String</span>) <span class="built_in">list</span>.<span class="built_in">get</span>(i); <span class="comment">// 1</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"name:"</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>我们定义一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//1中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。</p>
<p> <strong>在如上的编码过程中，我们发现主要存在两个问题：</strong></p>
<p>1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。</p>
<p>2.因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。</p>
<font color="#008080"><strong>那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。</strong></font>

<p><strong>二.什么是泛型？</strong></p>
<p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>这样说有点复杂，我们来看下上面那个例子采用泛型的写法:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest_2</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        List list = new ArrayList();</span></span><br><span class="line"><span class="comment">        list.add("justdoit");</span></span><br><span class="line"><span class="comment">        list.add("core");</span></span><br><span class="line"><span class="comment">        list.add(100);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="string">"justdoit"</span>);</span><br><span class="line">        <span class="built_in">list</span>.add(<span class="string">"core"</span>);</span><br><span class="line">        <span class="comment">//list.add(100);   // 1  提示编译错误</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">String</span> name = <span class="built_in">list</span>.<span class="built_in">get</span>(i); <span class="comment">// 2</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"name:"</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List&lt; String&gt;，直接限定了list集合中只能含有String类型的元素，从而在//2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。</p>
<p>结合上面的泛型定义，我们知道在List&lt; String&gt;中，String是类型实参，也就是说，相应的List接口中肯定含有类型形参。且get()方法的返回结果也直接是此形参类型（也就是对应的传入的类型实参）。下面就来看看List接口的的具体定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Object[] toArray();</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在List接口中采用泛型化定义之后，&lt; E&gt;中的E表示类型形参，可以接收具体的类型实参，并且此接口定义中，凡是出现E的地方均表示相同的接受自外部的类型实参。</p>
<p>自然的，ArrayList作为List接口的实现类，其定义形式是:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;E&gt; <span class="title">extends</span> <span class="title">AbstractList</span>&lt;E&gt; </span></span><br><span class="line"><span class="class">        <span class="title">implements</span> <span class="title">List</span>&lt;E&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(<span class="built_in">size</span> + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[<span class="built_in">size</span>++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">return</span> ArrayList.<span class="keyword">this</span>.elementData(offset + index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...省略掉其他具体的定义过程</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，我们可以从源代码角度明白了为什么//1处加入Integer类型对象编译错误，且//2处get()到的类型直接就是String类型了。</p>
<p><strong>三.自定义泛型接口、泛型类和泛型方法</strong></p>
<p>从上面的内容中，大家已经明白了泛型的具体运作过程。也知道了接口、类和方法也都可以使用泛型去定义，以及相应的使用。是的，在具体使用时，可以分为泛型接口、泛型类和泛型方法。</p>
<p>自定义泛型接口、泛型类和泛型方法与上述Java源码中的List、ArrayList类似。如下，我们看一个最简单的泛型类和方法定义：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest_3</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Box&lt;<span class="keyword">String</span>&gt; name = <span class="keyword">new</span> Box&lt;<span class="keyword">String</span>&gt;(<span class="string">"core"</span>);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"name:"</span> + name.getData());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;T&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest_4</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Box&lt;<span class="keyword">String</span>&gt; name = <span class="keyword">new</span> Box&lt;<span class="keyword">String</span>&gt;(<span class="string">"core"</span>);</span><br><span class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"name class:"</span> + name.getClass());      <span class="comment">// CoreJava.day_5.Box</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"age class:"</span> + age.getClass());        <span class="comment">// CoreJava.day_5.Box</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(name.getClass() == age.getClass());    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。</p>
<p>究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p>
<font color="#008080"><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></font>


<p><strong>四.类型通配符</strong></p>
<p>接着上面的结论，我们知道，Box&lt; Number&gt;和Box&lt; Integer&gt;实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于Box&lt; Number&gt;和Box&lt; Integer&gt;是否可以看成具有父子关系的泛型类型呢？</p>
<p>为了弄清这个问题，我们继续看下下面这个例子:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest_6</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Box&lt;Number&gt; name = <span class="keyword">new</span> Box&lt;Number&gt;(<span class="number">99</span>);</span><br><span class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</span><br><span class="line"></span><br><span class="line">        getData(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//The method getData(Box&lt;Number&gt;) in the type GenericTest is</span></span><br><span class="line">        <span class="comment">//not applicable for the arguments (Box&lt;Integer&gt;)</span></span><br><span class="line">        getData(age);   <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(Box&lt;Number&gt; data)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"data :"</span> + data.getData());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，在代码//1处出现了错误提示信息：The method getData(Box&lt; Number&gt;) in the t ype GenericTest is not applicable for the arguments (Box&lt; Integer&gt;)。显然，通过提示信息，我们知道Box&lt; Number&gt;在逻辑上不能视为Box&lt; Integer&gt;的父类。那么，原因是什么呢？</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest_5</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Box&lt;Integer&gt; a = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</span><br><span class="line">        Box&lt;Number&gt; b = a;  <span class="comment">// 1</span></span><br><span class="line">        Box&lt;Float&gt; f = <span class="keyword">new</span> Box&lt;Float&gt;(<span class="number">3.14f</span>);</span><br><span class="line">        b.setData(f);        <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(Box&lt;Number&gt; data)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"data :"</span> + data.getData());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;T&gt; &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        setData(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，显然//1和//2处肯定会出现错误提示的。在此我们可以使用反证法来进行说明。</p>
<p>假设Box&lt; Number&gt;在逻辑上可以视为Box&lt; Integer&gt;的父类，那么//1和//2处将不会有错误提示了，那么问题就出来了，通过getData()方法取出数据时到底是什么类型呢？Integer? Float? 还是Number？且由于在编程过程中的顺序不可控性，导致在必要的时候必须要进行类型判断，且进行强制类型转换。显然，这与泛型的理念矛盾，因此，<font color="#008080"><strong>在逻辑上Box&lt; Number&gt;不能视为Box&lt; Integer&gt;的父类。</strong></font></p>
<p>好，那我们回过头来继续看“类型通配符”中的第一个例子，我们知道其具体的错误提示的深层次原因了。那么如何解决呢？总不能再定义一个新的函数吧。这和Java中的多态理念显然是违背的，<font color="#008080"><strong>因此，我们需要一个在逻辑上可以用来表示同时是Box&lt; Integer&gt;和Box&lt; Number&gt;的父类的一个引用类型，由此，类型通配符应运而生。</strong></font></p>
<p>类型通配符一般是使用 ? 代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且Box&lt;?&gt;在逻辑上是Box&lt; Integer&gt;、Box&lt; Number&gt;…等所有Box&lt;具体类型实参&gt;的父类。由此，我们依然可以定义泛型方法，来完成此类需求。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest_7</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Box&lt;<span class="keyword">String</span>&gt; name = <span class="keyword">new</span> Box&lt;<span class="keyword">String</span>&gt;(<span class="string">"core"</span>);</span><br><span class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</span><br><span class="line">        Box&lt;Number&gt; number = <span class="keyword">new</span> Box&lt;Number&gt;(<span class="number">314</span>);</span><br><span class="line"></span><br><span class="line">        getData(name);</span><br><span class="line">        getData(age);</span><br><span class="line">        getData(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(Box&lt;?&gt; data)</span> </span>&#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"data :"</span> + data.getData());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时候，<font color="#008080"><strong>我们还可能听到类型通配符上限和类型通配符下限</strong>。具体有是怎么样的呢？</font></p>
<p>在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> GenericTest_8 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Box&lt;<span class="built_in">String</span>&gt; name = <span class="keyword">new</span> Box&lt;<span class="built_in">String</span>&gt;(<span class="string">"core"</span>);</span><br><span class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</span><br><span class="line">        Box&lt;<span class="built_in">Number</span>&gt; <span class="built_in">number</span> = <span class="keyword">new</span> Box&lt;<span class="built_in">Number</span>&gt;(<span class="number">314</span>);</span><br><span class="line"></span><br><span class="line">        getData(name);</span><br><span class="line">        getData(age);</span><br><span class="line">        getData(<span class="built_in">number</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getUpperNumberData(name); // 1</span></span><br><span class="line">        getUpperNumberData(age);    <span class="comment">// 2</span></span><br><span class="line">        getUpperNumberData(<span class="built_in">number</span>); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> getData(Box&lt;?&gt; data) &#123;</span><br><span class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> getUpperNumberData(Box&lt;? <span class="keyword">extends</span> <span class="built_in">Number</span>&gt; data) &#123;</span><br><span class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，显然，在代码//1处调用将出现错误提示，而//2 //3处调用正常。</p>
<font color="#008080"><strong>类型通配符上限通过形如Box&lt; ? extends Number&gt;形式定义，相对应的，类型通配符下限为Box&lt; ? super Number&gt;形式，其含义与类型通配符上限正好相反</strong>，</font>在此不作过多阐述了。<br><br><br><br><strong>五.话外篇</strong><br><br>本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。并且还要注意的一点是，Java中没有所谓的泛型数组一说。<br><br><font color="red"><strong>对于泛型，最主要的还是需要理解其背后的思想和目的。</strong></font>





]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 最佳技巧</title>
    <url>/2017/02/18/Java-8-%E6%9C%80%E4%BD%B3%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote>
<p>翻译文章<br>转自<a href="https://muyinchen.github.io/2016/12/13/Java%208%20%E6%9C%80%E4%BD%B3%E6%8A%80%E5%B7%A7/#more" target="_blank" rel="noopener">一叶知秋</a></p>
</blockquote>
<p><br><br>在过去的几年中，我一直使用Java 8 进行了很多的编码工作，用于开发 <a href="http://trishagee.github.io/presentation/java8_in_anger/" target="_blank" rel="noopener">新应用</a> 和 <a href="http://trishagee.github.io/presentation/refactoring_to_java_8/" target="_blank" rel="noopener">迁移遗留应用</a> ，我觉得是时候写一些有用的”最佳实践”。我个人不喜欢”最佳实践”这个术语，因为它意味着“一刀切”的解决方案，当然编码工作是不会这样的–这是因为我们开发人员会想出适合我们的方案。但我发现我对Java8特别的喜欢，它让我的生活更轻松一点，所以我想就此话题展开讨论。<br><a id="more"></a><br>Optional</p>
<p>Optional是一个被严重低估的功能, 它消除了很多困扰着我们的 NullPointerExceptions。它在代码边界（包括你调用和提供 API）处理上特别有用，因为它允许你和你调用的代码说明程序运行的期望结果。</p>
<p>然而，如果没有必要的思考和设计，那么就会导致一个小变化而影响大量的类，也会导致可读性变差。这里有一些关于如何高效使用Optional的提示。<br><br><br>Optional <strong>应该只用于返回类型</strong></p>
<p>…不能是参数和属性. 阅读 <a href="http://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html" target="_blank" rel="noopener">这个博客</a> 了解怎样使用 Optional。 幸运的是, IntelliJ IDEA 在打开 <a href="https://www.jetbrains.com/help/idea/2016.2/code-inspection.html" target="_blank" rel="noopener">inspection</a> 功能的情况下会检查你是否遵循了这些建议。</p>
<p><img src="http://img.blog.csdn.net/20161214162906891" alt></p>
<p>可选值应该在使用的地方进行处理.IntelliJ IDEA 的建议可以防止你不恰当的使用Optional, 所以你应该立即处理你发现的不恰当使用Optional。(根据自己的理解翻译)</p>
<p><img src="http://img.blog.csdn.net/20161214163003908" alt="这里写图片描述"></p>
<p><br><br><strong>你不应该简单的调用</strong> get()<br>Optional的目的是为了表示此值有可能为空，且让你有能力来应付这种情况。因此，在使用值之前进行检查是非常重要的。在某些情况下简单的调用get()而没有先使用isPresent()进行检查是一样会导致空指针问题。幸运的是，IntelliJ IDEA 任然会检查出这个问题并警告你。</p>
<p><img src="http://img.blog.csdn.net/20161214163211900" alt="这里写图片描述"><br><br><br><strong>有可能是一个更优雅的方式</strong></p>
<p>isPresent() 与  get() 结合 使用的技巧 …</p>
<p><img src="http://img.blog.csdn.net/20161214163327369" alt="这里写图片描述"></p>
<p>…但还有更优雅的解决方案。你可以使用 orElse方法来使得当它为null时给出一个代替的值。</p>
<p><img src="http://img.blog.csdn.net/20161214163422572" alt="这里写图片描述"></p>
<p>…或者使用 orElseGet方法来处理上述相同情况。这个例子和上面的看起来好像一样，但本例是可以调用 supplier 接口的 实现 ,，因此如果它是一个高开销的方法，可以使用 lambda 表达式来获得更好的性能。</p>
<p><img src="http://img.blog.csdn.net/20161214163525758" alt="这里写图片描述"></p>
<p><strong>使用Lambda表达式</strong></p>
<p>Lambda 表达式 是 Java 8 的卖点之一.。即使你还没有使用过Java 8， 到目前你也可能有一些基本的了解。但在Java编程中还是一种新的方式，它也不是明显的”最佳实践” 。 这里有一些我遵循的指南。</p>
<p><strong>保持简短</strong></p>
<p>函数式程序员更愿意使用较长的lambda 表达式，但我们这些仅仅使用Java很多年的程序员来说更容易保持lambda 表达式的短小。你甚至更喜欢把它们限制在一行，更容易把较长的表达式 重构 到一个方法中。</p>
<p><img src="http://img.blog.csdn.net/20161214163709620" alt="这里写图片描述"></p>
<p>把它们变成一个方法引用， 方法引用看起来有一点陌生，但却值得这样做，因为在某些情况有助于提高可读性，后面我再谈可读性。</p>
<p><img src="http://img.blog.csdn.net/20161214163740278" alt="这里写图片描述"></p>
<p><strong>明确的</strong><br>(作者应该想要表达的是: 参数命名规范，要有意义；有更好的翻译请修正)</p>
<p>lambda 表达式中类型信息已经丢失了，因此你会发现包含类型信息的参数会更有用。</p>
<p><img src="http://img.blog.csdn.net/20161214163826731" alt="这里写图片描述"></p>
<p>如你所见，这样会比较麻烦。因此我更喜欢给参数一个更有意义的命名。当然，你做与否， IntelliJ IDEA 都会让你看到参数的类型信息。</p>
<p><img src="http://img.blog.csdn.net/20161214163910185" alt="这里写图片描述"></p>
<p>即使是在函数式接口的lambda 表达式中:</p>
<p><img src="http://img.blog.csdn.net/20161214163951076" alt="这里写图片描述"></p>
<p><strong>针对 Lambda 表达式进行设计</strong></p>
<p>我认为lambda表达式有点像 泛型 – 泛型,我们经常使用它们 (例如, 给 List&lt;&gt; 添加类型信息 )，但不常见的是我们把一个方法或类泛型化 (如:  Person&lt;’T&gt; )。同样的, 它就像我们使用通过lambdas包装的 Streams API，但对我们来说更罕见的是创建一个需要 lambda 表达式参数的方法。</p>
<p><strong>IntelliJ IDEA 可以帮助你引入一个函数化的参数</strong></p>
<p>这里让你可以使用 Lambda 表达式而非对象来 <a href="https://www.jetbrains.com/help/idea/2016.1/extract-functional-parameter.html" target="_blank" rel="noopener">创建一个参数</a> 。这个功能的好处在于其建议使用一个已有的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html" target="_blank" rel="noopener">函数接口</a> 来匹配这个规范。</p>
<p><img src="http://img.blog.csdn.net/20161214164320297" alt="这里写图片描述"></p>
<p>这个将引导我们</p>
<p><strong>使用已有的函数接口</strong></p>
<p>当开发者越来越熟悉 Java 8 代码时，我们会知道使用例如 Supplier 和 Consumer 这样的接口会发生什么，但是单独再创建一个 ErrorMessageCreator 会让我们很诧异并且很浪费时间。你可以翻阅 function package 来查看系统本身已经给我们准备了什么。</p>
<p><strong>为函数接口添加 @FunctionalInterface 注解</strong></p>
<p>如果你真的需要创建自己的函数接口，那么就需要用这个  @FunctionalInterface  注解。这个注解似乎没多大用处，但是  IntelliJ IDEA  会在接口不满足这个注解要求的情况下予以提示。例如你没有指定要继承的方法：</p>
<p><img src="http://img.blog.csdn.net/20161214164518523" alt="这里写图片描述"></p>
<p>指定太多的方法：</p>
<p><img src="http://img.blog.csdn.net/20161214164547695" alt="这里写图片描述"></p>
<p>在类中使用注解而不是在接口：</p>
<p><img src="http://img.blog.csdn.net/20161214164619204" alt="这里写图片描述"></p>
<p>Lambda 表达式可用于任意只包含单个抽象方法的接口中，但是不能用于满足该要求的抽象类。看似不符合逻辑，但实际要求必须如此。</p>
<p><br><br><strong>Streams</strong></p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="noopener">Stream</a> API 是Java 8的另一大卖点, 我认为到现在为止，我们仍然不知道这会对我们的编码方式有多大改变．但我发现这是一个好坏参半的功能。</p>
<p><strong>流式风格</strong></p>
<p>就我个人而言，更喜欢使用流式风格．当然你不必也这么做, 但我发现它帮助了我：</p>
<p>  ·一眼就能看出有哪些操作，它的执行顺序是什么<br>·更方便调试（虽然IntelliJ IDEA提供了 <a href="https://www.youtube.com/watch?v=rimzOolGguo&amp;feature=youtu.be&amp;t=3s" target="_blank" rel="noopener">在包含lambda表达式的行上设置断点的能力</a> ，为了更方便调试，把它拆分到不同的行上）* 在测试的时候允许取消一个操作<br>·在调试或测试是，可以很方便的插入peek()</p>
<p><img src="http://img.blog.csdn.net/20161214165029299" alt="这里写图片描述"></p>
<p>在我看来这样写很简洁。但是使用这种方法并没有给我们节省多少代码行。你可能需要调整代码格式化设置让代码看起来更加清晰。</p>
<p><img src="http://img.blog.csdn.net/20161214165143409" alt="这里写图片描述"></p>
<p><br><br><strong>使用方法引用</strong></p>
<p>是的，你需要一点时间来适应这个奇怪的语法。但如果使用恰当，真的可以提升代码的可读性，看看下面代码：</p>
<p><img src="http://img.blog.csdn.net/20161214165247861" alt="这里写图片描述"></p>
<p>以及使用 Objects 类的辅助方法：</p>
<p><img src="http://img.blog.csdn.net/20161214165331410" alt="这里写图片描述"></p>
<p>后面一段代码更加的明确可读。IntelliJ IDEA 通常会知道怎么将一个 Lambda 表达式进行折叠。</p>
<p><img src="http://img.blog.csdn.net/20161214165408051" alt="这里写图片描述"></p>
<p><strong>当对集合进行元素迭代时，尽可能的使用 Streams API</strong></p>
<p>…或者用新的集合方法，例如 forEach . IntelliJ IDEA 会建议你这么做：</p>
<p><img src="http://img.blog.csdn.net/20161214165535504" alt="这里写图片描述"></p>
<p>一般来说使用 Streams API 比起循环和 if 语句组合来得更加直观，例如：</p>
<p><img src="http://img.blog.csdn.net/20161214165613194" alt="这里写图片描述"></p>
<p>IntelliJ IDEA 会建议这样的写法进行重构：</p>
<p><img src="http://img.blog.csdn.net/20161214165649927" alt="这里写图片描述"></p>
<p>我做过的性能测试显示这种重构带来的结果比较奇怪，难以预测，有时候好，有时候坏，有时候没区别。一如既往的，如果你的应用对性能问题非常在意，请认真的进行衡量。</p>
<p><strong>遍历数组时请用 for 循环</strong></p>
<p>然后，使用 Java 8 并不意味着你一定要使用流 API 以及集合的新方法。IntelliJ IDEA 会建议一些做法改用流的方式重构，但你不一定非得接受 (记住 <a href="https://www.jetbrains.com/help/idea/2016.2/suppressing-inspections.html" target="_blank" rel="noopener">inspections can be suppressed</a> 或者 <a href="https://www.jetbrains.com/help/idea/2016.2/disabling-and-enabling-inspections.html" target="_blank" rel="noopener">turned off</a> ).</p>
<p>特别是对一个原始类型的小数组时，使用 for 循环的性能是最好的，而且代码更具可读性（至少对 Streams API 的新手来说是这样）：</p>
<p><img src="http://img.blog.csdn.net/20161214165851697" alt="这里写图片描述"></p>
<p>任何的技巧和提示都不是一成不变的，你应该自己决定哪里需要使用 Streams API ，而哪里还用循环操作。</p>
<p><strong>最后</strong></p>
<p>我每天都在发现一些新的东西，有时候我的偏好会有所变化。例如我过去会讨厌方法的引用。非常期待倾听你的建议。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Logger级别</title>
    <url>/2017/02/18/Logger%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>日志记录器(Logger)是日志处理的核心组件。log4j具有5种正常级别(Level)。日志记录器(Logger)的可用级别Level (不包括自定义级别 Level)， <a id="more"></a>以下内容就是摘自log4j API (<a href="http://jakarta.apache.org/log4j/docs/api/index.html)" target="_blank" rel="noopener">http://jakarta.apache.org/log4j/docs/api/index.html)</a>:<br><br><strong>static Level DEBUG</strong><br><br>DEBUG Level指出细粒度信息事件对调试应用程序是非常有帮助的。<br><strong>static Level INFO</strong><br><br>INFO level表明 消息在粗粒度级别上突出强调应用程序的运行过程。<br><strong>static Level WARN</strong><br><br>WARN level表明会出现潜在错误的情形。<br><strong>static Level ERROR</strong><br><br>ERROR level指出虽然发生错误事件，但仍然不影响系统的继续运行。<br><strong>static Level FATAL</strong><br><br>FATAL level指出每个严重的错误事件将会导致应用程序的退出。<br>另外，还有两个可用的特别的日志记录级别: (以下描述来自log4j API <a href="http://jakarta.apache.org/log4j/docs/api/index.html)" target="_blank" rel="noopener">http://jakarta.apache.org/log4j/docs/api/index.html)</a>:<br><br><strong>static Level ALL</strong><br><br>ALL Level是最低等级的，用于打开所有日志记录。<br><strong>static Level OFF</strong><br><br>OFF Level是最高等级的，用于关闭所有日志记录。<br>日志记录器（Logger）的行为是分等级的。如下表所示：<br>分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。<font color="red">Log4j建议只使用四个级别，优先级从高到低分别是 ERROR、WARN、INFO、DEBUG。</font>通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。<font color="red">比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来，也是说大于等于的级别的日志才输出。</font></p>
<font color="red">日志记录的级别有继承性，子类会记录父类的所有的日志级别。</font>]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Logger</tag>
      </tags>
  </entry>
  <entry>
    <title>Java接口是常量存放的最佳地点吗？</title>
    <url>/2017/02/18/Java%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%B8%B8%E9%87%8F%E5%AD%98%E6%94%BE%E7%9A%84%E6%9C%80%E4%BD%B3%E5%9C%B0%E7%82%B9%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天偶然看到接口中不能包含<strong>实例域</strong>或<strong>静态方法</strong>，但是却可以包含<strong>常量</strong>。<br><br>其实在之前，就知道这么回事，但是一直只是当做知道而已，现在回过头来巩固基础，觉得有必要多想想。<br><a id="more"></a><br>首先，由于java的接口中声明的字段在编译时会自动加上static final的修饰符，即声明为常量。因而接口通常是存放常量的最佳地点，因为这样可以省去很多修饰符嘛，然而在java的实际应用时却会产生一些问题。<br></p>
<p>问题的起因个人觉得有两个:<br><br>第一，是我们所使用的常量并不是一成不变的，而是相对于变量不能赋值改变。例如我们在一个项目初期定义常量π＝3.14，而由于计算精度的提高我们可能会重新定义π＝3.14159，此时整个项目对此常量的引用都应该做出改变。<br><br>第二，java是动态语言。与c++之类的静态语言不同,java对一些字段的引用可以在运行期动态进行，这种灵活性是java这样的动态语言的一大优势。也就使得我们在java项目中有时部分内容的改变不用重新编译整个项目，而只需编译改变的部分重新发布就可以改变整个应用。</p>
<p>例如，有一个interface A，一个class B，代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface A&#123;</span><br><span class="line">	<span class="keyword">String</span> name = <span class="string">"bright"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"Class A's name = "</span> + A.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译A和B。<br><br>运行，输入java B，显然结果如下：<br><figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">A</span>'<span class="title">s</span> <span class="title">name</span> = <span class="title">bright</span></span></span><br></pre></td></tr></table></figure></p>
<p>我们现在修改A如下：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>A&#123;</span><br><span class="line">	String name = <span class="string">"bright sea"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译A后重新运行B，输入java B，注意：结果如下<br><figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">A</span>'<span class="title">s</span> <span class="title">name</span> = <span class="title">bright</span></span></span><br></pre></td></tr></table></figure></p>
<p>为什么不是”Class A’s name = bright sea”？让我们使用jdk提供的反编译工具javap反编译B.class看个究竟，输入：javap -c B ，结果如下：</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line">Compiled from B.java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> B();</span><br><span class="line">    <span class="keyword">public</span> static void main(java.lang.String[]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">B</span>(</span>)</span><br><span class="line">   <span class="number">0</span> aload_0</span><br><span class="line">   <span class="number">1</span> invokespecial<span class="meta"> #1 &lt;Method java.lang.Object()&gt;</span></span><br><span class="line">   <span class="number">4</span> <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">void</span> <span class="title">main</span>(</span>java.lang.String[])</span><br><span class="line">   <span class="number">0</span> getstatic<span class="meta"> #2 &lt;Field java.io.PrintStream out&gt;</span></span><br><span class="line">   <span class="number">3</span> ldc<span class="meta"> #3 &lt;String "Class A's name = bright"&gt;</span></span><br><span class="line">   <span class="number">5</span> invokevirtual<span class="meta"> #4 &lt;Method void println(java.lang.String)&gt;</span></span><br><span class="line">   <span class="number">8</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>注意到标号3的代码了吗？由于引用了一个static final 的字段，编译器已经将interface A中name的内容编译进了class B中，而不是对interface A中的name的引用。因此除非我们重新编译class B，interface A中name发生的变化无法在class B中反映。如果这样去做那么java的动态优势就消失殆尽。<br></p>
<p>解决方案，有两种解决方法。<br><br>第一种方法是不再使用常量，将所需字段放入class中声明，并去掉final修饰符。但这种方法存在一定的风险，由于不再是常量着因而在系统运行时有可能被其他类修改其值而发生错误，也就违背了我们设置它为常量的初衷，因而不推荐使用。<br><br>第二种方法，将常量放入class中声明，使用class方法来得到此常量的值。为了保持对此常量引用的简单性，我们可以使用一个静态方法。我们将A.java和B.java修改如下：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> name = <span class="string">"bright"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"Class A's name = "</span> + A.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样我们编译A和B。运行class B，输入java B，显然结果如下：<br>Class A’s name = bright<br>现在我们修改A如下：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> name = <span class="string">"bright"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再次编译A后重新运行B，输入java B：结果如下<br><figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">A</span>'<span class="title">s</span> <span class="title">name</span> = <span class="title">bright</span> <span class="title">sea</span></span></span><br></pre></td></tr></table></figure></p>
<p>终于得到了我们想要的结果，我们可以再次反编译B看看class B的改变，输入<br>javap -c B,结果如下：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Compiled from B.java</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> </span>&#123;</span><br><span class="line">    public B();</span><br><span class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(java.lang.<span class="built_in">String</span>[]);</span><br><span class="line">&#125;</span><br><span class="line">Method B()</span><br><span class="line">   <span class="number">0</span> aload_0</span><br><span class="line">   <span class="number">1</span> invokespecial #<span class="number">1</span> &lt;Method java.lang.<span class="built_in">Object</span>()&gt;</span><br><span class="line">   <span class="number">4</span> <span class="keyword">return</span></span><br><span class="line">Method <span class="keyword">void</span> main(java.lang.<span class="built_in">String</span>[])</span><br><span class="line">   <span class="number">0</span> getstatic #<span class="number">2</span> &lt;Field java.io.PrintStream out&gt;</span><br><span class="line">   <span class="number">3</span> <span class="keyword">new</span> #<span class="number">3</span> &lt;Class java.lang.<span class="built_in">StringBuffer</span>&gt;</span><br><span class="line">   <span class="number">6</span> dup</span><br><span class="line">   <span class="number">7</span> invokespecial #<span class="number">4</span> &lt;Method java.lang.<span class="built_in">StringBuffer</span>()&gt;</span><br><span class="line">  <span class="number">10</span> ldc #<span class="number">5</span> &lt;<span class="built_in">String</span> <span class="string">"Class A's name = "</span>&gt;</span><br><span class="line">  <span class="number">12</span> invokevirtual #<span class="number">6</span> &lt;Method java.lang.<span class="built_in">StringBuffer</span> append(java.lang.<span class="built_in">String</span>)&gt;</span><br><span class="line">  <span class="number">15</span> invokestatic #<span class="number">7</span> &lt;Method java.lang.<span class="built_in">String</span> getName()&gt;</span><br><span class="line">  <span class="number">18</span> invokevirtual #<span class="number">6</span> &lt;Method java.lang.<span class="built_in">StringBuffer</span> append(java.lang.<span class="built_in">String</span>)&gt;</span><br><span class="line">  <span class="number">21</span> invokevirtual #<span class="number">8</span> &lt;Method java.lang.<span class="built_in">String</span> toString()&gt;</span><br><span class="line">  <span class="number">24</span> invokevirtual #<span class="number">9</span> &lt;Method <span class="keyword">void</span> println(java.lang.<span class="built_in">String</span>)&gt;</span><br><span class="line">  <span class="number">27</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure></p>
<p>注意标号10至15行的代码，class B中已经变为对A class的getName()方法的引用，当常量name的值改变时我们只需对class A中的常量做修改并重新编译，无需编译整个项目工程我们就能改变整个应用对此常量的引用，即保持了java动态优势又保持了我们使用常量的初衷，因而方法二是一个最佳解决方案。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>接口</tag>
        <tag>常量</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射学习总结（五）</title>
    <url>/2017/02/18/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><strong>使用反射实例对象</strong></p>
<p>使用反射机制，我们可以在运行时动态加载类并且实例化对象，操作对象的方法、改变类成员的值，甚至还可以改变私有（private）成员的值。</p>
<p>我们可以用 Class 的 newInstance() 方法来实例化一个对象，实例化的对象是以 Object 传回的，例如：<br><a id="more"></a><br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span> c = <span class="keyword">Class</span>.forName(className);</span><br><span class="line"><span class="keyword">Object</span> obj = c.newInstance();</span><br></pre></td></tr></table></figure></p>
<p>下面范例动态加载list接口的类：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line">            List <span class="built_in">list</span> = (List) c.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="built_in">list</span>.add(<span class="string">"element "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Object o : <span class="built_in">list</span>.toArray()) &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"找不到指定的类"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">java CoreJava.day_2.NewInstanceDemo java.util.ArrayList</span><br><span class="line"><span class="keyword">element</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">element</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">element</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">element</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">element</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>实际上如果想要使用反射来动态加载类，通常是对对象的接口或类别都一无所知，也就无法像上面对 newInstance() 传回的对象进行接口转换。</p>
<p>如果加载的类中具备无参数的构造方法，则可以无参数的 newInstance() 来构造一个不指定初始化的引用，如果要在动态加载及生成对象时指定对象的引用，则要先指定参数类型、取得 Constructor 对象、使用 Constructor 的 newInstance() 并指定参数。</p>
<p>可以用一个例子来说明，先定义一个student类:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = <span class="string">"N/A"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">String</span> name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">":"</span> + score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用 Class.forName() 来加载 Student ，并使用第二个有参数的构造方法来构造Student 实例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> NewInstanceDemo2 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = Class.forName(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指定参数</span></span><br><span class="line">            Class[] params = <span class="keyword">new</span> Class[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 第一个是String</span></span><br><span class="line">            params[<span class="number">0</span>] = <span class="built_in">String</span>.class;</span><br><span class="line">            <span class="comment">// 第二个是int</span></span><br><span class="line">            params[<span class="number">1</span>] = Integer.TYPE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取得对应的构造方法</span></span><br><span class="line">            Constructor <span class="keyword">constructor</span> =</span><br><span class="line">                    c.getConstructor(<span class="params">params</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指定引用内容</span></span><br><span class="line">            <span class="built_in">Object</span>[] argObjs = <span class="keyword">new</span> <span class="built_in">Object</span>[<span class="number">2</span>];</span><br><span class="line">            argObjs[<span class="number">0</span>] = <span class="string">"caterpillar"</span>;</span><br><span class="line">            argObjs[<span class="number">1</span>] = <span class="keyword">new</span> Integer(<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 给定引用并初始化</span></span><br><span class="line">            <span class="built_in">Object</span> obj = <span class="keyword">constructor</span>.newInstance(<span class="params">argObjs</span>);</span><br><span class="line">            <span class="comment">// toString()查看</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"找不到类"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有所指定的方法"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span> <span class="selector-tag">NewInstanceDemo2</span> <span class="selector-tag">CoreJava</span><span class="selector-class">.day_2</span><span class="selector-class">.Student</span></span><br><span class="line"><span class="selector-tag">caterpillar</span><span class="selector-pseudo">:90</span></span><br></pre></td></tr></table></figure>
<p><strong>调用方法</strong></p>
<p>使用反射可以取回类上方法的对象代表，方法的物件代表是 java.lang.reflect.Method 的实例，我们可以使用它的 invoke() 方法来动态调用指定的方法，例如调用上面 Student 上的 setName() 等方法：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> InvokeMethodDemo &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">Class</span> c = <span class="keyword">Class</span>.forName(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 使用无参构造方法实例对象</span></span><br><span class="line">            Object targetObj = c.newInstance();</span><br><span class="line">            <span class="comment">// 设置参数类型</span></span><br><span class="line">            <span class="keyword">Class</span>[] param1 = &#123;String.<span class="keyword">class</span>&#125;;</span><br><span class="line">            <span class="comment">// 根据参数取回方法</span></span><br><span class="line">            Method setNameMethod = c.getMethod(<span class="string">"setName"</span>, param1);</span><br><span class="line">            <span class="comment">// 设置引用</span></span><br><span class="line">            Object[] argObjs1 = &#123;<span class="string">"caterpillar"</span>&#125;;</span><br><span class="line">            <span class="comment">// 给引用调用指定对象的方法方法</span></span><br><span class="line">            setNameMethod.invoke(targetObj, argObjs1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span>[] param2 = &#123;Integer.TYPE&#125;;</span><br><span class="line">            Method setScoreMethod =</span><br><span class="line">                    c.getMethod(<span class="string">"setScore"</span>, param2);</span><br><span class="line"></span><br><span class="line">            Object[] argObjs2 = &#123;<span class="keyword">new</span> Integer(<span class="number">90</span>)&#125;;</span><br><span class="line">            setScoreMethod.invoke(targetObj, argObjs2);</span><br><span class="line">            <span class="comment">// 显示类描述</span></span><br><span class="line">            System.out.<span class="keyword">println</span>(targetObj);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"找不到类"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"没有这个方法"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以指定加载 Student 类并生成实例，接着可以动态调用 setName() 和 setScore() 方法，由于调用setName() 和 setScore() 所设置的参数是 “caterpillar” 和90。</p>
<p>在很少的情況下，我们需要突破 Java 的存取限制来调用受保护的（protected）或私有（private）的方法（例如我们拿到一个组件（Component），但我们没法修改它的原始码来改变某个私有方法的权限，而我们又一定要调用某个私有方法），这时我们可以使用反射机制來达到目的，一个存取私有方法的例子如下：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">privateMethod</span> = </span></span><br><span class="line"><span class="function">            <span class="title">c</span>.<span class="title">getDeclaredMethod</span><span class="params">("somePrivateMethod", <span class="keyword">new</span> <span class="keyword">Class</span>[0])</span>;</span></span><br><span class="line">privateMethod.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">privateMethod.invoke(targetObj, argObjs);</span><br></pre></td></tr></table></figure>
<p>使用反射来动态调用方法的实例例子之一是在 JavaBean 的设定，例如在 JSP/Servlet 中，可以根据使用者的请求名和 JavaBean 的属性自动对比，将请求值设置到指定的 JavaBean 上，并自动根据参数类型转换。</p>
<p>下面是一个map的小例子：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class CommandUtil &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Object</span> getCommand(Map requestMap,</span><br><span class="line">                                    <span class="keyword">String</span> commandClass)</span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Class c = Class.forName(commandClass);</span><br><span class="line">        <span class="keyword">Object</span> o = c.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> updateCommand(requestMap, o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用reflection自动找出要更新的属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Object</span> updateCommand(</span><br><span class="line">            Map requestMap,</span><br><span class="line">            <span class="keyword">Object</span> command)</span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Method[] methods =</span><br><span class="line">                command.getClass().getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 略过private、protected成员</span></span><br><span class="line">            <span class="comment">// 且找出必须是set开头的方法</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPrivate(methods[i].getModifiers()) &amp;&amp;</span><br><span class="line">                    !Modifier.isProtected(methods[i].getModifiers()) &amp;&amp;</span><br><span class="line">                    methods[i].getName().startsWith(<span class="string">"set"</span>)) &#123;</span><br><span class="line">                <span class="comment">// 取得不包括set方法</span></span><br><span class="line">                <span class="keyword">String</span> name = methods[i].getName()</span><br><span class="line">                        .substring(<span class="number">3</span>)</span><br><span class="line">                        .toLowerCase();</span><br><span class="line">                <span class="comment">// 如果setter名称键值对相同</span></span><br><span class="line">                <span class="comment">// 调用对应的setter并给值</span></span><br><span class="line">                <span class="keyword">if</span> (requestMap.containsKey(name)) &#123;</span><br><span class="line">                    <span class="keyword">String</span> param = (<span class="keyword">String</span>) requestMap.<span class="built_in">get</span>(name);</span><br><span class="line">                    <span class="keyword">Object</span>[] values = findOutParamValues(</span><br><span class="line">                            param, methods[i]);</span><br><span class="line">                    methods[i].invoke(command, values);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换对应类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Object</span>[] findOutParamValues(</span><br><span class="line">            <span class="keyword">String</span> param, Method method) &#123;</span><br><span class="line">        Class[] params = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">Object</span>[] objs = <span class="keyword">new</span> <span class="keyword">Object</span>[params.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (params[i] == <span class="keyword">String</span>.class) &#123;</span><br><span class="line">                objs[i] = param;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == Short.TYPE) &#123;</span><br><span class="line">                <span class="keyword">short</span> number = Short.parseShort(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Short(number);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == Integer.TYPE) &#123;</span><br><span class="line">                <span class="built_in">int</span> number = Integer.parseInt(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Integer(number);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == Long.TYPE) &#123;</span><br><span class="line">                <span class="keyword">long</span> number = Long.parseLong(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Long(number);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == Float.TYPE) &#123;</span><br><span class="line">                <span class="built_in">float</span> number = Float.parseFloat(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Float(number);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == Double.TYPE) &#123;</span><br><span class="line">                <span class="keyword">double</span> number = Double.parseDouble(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Double(number);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == Boolean.TYPE) &#123;</span><br><span class="line">                <span class="built_in">boolean</span> bool = Boolean.parseBoolean(param);</span><br><span class="line">                objs[i] = <span class="keyword">new</span> Boolean(bool);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objs;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; request = </span><br><span class="line">                  <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;();</span><br><span class="line">        request.put(<span class="string">"name"</span>, <span class="string">"caterpillar"</span>);</span><br><span class="line">        request.put(<span class="string">"score"</span>, <span class="string">"90"</span>);</span><br><span class="line">        <span class="keyword">Object</span> obj = CommandUtil.getCommand(request, args[<span class="number">0</span>]);</span><br><span class="line">        System.out.<span class="built_in">println</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CommandUtil 可以自动根据方法上的参数类型，将Map 中的value转换成相应的类型，目前它可以转换基本类型和 String。</p>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span> <span class="selector-tag">CommandUtilDemo</span> <span class="selector-tag">CoreJava</span><span class="selector-class">.day_2</span><span class="selector-class">.Student</span></span><br><span class="line"><span class="selector-tag">caterpillar</span><span class="selector-pseudo">:90</span></span><br></pre></td></tr></table></figure>
<p>当然也可以修改<strong>成员变量</strong>，尽管直接读取类的成员属性（Field）是不被鼓励的，但我们仍是可以直接存取公共的（public）成员属性的，而我们甚至也可以通过反射机制来读取私用成员变量，以一个例子来说明：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> testInt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> testString;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> testInt + <span class="string">":"</span> + testString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后利用反射机制动态的读取成员变量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">package <span class="type">CoreJava</span>.day_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssignFieldDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="built_in">c</span> = <span class="type">Class</span>.forName(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">Object</span> targetObj = <span class="built_in">c</span>.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="type">Field</span> testInt = <span class="built_in">c</span>.getField(<span class="string">"testInt"</span>);</span><br><span class="line">            testInt.setInt(targetObj, <span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Field</span> testString = <span class="built_in">c</span>.getField(<span class="string">"testString"</span>);</span><br><span class="line">            testString.<span class="keyword">set</span>(targetObj, <span class="string">"caterpillar"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(targetObj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">ArrayIndexOutOfBoundsException</span> e) &#123;</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"没有指定类"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">ClassNotFoundException</span> e) &#123;</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"找不到指定的类"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">SecurityException</span> e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">NoSuchFieldException</span> e) &#123;</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"找不到指定的成员变量"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">InstantiationException</span> e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">IllegalAccessException</span> e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span> <span class="selector-tag">AssignFieldDemo</span> <span class="selector-tag">CoreJava</span><span class="selector-class">.day_2</span><span class="selector-class">.TestField</span></span><br><span class="line">99<span class="selector-pseudo">:caterpillar</span></span><br></pre></td></tr></table></figure>
<p>如果有必要的话，也可以通过反射机制来读取私有的成员变量，例如：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">Field privateField = <span class="keyword">c</span>.getDeclaredField(<span class="string">"privateField"</span>)<span class="comment">; </span></span><br><span class="line"><span class="comment">privateField.setAccessible(true);</span></span><br><span class="line"><span class="comment">privateField.setInt(targetObj, 99);</span></span><br></pre></td></tr></table></figure>
<p><strong>数组</strong><br>在 Java 中数组也是一个对象，也会有一个 Class 实例来表示它，我们用几个基本类型和String来进行测试：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        short[] sArr = <span class="keyword">new</span> short[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span>[] iArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">long</span>[] lArr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">float</span>[] fArr = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">double</span>[] dArr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">byte</span>[] bArr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] zArr = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">String</span>[] strArr = <span class="keyword">new</span> <span class="keyword">String</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"short 数组："</span> + sArr.getClass());</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"int 数组："</span> + iArr.getClass());</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"long 数组："</span> + lArr.getClass());</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"float 数组："</span> + fArr.getClass());</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"double 数组："</span> + dArr.getClass());</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"byte 数组："</span> + bArr.getClass());</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"boolean 数组："</span> + zArr.getClass());</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"String 数组："</span> + strArr.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">short 数组：<span class="class"><span class="keyword">class</span> [<span class="title">S</span></span></span><br><span class="line">int 数组：<span class="class"><span class="keyword">class</span> [<span class="title">I</span></span></span><br><span class="line">long 数组：<span class="class"><span class="keyword">class</span> [<span class="title">J</span></span></span><br><span class="line">float 数组：<span class="class"><span class="keyword">class</span> [<span class="title">F</span></span></span><br><span class="line">double 数组：<span class="class"><span class="keyword">class</span> [<span class="title">D</span></span></span><br><span class="line">byte 数组：<span class="class"><span class="keyword">class</span> [<span class="title">B</span></span></span><br><span class="line">boolean 数组：<span class="class"><span class="keyword">class</span> [<span class="title">Z</span></span></span><br><span class="line">String 数组：<span class="class"><span class="keyword">class</span> [<span class="title">Ljava</span>.<span class="title">lang</span>.<span class="title">String</span>;</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>要使用<strong>反射机制动态生成数组</strong>的话，也可以这样：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="keyword">Array</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class NewArrayDemo &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        Class c = <span class="keyword">String</span>.class;</span><br><span class="line">        <span class="keyword">Object</span> objArr = <span class="keyword">Array</span>.newInstance(c, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">Array</span>.<span class="built_in">set</span>(objArr, i, i + <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(<span class="keyword">Array</span>.<span class="built_in">get</span>(objArr, i) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">String</span>[] strs = (<span class="keyword">String</span>[]) objArr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> s : strs) &#123;</span><br><span class="line">            System.out.<span class="built_in">print</span>(s + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Array.newInstance() 的第一个参数是指定参数类型，而第二个参数是用来指定数组长度的，结果如下：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>如果是二维数组，也是一样的：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.<span class="keyword">Array</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class NewArrayDemo2 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        Class c = <span class="keyword">String</span>.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打算建立一个3*4数组</span></span><br><span class="line">        <span class="built_in">int</span>[] dim = <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">Object</span> objArr = <span class="keyword">Array</span>.newInstance(c, dim);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">Object</span> row = <span class="keyword">Array</span>.<span class="built_in">get</span>(objArr, i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">Array</span>.<span class="built_in">set</span>(row, j, <span class="string">""</span> + (i + <span class="number">1</span>) * (j + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">Object</span> row = <span class="keyword">Array</span>.<span class="built_in">get</span>(objArr, i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                System.out.<span class="built_in">print</span>(<span class="keyword">Array</span>.<span class="built_in">get</span>(row, j) + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">println</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">6</span> <span class="number">9</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>如果想要知道数组元素的类型，可以在取得数组的 Class 实例之后，使用 Class 实例的 getComponentType() 方法，所取回的是元素的 Class 实例，例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] iArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">System.out.<span class="built_in">println</span>(iArr.getClass().getComponentType());</span><br></pre></td></tr></table></figure>
<p>对反射的总结差不多就写到这里了，查阅了很多资料，网络上写的也是参差不齐的，在手写的几十个demo支撑下，得出的一点关于反射的东西，肯定不能说全部正确，但是还是可以提供一些帮助的  -。-</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射学习总结（四）</title>
    <url>/2017/02/18/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><strong>类加载器</strong></p>
<p>Java在需要使用类的时候，才会将类加载，Java的类加载是由类加载器（Class loader）来完成的。<br>当我们在命令模式下执行java xxx指令后，Java执行程序会尝试找到jre安装的所在目录，然后找到jvm.dll（假设在jre目录下的bin\client下），接着启动jvm并进行初始化操作，接着会产生bootstrap loader，bootstrap loader则会加载 extended loader，并设定 extended loader的parent为bootstrap loader，接着bootstrap loader会加载system loader，并将system loader的parent设为 extended loader。<br><a id="more"></a><br>bootstrap loader通常是由c写的， extended loader是由Java写的，实际这个对应着sun.misc.Launcher\$ExtClassLoader（Launcher 中的内部类）；system loader 是由 Java写的，实际对应sun.misc. Launcher\$AppClassLoader（Launcher 中的内部类）。</p>
<p><strong>流程如下图：</strong><br><img src="http://img.blog.csdn.net/20161205220032526" alt="这里写图片描述"></p>
<p>Bootstrap Loader 会查找系统参数 sun.boot.class.path 中指定位置的类，假设是 JRE classes 下之文件，或 lib 目录下 .jar 文件中（例如 rt.jar）的类并加载，我们可以使用 System.getProperty(“sun.boot.class.path”) 来显示 sun.boot.class.path 中指定的路劲，例如在我的终端显示的是以下的路劲：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/Library/</span>Java<span class="regexp">/JavaVirtualMachines/</span>jdk1<span class="number">.8</span><span class="number">.0</span>_65.jdk<span class="regexp">/Contents/</span>Home<span class="regexp">/jre/</span>lib<span class="regexp">/resources.jar:/</span>Library<span class="regexp">/Java/</span>JavaVirtualMachines<span class="regexp">/jdk1.8.0_65.jdk/</span>Contents<span class="regexp">/Home/</span>jre<span class="regexp">/lib/</span>rt.<span class="string">jar:</span><span class="regexp">/Library/</span>Java<span class="regexp">/JavaVirtualMachines/</span>jdk1<span class="number">.8</span><span class="number">.0</span>_65.jdk<span class="regexp">/Contents/</span>Home<span class="regexp">/jre/</span>lib<span class="regexp">/sunrsasign.jar:/</span>Library<span class="regexp">/Java/</span>JavaVirtualMachines<span class="regexp">/jdk1.8.0_65.jdk/</span>Contents<span class="regexp">/Home/</span>jre<span class="regexp">/lib/</span>jsse.<span class="string">jar:</span><span class="regexp">/Library/</span>Java<span class="regexp">/JavaVirtualMachines/</span>jdk1<span class="number">.8</span><span class="number">.0</span>_65.jdk<span class="regexp">/Contents/</span>Home<span class="regexp">/jre/</span>lib<span class="regexp">/jce.jar:/</span>Library<span class="regexp">/Java/</span>JavaVirtualMachines<span class="regexp">/jdk1.8.0_65.jdk/</span>Contents<span class="regexp">/Home/</span>jre<span class="regexp">/lib/</span>charsets.<span class="string">jar:</span><span class="regexp">/Library/</span>Java<span class="regexp">/JavaVirtualMachines/</span>jdk1<span class="number">.8</span><span class="number">.0</span>_65.jdk<span class="regexp">/Contents/</span>Home<span class="regexp">/jre/</span>lib<span class="regexp">/jfr.jar:/</span>Library<span class="regexp">/Java/</span>JavaVirtualMachines<span class="regexp">/jdk1.8.0_65.jdk/</span>Contents<span class="regexp">/Home/</span>jre/classes</span><br></pre></td></tr></table></figure>
<p>Extended Loader（sun.misc.Launcher$ExtClassLoader）是由 Java 写的，会查找系统参数java.ext.dirs 中指定位置的类，假设是 JRE 目录下的 lib\ext\classes 目录下的 .class 文件，或 lib\ext 目录下的 .jar 文件中（例如 rt.jar）的类并加载，我们可以使用 System.getProperty(“java.ext.dirs”) 来显示指定的路劲:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/Users/</span>lizhi<span class="regexp">/Library/</span>Java<span class="regexp">/Extensions:/</span>Library<span class="regexp">/Java/</span>JavaVirtualMachines<span class="regexp">/jdk1.8.0_65.jdk/</span>Contents<span class="regexp">/Home/</span>jre<span class="regexp">/lib/</span><span class="string">ext:</span><span class="regexp">/Library/</span>Java<span class="regexp">/Extensions:/</span>Network<span class="regexp">/Library/</span>Java<span class="regexp">/Extensions:/</span>System<span class="regexp">/Library/</span>Java<span class="regexp">/Extensions:/</span>usr<span class="regexp">/lib/</span>java</span><br></pre></td></tr></table></figure>
<p>System Loader（sun.misc.Launcher$AppClassLoader）是由 Java 写的，会查找系统参 java.class.path 中指定位置的类，也就是 Classpath 所指定的路径，假设是目前工作路径下的 .class 文件，我们可以使用 System.getProperty(“java.class.path”) 来显示 java.class.path 中指定的路径，在使用 java 执行程序时，我们也可以加上 -cp 來覆盖原有的 Classpath 设置，例如：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">java</span> –<span class="meta">cp</span> ./classes SomeClass</span><br></pre></td></tr></table></figure>
<p>Bootstrap Loader 会在 JVM 启动之后生成，之后它会加载 Extended Loader 并将其 parent 设为 Bootstrap Loader，然后Bootstrap Loader 再加载 System Loader 并将其 parent 设为 ExtClassLoader，接着System Loader 开始加载我们指定的类，在加载类时，每个类加载器会先将加载类的任务讲给他的parent，如果 parent 找不到，才由自己负责加载，所以在加载类时，会以 Bootstrap Loader→Extended Loader→System Loader 的顺序开查找类，如果都找不到，就会抛出 NoClassDefFoundError。</p>
<p>类加载器在 Java 中是以 java.lang.ClassLoader 形式存在，每一个类被加载后，都会有一个 Class 的实例来代表，而每个 Class 的实例都会记得自己是由哪个 ClassLoader 加载的，可以由 Class 的 getClassLoader() 取得加载该类的 ClassLoader，而从 ClassLoader 的 getParent() 方法可以取得自己的 parent。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立SomeClass实例</span></span><br><span class="line">        SomeClass some = <span class="keyword">new</span> SomeClass();</span><br><span class="line">        <span class="comment">// 取得SomeClass的Class实例</span></span><br><span class="line">        Class c = some.getClass();</span><br><span class="line">        <span class="comment">// 取得ClassLoader</span></span><br><span class="line">        ClassLoader loader = c.getClassLoader();</span><br><span class="line">        System.out.<span class="built_in">println</span>(loader);</span><br><span class="line">        <span class="comment">// 取得父ClassLoader</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(loader.getParent());</span><br><span class="line">        <span class="comment">// 再取得父ClassLoader</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(loader.getParent().getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sun.misc.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">60</span>e53b93</span><br><span class="line">sun.misc.Launcher<span class="variable">$ExtClassLoader</span>@<span class="number">66</span>d3c617</span><br><span class="line">null</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>CoreJava.day_2.SomeClass 是个自定义类，我们在目前的目录下执行程序，首先 AppClassLoader 会将加载类的任务交給 ExtClassLoader，而 ExtClassLoader 将会把加载类的任务交给 Bootstrap Loader，由于Bootstrap Loader 在它的路径（sun.boot.class.path）下找不到类，所以由 ExtClassLoader 来尝试查找，而 ExtClassLoader 在它的路径设置（java.ext.dirs）下也找不到类，所以由 AppClassLoader 来尝试查找，AppClassLoader 最后在 Classpath（java.class.path）设置下找到指定的类并加载。</p>
<p>在输出中可以看到，加载 SomeClass 的 ClassLoader 是 AppClassLoader，而 AppClassLoader 的 parent 是 ExtClassLoader，而 ExtClassLoader 的 parent 是 null，null 并不是表示 ExtClassLoader 没有设置 parent，而是因为 Bootstrap Loader 通常由 C 写的，在 Java 中并没有一个类来表示它，所以才会显示为null。</p>
<p>如果把 SomeClass 的 .class 文件移至 JRE 目录下的 lib\ext\classes下，并重新（任何目录下）执行程序，我们可以看到：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">null</span></span><br><span class="line"><span class="selector-tag">Exception</span> <span class="selector-tag">in</span> <span class="selector-tag">thread</span> "<span class="selector-tag">main</span>" <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.NullPointerException</span></span><br><span class="line">        <span class="selector-tag">at</span> <span class="selector-tag">CoreJava</span><span class="selector-class">.day_2</span><span class="selector-class">.SomeClass</span><span class="selector-class">.main</span>(<span class="selector-tag">SomeClass</span><span class="selector-class">.java</span><span class="selector-pseudo">:13)</span></span><br></pre></td></tr></table></figure>
<p>由于 SomeClass 这次可以在 Bootstrap Loader 的设置路径下找到，所以会由 Bootstrap Loader 来加载 SomeClass 类，Bootstrap Loader 通常由 C 写的，在 Java 中没有一个实际类来表示，所以显示为 null，因为表示为null，所以再由 null 上尝试调用 getParent() 方法就会抛出 NullPointerException 异常。</p>
<p>取得 ClassLoader 的实例之后，我们可以使用它的 loadClass() 方法来加载类，使用 loadClass() 方法加载类时，不会执行静态代码块，静态代码块的执行会等到真正使用类时来建立实例：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李智</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016/12/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass2</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"[执行静态代码块]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ForNameDemoV3 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"加载TestClass2"</span>);</span><br><span class="line">            ClassLoader loader = ForNameDemoV3.<span class="keyword">class</span>.getClassLoader();</span><br><span class="line">            <span class="keyword">Class</span> c = loader.loadClass(<span class="string">"CoreJava.day_2.TestClass2"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"TestClass2声明"</span>);</span><br><span class="line">            TestClass2 test = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"TestClass2实例对象"</span>);</span><br><span class="line">            test = <span class="keyword">new</span> TestClass2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"找不到指定的类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">加载TestClass2</span><br><span class="line">TestClass2声明</span><br><span class="line">TestClass2实例对象</span><br><span class="line">[执行静态代码块]</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以看出，loadClass() 不会在加载类时执行静态代码块，而会在使用类new对象时才执行静态代码块代码。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射学习总结（三）</title>
    <url>/2017/02/18/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Class对象表示所加载的类，取得Class对象后，我们就可以愉快的取得与类相关的信息了，就像包（package,package也是类名的一部分哦~），构造方法，方法，属性等信息，而每一个信息，也会有相应的类别形态，比如包对应的是 java.lang.Package，构造方法对应的是java.lang.reflect.Constructor，成员方法对应的是 java.lang.reflect.Method，属性对应的是 java.lang.reflect.Field等。<br><a id="more"></a><br>先来个简单的例子吧，获取一下包名：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ClassInfoDemo &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">Class</span> c = <span class="keyword">Class</span>.forName(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">Package</span> p = c.getPackage();</span><br><span class="line">            System.out.<span class="keyword">println</span>(p.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"没有指定类"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"找不到指定类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span> <span class="selector-tag">ClassInfoDemo</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.ArrayList</span></span><br><span class="line"><span class="selector-tag">java</span><span class="selector-class">.util</span></span><br></pre></td></tr></table></figure>
<p>用相应的方法，我们可以分别取得 Field、Constructor、Method等对象。</p>
<p>下面是一个我之前写的可以获取某些类信息的一个demo：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> name;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            name = args[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"输入类名:(例如:java.util.Date)"</span>);</span><br><span class="line">            name = in.next();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c1 = Class.forName(name);</span><br><span class="line">            Class superc1 = c1.getSuperclass();</span><br><span class="line">            <span class="keyword">String</span> modifiers = Modifier.toString(c1.<span class="built_in">getModifiers</span>());</span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.<span class="built_in">print</span>(modifiers + <span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">print</span>(<span class="string">"class "</span> + name);</span><br><span class="line">            <span class="keyword">if</span> (superc1 != null &amp;&amp; superc1 != Object.class) &#123;</span><br><span class="line">                System.out.<span class="built_in">print</span>(<span class="string">" extends"</span> + superc1.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">print</span>(<span class="string">"\n&#123;\n"</span>);</span><br><span class="line">            printConstructors(c1);</span><br><span class="line">            System.out.<span class="built_in">println</span>();</span><br><span class="line">            printMethods(c1);</span><br><span class="line">            System.out.<span class="built_in">println</span>();</span><br><span class="line">            printFields(c1);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"&#125;"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConstructors</span><span class="params">(Class c1)</span> </span>&#123;</span><br><span class="line">        Constructor[] constructors = c1.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c : constructors) &#123;</span><br><span class="line">            <span class="keyword">String</span> name = c.getName();</span><br><span class="line">            System.out.<span class="built_in">print</span>(<span class="string">""</span>);</span><br><span class="line">            <span class="keyword">String</span> modifers = Modifier.toString(c.<span class="built_in">getModifiers</span>());</span><br><span class="line">            <span class="keyword">if</span> (modifers.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.<span class="built_in">print</span>(modifers + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">print</span>(name + <span class="string">"("</span>);</span><br><span class="line">            Class[] paramTypes = c.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; paramTypes.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.<span class="built_in">print</span>(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.<span class="built_in">print</span>(paramTypes[j].getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">");"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMethods</span><span class="params">(Class c1)</span> </span>&#123;</span><br><span class="line">        Method[] methods = c1.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m : methods) &#123;</span><br><span class="line">            Class retType = m.getReturnType();</span><br><span class="line">            <span class="keyword">String</span> name = m.getName();</span><br><span class="line"></span><br><span class="line">            System.out.<span class="built_in">print</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">String</span> modifiers = Modifier.toString(m.<span class="built_in">getModifiers</span>());</span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.<span class="built_in">print</span>(modifiers + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">print</span>(retType.getName() + <span class="string">" "</span> + <span class="string">"("</span>);</span><br><span class="line">            Class[] paramTypes = m.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; paramTypes.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.<span class="built_in">print</span>(<span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.<span class="built_in">print</span>(paramTypes[j].getName());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">");"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFields</span><span class="params">(Class c1)</span> </span>&#123;</span><br><span class="line">        Field[] fields = c1.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">            Class type = f.getType();</span><br><span class="line">            <span class="keyword">String</span> name = f.getName();</span><br><span class="line">            System.out.<span class="built_in">print</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">String</span> modifiers = Modifier.toString(f.<span class="built_in">getModifiers</span>());</span><br><span class="line">            <span class="keyword">if</span> (modifiers.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.<span class="built_in">print</span>(modifiers + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">println</span>(type.getName() + <span class="string">" "</span> + name + <span class="string">";"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">输入类名:(例如:java.util.Date)</span><br><span class="line">java.util.Date</span><br><span class="line">publicclass java.util.Date</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> java.util.Date(java.lang.<span class="keyword">String</span>);</span><br><span class="line"><span class="keyword">public</span> java.util.Date(<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>);</span><br><span class="line"><span class="keyword">public</span> java.util.Date(<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>);</span><br><span class="line"><span class="keyword">public</span> java.util.Date();</span><br><span class="line"><span class="keyword">public</span> java.util.Date(<span class="keyword">long</span>);</span><br><span class="line"><span class="keyword">public</span> java.util.Date(<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">boolean</span> (java.lang.<span class="keyword">Object</span>);</span><br><span class="line"> <span class="keyword">public</span> java.lang.<span class="keyword">String</span> ();</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</span><br><span class="line"> <span class="keyword">public</span> java.lang.<span class="keyword">Object</span> ();</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> (java.util.Date);</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="built_in">int</span> (java.lang.<span class="keyword">Object</span>);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> (java.io.ObjectInputStream);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> (java.io.ObjectOutputStream);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar$Date ();</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar$Date (sun.util.calendar.BaseCalendar$Date);</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> (java.lang.<span class="keyword">String</span>);</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">boolean</span> (java.util.Date);</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">boolean</span> (java.util.Date);</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="built_in">int</span>);</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="built_in">int</span>);</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="built_in">int</span>);</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="built_in">int</span>);</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="built_in">int</span>);</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="built_in">int</span>);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> ();</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> (java.util.Date);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.StringBuilder (java.lang.StringBuilder,java.lang.<span class="keyword">String</span>);</span><br><span class="line"> <span class="keyword">public</span> java.lang.<span class="keyword">String</span> ();</span><br><span class="line"> <span class="keyword">public</span> java.lang.<span class="keyword">String</span> ();</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar$Date ();</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar (sun.util.calendar.BaseCalendar$Date);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar (<span class="keyword">long</span>);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar (<span class="built_in">int</span>);</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> sun.util.calendar.BaseCalendar ();</span><br><span class="line"> <span class="keyword">public</span> java.time.Instant ();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> (<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>);</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> java.util.Date (java.time.Instant);</span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="keyword">long</span>);</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">long</span> ();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar gcal;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> sun.util.calendar.BaseCalendar jcal;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">long</span> fastTime;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> sun.util.calendar.BaseCalendar$Date cdate;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> defaultCenturyStart;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> [Ljava.lang.<span class="keyword">String</span>; wtb;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> [I ttb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>输入一个类（完整的类名），即可打印该类的略为完整信息。当然还有一些不知道的，可以查看API来完成。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射学习总结（二）</title>
    <url>/2017/02/18/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p><strong>使用 Class.forName() 加载类</strong></p>
<p>在一些应用中，我们无法事先知道使用者将会加载什么类，而必须让使用者指定类名类加载类，我们就可以用Class的静态forName()方法来实现动态加载类，如下：<br><a id="more"></a><br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">package <span class="type">CoreJava</span>.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForNameDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="built_in">c</span> = <span class="type">Class</span>.forName(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"类名："</span> +</span><br><span class="line">                    <span class="built_in">c</span>.getName());</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"是否为接口："</span> +</span><br><span class="line">                    <span class="built_in">c</span>.isInterface());</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"是否为基本类型："</span> +</span><br><span class="line">                    <span class="built_in">c</span>.isPrimitive());</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"是否为数组："</span> + <span class="built_in">c</span>.isArray());</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"父类名："</span> +</span><br><span class="line">                    <span class="built_in">c</span>.getSuperclass().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">ArrayIndexOutOfBoundsException</span> e) &#123;</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"没有指定的类名"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="type">ClassNotFoundException</span> e) &#123;</span><br><span class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"找不到指定类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span> <span class="selector-tag">ForNameDemo</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.String</span></span><br><span class="line">类名：<span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.Scanner</span></span><br><span class="line">是否为接口：<span class="selector-tag">false</span></span><br><span class="line">是否为基本类型：<span class="selector-tag">false</span></span><br><span class="line">是否为数组：<span class="selector-tag">false</span></span><br><span class="line">父类名：<span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Object</span></span><br></pre></td></tr></table></figure>
<p>Class的静态方法forName()方法有两个版本，上面所示的是指定类名版本，还一个版本可以让我们指定类名，加载时是否执行静态代码块，指定类的加载器（Class loader）:</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">Class</span> forName(<span class="keyword">String</span> <span class="keyword">name</span>, boolean initialize, ClassLoader loader)</span><br></pre></td></tr></table></figure>
<p><a href="http://justdoitlee.com/javafan-she-xue-xi-bi-ji/" target="_blank"><br>上一篇</a>写到过，假设在加载类的时候，如果类中有定义静态代码块则会执行它，我们可以使用forName的第二个版本，将initialize设为false，如果在加载类时并不会马上执行静态代码块的代码，而会在使用类实例对象时才执行静态代码块，我们可以做一下测试：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李智</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016/12/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass2</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"[执行静态代码块]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们只定义了静态代码块显示一段信息，来观察静态代码块何时被执行。先用第一个版本来测试：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ForNameDemoV1 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"加载TestClass2"</span>);</span><br><span class="line">            <span class="keyword">Class</span> c = <span class="keyword">Class</span>.forName(<span class="string">"TestClass2"</span>);</span><br><span class="line"></span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"TestClass2声明"</span>);</span><br><span class="line">            TestClass2 test = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"TestClass2实例对象"</span>);</span><br><span class="line">            test = <span class="keyword">new</span> TestClass2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"找不到指定的类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">加载TestClass2</span><br><span class="line">[执行静态代码块]</span><br><span class="line">TestClass2声明</span><br><span class="line">TestClass2实例对象</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以从结果看出，第一个版本的forName()方法在加载类之后，会马上执行静态代码块，再看看第二种结果怎么样：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ForNameDemoV2 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"加载TestClass2"</span>);</span><br><span class="line">            <span class="keyword">Class</span> c = <span class="keyword">Class</span>.forName(</span><br><span class="line">                    <span class="string">"CoreJava.day_2.TestClass2"</span>,</span><br><span class="line">                    <span class="keyword">false</span>, <span class="comment">// 加载类时不执行静态代码块代码</span></span><br><span class="line">                    Thread.currentThread().getContextClassLoader());</span><br><span class="line"></span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"TestClass2声明"</span>);</span><br><span class="line">            TestClass2 test = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"TestClass2实例对象"</span>);</span><br><span class="line">            test = <span class="keyword">new</span> TestClass2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">"找不到指定的类"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">加载TestClass2</span><br><span class="line">TestClass2声明</span><br><span class="line">TestClass2实例对象</span><br><span class="line">[执行静态代码块]</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>由于在第二个版本的forName()方法中，把initialize设为了false，所以加载类时并不会马上执行静态代码块，而会在类实例对象时才去执行静态代码块代码，第二个版本的forName()方法需要一个类加载器（Class loader）。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射学习总结（一)</title>
    <url>/2017/02/18/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Java提供的反射机制允许我们在运行时期动态加载类，检测和修改它本身状态或行为，要举反射机制的一个实例的话，就是在整合开发环境中所提供的方法提示或者类的检查工具，另外像jsp中的javabean自动收集请求也用到了反射，还有我们经常用的框架也可以看到反射机制的使用，这样可以达到动态加载使用者自己定义的类的目的。<br><a id="more"></a><br>在我们拿到一个类时，即使对它一无所知，但是其实他本身就包括了很多信息，Java在需要使用某个类时才会将类加载，并在jvm中以一个<strong>java.lang.Class</strong>的实例存在，从Class实例开始，我们可以获取类的信息。</p>
<p><strong>Class类的加载</strong></p>
<p>Java在真正需要使用一个类的时候才会进行加载，而不是在程序启动时加载所有的类，因为大多数人都只使用到应用程序的部分资源，在需要某些功能时在加载某些资源，这样可以让系统的资源运用更有效率。</p>
<p>一个java.lang.Class代表了Java程序中运行时加载类或者接口的实例，也可以用来表达enum（枚举），annotation（注解），数组，基本数据类型；Class类没有public构造方法，Class是由jvm自动生成的，每当一个类被加载时，jvm就会自动生成一个Class实例。</p>
<p>我们还可以通过Object的getClass()方法来取得每一个对象对应Class实例，或者通过”class”常量，在取得Class实例之后，操作Class实例上的一些方法来取得类的基本信息，例如：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> name = <span class="string">"justdoitlee"</span>;</span><br><span class="line">        Class stringClass = name.getClass();</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"类名称："</span> +</span><br><span class="line">                stringClass.getName());</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"是否为接口："</span> +</span><br><span class="line">                stringClass.isInterface());</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"是否为基本数据类型："</span> +</span><br><span class="line">                stringClass.isPrimitive());</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"是否为数组："</span> +</span><br><span class="line">                stringClass.isArray());</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"父类名称："</span> +</span><br><span class="line">                stringClass.getSuperclass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">类名称：java.lang.String</span><br><span class="line">是否为借口：false</span><br><span class="line">是否为基本数据类型：false</span><br><span class="line">是否为数组：false</span><br><span class="line">父类名称：java.lang.Object</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这里简单的的使用 getClass() 方法来取得 String 类的 Class 实例，并从中得到 String 的一些基本信息。</p>
<p>当然，我们也可以直接使用下面的方式来取得String类的Class对象：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Class</span> stringClass = <span class="keyword">String</span>.<span class="keyword">class</span>;</span><br></pre></td></tr></table></figure>
<p>Java在真正需要类时才会加载这个类，所谓的<strong>真正需要</strong>通常指的是要使用指定的类生成对象时，或者使用指定要加载的类时，例如使用Class.forName()加载类，或者使用ClassLoader的loadClass()加载类，声明类并不会导致类的加载，可以使用一个小测试来验证。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李智</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016/12/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"类被加载"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面我们定义了一个静态代码块，假设在类第一次被加载时会执行静态代码块（说假设是因为，可以设置加载类时不执行静态代码块，使Class生成对象时才执行静态代码块），看输出信息可以看出类何时被加载(如下LoadClassTest)。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 李智</span></span><br><span class="line"><span class="comment"> * @date 2016/12/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadClassTest</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">        TestClass test = null;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"声明TestClass"</span>);</span><br><span class="line">        test = <span class="keyword">new</span> TestClass();</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"生成TestClass实例"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">声明TestClass</span><br><span class="line">类被加载</span><br><span class="line">生成TestClass实例</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>从执行结果可以看出，声明类并不会导致TestClass被加载，而是在使用new生成对象时才会被加载类。</p>
<p>Class的信息是在编译时期就被加入至.class文件的，这是Java执行时期被辨别（RTTI，Run-Time Type Information或Run-Time Type Identification）的一种方式，在编译时期编译器会先检查对应的.class文件，而执行时期jvm在使用类时，会先检查对应的Class是否已经被加载，如果没有加载，则会寻找对应的,class文件并加载，一个类在jvm中只会有一个Class实例，每个类的实例都会记得自己是由哪个Class实例所生成，我们可以使用getClass()或.class来取得Class实例。</p>
<p>另外，在Java中，数组对象也有对应的Class实例，这个对象是由具有相同元素与维度的数组所共用，而基本类型像是 boolean, byte, char, short, int, long, float, double 以及关键字 void（以前都不知道有这个呢！！），也都具有对应的Class对象，我们还可以用类常量（Class literal）来获取这些对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> CoreJava.day_2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 李智</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016/12/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">boolean</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] iarr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        System.out.println(iarr.getClass().toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span>[] darr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line">        System.out.println(darr.getClass().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">boolean</span><br><span class="line">void</span><br><span class="line">class [I</span><br><span class="line">class [D</span><br><span class="line"></span><br><span class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在Java中 数组确实是以对象的形式存在的，其对应的类都是有jvm自动生成的，当我们是用toString()来显示数组对象的描述时，[表示为数组类型，并且加上一个类型代表字，上面的I表示是一个Int的数组，d是一个double数组。</p>
<p>这里就先讲一下Class类的加载吧，后面的再总结。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>我们为什么要用Spring，SpringMVC</title>
    <url>/2017/02/18/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Spring%EF%BC%8CSpringMVC/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天被公司派到别的公司谈项目，刚去就先被面试了一波（原来是把我外包到别的公司做项目了 -。-），面试时候问了我一个问题，很简单，就是问我java开发web项目为什么要用spring,springmvc？<br><br>好吧，当时我人直接懵逼了，什么鬼问我这个！！不就是可以省去很多功夫让我们踏踏实实写业务代码嘛? <br><br><a id="more"></a><br>当时就随便回答了一些，回到公司仔细想想，发现还有挺多可以想，可以讲的。我想起了之前项目的控制层从struts2转到springmvc，我就在想为什么我们现在做javaweb开发，要用struts2或者springMVC这样的框架，而不是使用servlet加jsp这样的技术呢？特别是现在我们web的前端页面都是使用freemaker这样的模板语言进行开发，抛弃了jsp，这样的选择又会给我们javaweb开发带来什么样的好处，延着这个问题的思路，我又发现新的疑问，为什么现在很多java企业级开发都会去选择spring框架，spring框架给我们开发的应用带来了什么？这么一想我人更加糊涂了，很难找带让自己完全信服的答案。<br><br>最终我发现，这些我认为<strong>“用”</strong>的很熟悉技术，其实还有很多让我陌生不解的地方，这些陌生和不解的地方也正是我是否能更高层次使用它们的关键。</p>
<p> 首先，软件里有很多优秀的框架，有一种类型的框架，它的特点是建立在一个现有技术的基础上，提供和现有技术一样业务功能的技术框架，这个新的技术框架比原技术更加易用，更加健壮同时功能更加强大，例如常用的jQuery，以及上面提到的spring和springMVC（其实是一个啦），深究这些框架都是很复杂的，但是它们的优点其实只有一个：<strong>就是让使用者只关心核心业务的开发，框架帮你屏蔽原有技术跟业务开发无关的各类技术问题</strong>。像jQuery，springMVC这类框架之所以优秀，就是它们在这点上做的太好了，以至于很多使用它的程序员都已经不清楚原有技术的真实面目，因此我们要将springmvc理解的更好，使用的更加熟练和深入，这里我们就要跳出springmvc的技术，到springmvc技术的源头servlet，仔细研究下servlet的特点，只有这样我们才能把springmvc框架学的更好（所以才那么多人看springmvc的源码学习吧）。</p>
<p>先讲讲servlet吧，servlet的作用就是是接收浏览器传给服务端的请求（request），并将服务端处理完的响应（response）返回给用户的浏览器，浏览器和服务端之间通过http协议进行沟通，其过程是浏览器根据用户的选择将相关信息按http协议报文的规范组装请求的http报文，报文通过网络传输到指定的服务器，服务器通过特定的web容器接收这个报文信息，例如：tomcat，jetty，jboss这样的web容器，web容器会将http报文解析出来，如果是用户请求，最终解析出来的报文信息会用一个request对象存储起来，服务端使用这个request做完相应的处理后，服务端程序将结果信息封装到response对象里，然后将response对象交给web容器，web容器则把这个response对象转变为http协议的报文，并将报文回传给浏览器，浏览器最后解析这个响应报文，将最终结果展示给用户。</p>
<p>而Web容器创造了servlet接口，servlet接口就是开发人员自己实现业务逻辑的地方，程序员开发servlet就好比做填空题，而填空题的语境或者说上下文提示就是由request和response对象，但是javaEE规范里的servlet接口很简单，就三个方法init，service和destory，但是这个接口太笼统了，所以规范里还提供了一个HttpServlet类，这个类根据http请求类型提供了doGet，doPost等方法，servlet接口最大的特点就是根据http协议的特点进行定义，因此做servlet开发时候如果使用者对http协议特点不是特别熟悉，都会碰到或多或少令人迷惑的问题，特别是碰到一些复杂特殊的请求时候：例如文件上传，返回特殊的文件格式到浏览器，这时候使用servlet开发就不是很方便了，servlet开发还有个问题可能大家常常被忽视，就是请求的数据的类型转化，http协议传输都是文本形式，到了web容器解析后也是文本类型，如果碰到货币，数字，日期这样的类型需要我们根据实际情况进行转化，如果页面传送的信息非常多，我们就不得不做大量类型转化，这种工作没有什么技术含量，是个体力活而且很容易导致程序错误。</p>
<p>servlet另一个作用就是构造response对象，让页面获得正确的响应，其实现代的浏览器是一个多媒体工具，文字，图片，视屏等等东西都可以在浏览器里显示，资源的不同就会导致http响应报文的差别，如果我们使用servlet开发就要根据资源的不同在java程序里用硬编码的形式处理，这样的程序很难复用，而且如果程序员对某种资源的处理理解不到位，就会导致问题的出现。</p>
<p>而在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p>
<p>servlet里还有两个重要的技术：监听器和过滤器，对于监听器在web开发里使用的场景比较少，都是一些十分特别的情况才会使用，大部分web开发里可以忽略它的使用，我们用的最多的监听器可能就是对ServletContext创建和销毁的监听器，ServletContext是整个web应用的全局对象，它和Web应用的生命周期绑定在一起，因此使用这个监听器对Web应用的全局信息进行初始化和销毁操作，例如spring容器的初始化操作。而过滤器方面，使用SpringMVC拦截器和Struts2一样，Spring MVC也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必须实现HandlerInterceptor接口。</p>
<p><strong>下面再谈谈spring</strong><br><br>spring技术可以说是java企业开发里最重要的技术，不过真的理解spring的作用和意义还真是一件麻烦的事情，很多人对spring理解其实都是停留在使用阶段（例如：声明式事务很好用等等），当今的spring技术生态环境里可谓是蔚为壮观，spring已经包罗万象，它的内容之多完全不亚于它的本源java语言了，而spring这么大的框都是建立在ioc和aop技术之上，只有深入理解了这两个技术我们才能明白为什么spring这个框能装的下那么多东西了。</p>
<p>首先是ioc，ioc技术第一个解释叫做控制反转，它还有个解释就是依赖注入，这两个名字很难从字面理解，但是当你理解它的原理后就会发现它们的描述是何等准确。Ioc技术的本质就是构建对象的技术换句话说就是将一个类实例化成对象的技术，在java里实例化类通过new关键字进行的，每次new一个类都会产生一个新的实例对象，这么做视乎很浪费，有时这种浪费还挺危险，因为在程序开发时候我们常常只需要某个类永远只能产生一个的实例对象这个时候就得使用单例模式，此外在设计模式里还可以通过工厂方式产生对象，使用过spring的人看到上面的文字就知道了，spring里bean的定义就和上面的内容一一对应，scope属性single产生单例对象，prototype产生新对象，bean还可以通过工厂方式产生对象，可以说spring的bean就是制造对象的工具。面向对象编程里对象相当于显示生活中的一个实体，例如我们有个对象作用是完成打猎的操作，那么打猎这个对象内部包含两个辅助对象：人和枪，只有人和枪赋予了打猎这个对象，那么打猎对象才能完成打猎的操作，但是构建一个人和枪的对象并不是看起来那么简单，这里以枪为例，要创造一把枪我们需要金属，需要机床，需要子弹，而机床和子弹又是两个新对象，这些对象一个个相互嵌套相互关联，大伙试想下如果我们在java代码里构建一个枪的对象那是何其的复杂，假如我们要构造的不是简单的枪对象而是更加复杂的航空母舰，那么构造这个对象的成本之高是让人难以想象的，怎么来消除这种对象相互嵌套相互依赖的关系了？spring提供了一种方式，这种方式就是spring提供一个容器，我们在xml文件里定义各个对象的依赖关系，由容器完成对象的构建，当我们java代码里需要使用某个实例的时候就可以从容器里获取，那么对象的构建操作就被spring容器接管，所以它被称为控制反转，控制反转的意思就是本来属于java程序里构建对象的功能交由容器接管，依赖注入就是当程序要使用某个对象时候，容器会把它注入到程序里，这就叫做依赖注入。在java开发里我们想使用某个类提供的功能，有两种方式，一种就是构造一个新的类，新的类继承该类，另一种方式则是将某个类定义在新类里，那么两个类之间就建立一种关联关系，spring的ioc容器就是实现了这种关联关系（记住不是继承关系哦），那么某个类要被赋予到新类有哪些办法了？一般只有两种：一种就是通过构造函数，一种就是通过setXXX方式，这也是spring容器使用到了两种标准的注入方式。</p>
<p>不管是上面说的继承方式，还是关联方式其实都是增强目标对象能力的开发手段，在设计模式里有一种代理模式，代理模式将继承模式和关联模式结合在一起使用，代理模式就是继承模式和关联模式的综合体，不过这个综合体的作用倒不是解决对象注入的问题，而是为具体操作对象找到一个保姆或者是秘书，这就和小说里的二号首长一样，这个二号首长对外代表了具体的实例对象，实例对象的入口和出口都是通过这个二号首长，因为具体的实例对象是一号首长，一号首长是要干大事的，所以一些事务性，重复性的工作例如泡茶，安排车子，这样的工作是不用劳烦一号首长的大驾，而是二号首长帮忙解决的，这就是aop的思想，aop解决程序开发里事务性，和核心业务无关的问题，但这些问题对于业务场景的实现是很有必要的，在实际开发里aop也是节省代码的一种方式。</p>
<p>Spring的核心技术的作用本质就是一个 沟通机制，spring总是尽全力的让沟通的双方信息畅通，同时降低双方的沟通成本，在现实机构里一个善于沟通的人肯定是该公司的领导，很会沟通的领导能调动起各种资源的积极性，善于沟通的领导就会做到海纳百川，让各种不同人追随他，所以当今的spring就是一个大框，什么都可以往里装。</p>
<p>Spring很像银行，它不能直接创造物质财富，但是一切资源都要通过它进行流通，它能控制经济发展的走向，回到程序的世界，spring的作用是被标榜为程序之间的解耦，spring能降低不同模块之间的耦合度，原因就是在程序开发里不同模块之间信息的沟通是通过对象传递完成的，而对象能否顺利传递就是要合理的构建好对象，而管理好对象的构建方式就能管理好对象传递，这就是spring给系统架构设计带来的好处。</p>
<p>写啊写，找啊找，抄啊抄，结果搞了这么多。。。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的静态/动态绑定</title>
    <url>/2017/02/18/Java%E7%9A%84%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天看到《Java核心技术I》书上的动态绑定，意思就是当子类和父类存在同一个方法，子类重写了父类的方法，程序在运行时调用方法是调用父类的方法还是子类的重写方法呢？程序会在运行的时候自动选择调用某个方法（根据方法表）。<br>看完这里不由自主的想到，有动态肯定也就有静态吧，于是去求助了下google，首先看了下什么是<strong>绑定</strong>:<br>绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。<br><a id="more"></a><br>然后我们分别看看两者之间含义以及差别<br><br><strong>动态绑定</strong>：在运行时根据具体对象的类型进行绑定。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。</p>
<p><strong>动态绑定的过程</strong>：<br><br>虚拟机提取对象的实际类型的方法表；–&gt;<br>虚拟机搜索方法签名；–&gt;<br>调用方法。</p>
<p><strong>静态绑定</strong>：在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。针对java，可以简单的理解为程序编译期的绑定；这里要特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定。</p>
<p><strong>差别</strong>：其实上述解释可以看出很多东西了。<br><br>（1）静态绑定发生在编译时期，动态绑定发生在运行时<br><br>（2）使用private或static或final修饰的变量或者方法，使用静态绑定。而虚方法（可以被子类重写的方法）则会根据运行时的对象进行动态绑定。<br><br>（3）静态绑定使用类信息来完成，而动态绑定则需要使用对象信息来完成。<br><br>（4）重载(Overload)的方法使用静态绑定完成，而重写(Override)的方法则使用动态绑定完成。</p>
<p><strong>下面开始代码测试</strong>：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">String</span> str = <span class="keyword">new</span> <span class="keyword">String</span>();</span><br><span class="line">      Lee lee = <span class="keyword">new</span> Lee();</span><br><span class="line">      lee.say(str);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lee</span> &#123;</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"这是个Object"</span>);</span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">String</span> str)</span> </span>&#123;</span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"这是个String"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果</strong>：<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ java <span class="keyword">Test</span></span><br><span class="line">这是个<span class="keyword">String</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，lee方法存在两个重载的实现，一个是接收Object类型的对象作为参数，另一个则是接收String类型的对象作为参数。而str是一个String对象，所有接收String类型参数的call方法会被调用。而这里的绑定就是在编译时期根据参数类型进行的静态绑定。</p>
<p><strong>接着我们反编译验证一下</strong>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">javap</span> <span class="string">-c</span> <span class="string">Test</span>    </span><br><span class="line"><span class="string">Compiled</span> <span class="string">from</span> <span class="string">"Test.java"</span></span><br><span class="line"><span class="string">public</span> <span class="string">class</span> <span class="string">CoreJava.day_2.Test</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">public</span> <span class="string">CoreJava.day_2.Test();</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">       <span class="attr">0:</span> <span class="string">aload_0</span></span><br><span class="line">       <span class="attr">1:</span> <span class="string">invokespecial</span> <span class="comment">#1                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">       <span class="attr">4:</span> <span class="string">return</span></span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">main(java.lang.String[]);</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">       <span class="attr">0:</span> <span class="string">new</span>           <span class="comment">#2                  // class java/lang/String</span></span><br><span class="line">       <span class="attr">3:</span> <span class="string">dup</span></span><br><span class="line">       <span class="attr">4:</span> <span class="string">invokespecial</span> <span class="comment">#3                  // Method java/lang/String."&lt;init&gt;":()V</span></span><br><span class="line">       <span class="attr">7:</span> <span class="string">astore_1</span></span><br><span class="line">       <span class="attr">8:</span> <span class="string">new</span>           <span class="comment">#4                  // class CoreJava/day_2/Test$Lee</span></span><br><span class="line">      <span class="attr">11:</span> <span class="string">dup</span></span><br><span class="line">      <span class="attr">12:</span> <span class="string">invokespecial</span> <span class="comment">#5                  // Method CoreJava/day_2/Test$Lee."&lt;init&gt;":()V</span></span><br><span class="line">      <span class="attr">15:</span> <span class="string">astore_2</span></span><br><span class="line">      <span class="attr">16:</span> <span class="string">aload_2</span></span><br><span class="line">      <span class="attr">17:</span> <span class="string">aload_1</span></span><br><span class="line">      <span class="attr">18:</span> <span class="string">invokevirtual</span> <span class="comment">#6                  // Method CoreJava/day_2/Test$Lee.call:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="attr">21:</span> <span class="string">return</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>看到了这一行18: invokevirtual #6                  // Method CoreJava/day_2/Test$Lee.call:(Ljava/lang/String;)V确实是发生了静态绑定，确定了调用了接收String对象作为参数的say方法。</p>
<p><strong>现在可以改写一下</strong>：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">String</span> str = <span class="keyword">new</span> <span class="keyword">String</span>();</span><br><span class="line">      Lee lee = <span class="keyword">new</span> SecLee();</span><br><span class="line">      lee.say(str);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lee</span> &#123;</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">String</span> str)</span> </span>&#123;</span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"这是个String"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecLee</span> <span class="title">extends</span> <span class="title">Lee</span> &#123;</span></span><br><span class="line">      @Override</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">String</span> str)</span> </span>&#123;</span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"这是第二李的String"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果为</strong>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ java <span class="keyword">Test</span></span><br><span class="line">这是第二李的<span class="keyword">String</span></span><br></pre></td></tr></table></figure>
<p>上面，用SecLee继承了Lee，并且重写了say方法。我们声明了一个Lee类型的变量lee，但是这个变量指向的是他的子类SecLee。根据结果可以看出，其调用了SecLee的say方法实现，而不是Lee的say方法。这一结果的产生的原因是因为在运行时发生了动态绑定，在绑定过程中需要确定调用哪个版本的say方法实现。</p>
<p><strong>再看看反编译的结果</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">javap</span> <span class="string">-c</span> <span class="string">Test</span></span><br><span class="line"><span class="string">警告:</span> <span class="string">二进制文件Test包含CoreJava.day_2.Test</span></span><br><span class="line"><span class="string">Compiled</span> <span class="string">from</span> <span class="string">"Test.java"</span></span><br><span class="line"><span class="string">public</span> <span class="string">class</span> <span class="string">CoreJava.day_2.Test</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">public</span> <span class="string">CoreJava.day_2.Test();</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">       <span class="attr">0:</span> <span class="string">aload_0</span></span><br><span class="line">       <span class="attr">1:</span> <span class="string">invokespecial</span> <span class="comment">#1                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">       <span class="attr">4:</span> <span class="string">return</span></span><br><span class="line"></span><br><span class="line">  <span class="string">public</span> <span class="string">static</span> <span class="string">void</span> <span class="string">main(java.lang.String[]);</span></span><br><span class="line">    <span class="attr">Code:</span></span><br><span class="line">       <span class="attr">0:</span> <span class="string">new</span>           <span class="comment">#2                  // class java/lang/String</span></span><br><span class="line">       <span class="attr">3:</span> <span class="string">dup</span></span><br><span class="line">       <span class="attr">4:</span> <span class="string">invokespecial</span> <span class="comment">#3                  // Method java/lang/String."&lt;init&gt;":()V</span></span><br><span class="line">       <span class="attr">7:</span> <span class="string">astore_1</span></span><br><span class="line">       <span class="attr">8:</span> <span class="string">new</span>           <span class="comment">#4                  // class CoreJava/day_2/Test$SecLee</span></span><br><span class="line">      <span class="attr">11:</span> <span class="string">dup</span></span><br><span class="line">      <span class="attr">12:</span> <span class="string">invokespecial</span> <span class="comment">#5                  // Method CoreJava/day_2/Test$SecLee."&lt;init&gt;":()V</span></span><br><span class="line">      <span class="attr">15:</span> <span class="string">astore_2</span></span><br><span class="line">      <span class="attr">16:</span> <span class="string">aload_2</span></span><br><span class="line">      <span class="attr">17:</span> <span class="string">aload_1</span></span><br><span class="line">      <span class="attr">18:</span> <span class="string">invokevirtual</span> <span class="comment">#6                  // Method CoreJava/day_2/Test$Lee.say:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="attr">21:</span> <span class="string">return</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>正如上面的结果，18: invokevirtual #6                  // Method CoreJava/day_2/Test Lee.say:(Ljava/lang/String;)V这里是TestLee.say而非Test$SecLee.say，因为编译期无法确定调用子类还是父类的实现，所以只能丢给运行时的动态绑定来处理。</p>
<p>既然重写测试了，<strong>那我们再试试重载</strong>：</p>
<p>下面的例子更复杂！Lee类中存在say方法的两种重载，更复杂的是SecLee集成Lee并且重写了这两个方法。其实这种情况是上面两种情况的复合情况。<br>下面的代码首先会发生静态绑定，确定调用参数为String对象的say方法，然后在运行时进行动态绑定确定执行子类还是父类的say实现。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">String</span> str = <span class="keyword">new</span> <span class="keyword">String</span>();</span><br><span class="line">      Lee lee = <span class="keyword">new</span> SecLee();</span><br><span class="line">      lee.say(str);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lee</span> &#123;</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"这是Object"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">String</span> str)</span> </span>&#123;</span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"这是String"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecLee</span> <span class="title">extends</span> <span class="title">Lee</span> &#123;</span></span><br><span class="line">      @Override</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"这是第二李的Object"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      @Override</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">String</span> str)</span> </span>&#123;</span><br><span class="line">          System.out.<span class="built_in">println</span>(<span class="string">"这是第二李的String"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">$ java <span class="keyword">Test</span></span><br><span class="line">这是第二李的<span class="keyword">String</span></span><br></pre></td></tr></table></figure>
<p>结果在意料之中，就不多说了。</p>
<p>那么问题来了，<font color="red"><strong>非动态绑定不可么？</strong></font><br>其实某些方法的绑定也可以由静态绑定实现，比如说：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">      <span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">new</span> <span class="keyword">String</span>();</span><br><span class="line">      <span class="keyword">final</span> Lee lee = <span class="keyword">new</span> SecLee();</span><br><span class="line">      lee.say(<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这里lee持有SecLee的对象并且lee变量为final，立即执行了say方法，编译器理论上通过足够的分析代码，是可以知道应该调用SecLee的say方法。</p>
<p><strong>结论：</strong><br>由于动态绑定需要在运行时确定执行哪个版本的方法实现或者变量，比起静态绑定起来要耗时，所以正如书上所说的，有些程序员认为，除非有足够的理由使用多态性，应该把所有的方法都声明为final，private或者static进行修饰。我觉得这个有点偏激了，具体使用仁者见仁，智者见智吧。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>静态动态绑定</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 如何插入一列自增序号</title>
    <url>/2017/02/18/mysql-%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E4%B8%80%E5%88%97%E8%87%AA%E5%A2%9E%E5%BA%8F%E5%8F%B7/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天看到朋友问的一个问题，“mysql 加一列 叫序号 然后序号自增 怎么搞？”,由于他主要用的是oracle，所以不太了解mysql的用法，然后我就告诉他用rownum就好了，但是他说用了这个没得到效果。<br><a id="more"></a><br>我想了一下 没啥啊。他说他就想在查询结果中加一个序号列 实现自增，于是我自己建了张表实验一下。</p>
<p><img src="http://img.blog.csdn.net/20161124164205404" alt="这里写图片描述"></p>
<p>只给了id和name两个字段，方便测试。</p>
<p><img src="http://img.blog.csdn.net/20161124164414499" alt="这里写图片描述"></p>
<p>随便插入了几条数据（设置了utf-8的格式输入中文就直接???了 不知道怎么回事，估计是数据库编码有点问题，先用英文凑合一下。）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @rd := @rd+<span class="number">1</span>  <span class="keyword">as</span> <span class="keyword">rownum</span>, b.name <span class="keyword">from</span> (<span class="keyword">select</span> @rd:=<span class="number">0</span>, <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">test</span>) b</span><br></pre></td></tr></table></figure>
<p>取出name属性，然后给变量rd自增1赋给rownum，看结果：</p>
<p><img src="http://img.blog.csdn.net/20161124164635603" alt="这里写图片描述"></p>
<p>然后，然后就这么成了 -。- 用变量累加，插入有自增字段的临时表中、如果有唯一标识的字段，也可以用查询解决。</p>
]]></content>
      <categories>
        <category>数据库那点事</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>自增序号</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Ajax的cache参数的测试</title>
    <url>/2017/02/18/%E5%85%B3%E4%BA%8EAjax%E7%9A%84cache%E5%8F%82%E6%95%B0%E7%9A%84%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>&nbsp;&nbsp;其实这次做这个测试是因为和同学谈论@requestbody时引发的一个笑话，我之前一直以为ajax中的<code>dataType: &#39;json&#39;</code>是传输去后台的数据格式，后来分分钟被打脸，查了一下百度，才知道原来<code>dataType: &#39;json&#39;</code>是期望返回的数据类型，由此才发现原来ajax并没有平常用的那么简单。<br><a id="more"></a><br>首先我们来看一下什么是Ajax：<br>AJAX = 异步 JavaScript 和 XML。<br>AJAX 是一种用于创建快速动态网页的技术。<br>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br>传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。<br>有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。(以上来自w3cschool)</p>
<p>在看这些资料的过程中，一个参数引起了我的注意：<strong>cache</strong> 这个cache有true和false两个方向，<font color="red">显式的要求如果当前请求有缓存的话，直接使用缓存。如果该属性设置为 false，则每次都会向服务器请求</font>。由此我做了下面的测试：</p>
<p>首先创建一个servlet，用来接收客户端发来的请求</p>
<p>AjaxServlet.java</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AjaxServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doGet(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"进入了servlet!"</span>);</span><br><span class="line">        resp.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> out = resp.getWriter();</span><br><span class="line">        int a = <span class="number">1</span>;</span><br><span class="line">        out.print(a);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void doPost(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</span><br><span class="line">        doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里做出了标记，如果请求进来了，控制台会输出”进入了servlet”</p>
<p>然后创建一个Jsp用来发出请求：<br>ajaxTest.jsp</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">String</span> <span class="attr">path</span> = <span class="string">request.getContextPath();</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"ajaxBtn"</span> <span class="attr">value</span>=<span class="string">"点我试试~"</span>&gt;</span>点我试试~<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">"#ajaxBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">            url: <span class="string">"&lt;%=path%&gt;/AjaxServlet"</span>,</span></span><br><span class="line"><span class="actionscript">            type: <span class="string">'get'</span>,</span></span><br><span class="line"><span class="actionscript">            cache: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">            success: <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;</span></span><br><span class="line">                alert(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里点击这个按钮可以出发一个get请求，我们把cache设置为了true，这样会在浏览器缓存中加载请求信息。</p>
<p><img src="http://img.blog.csdn.net/20161123204951948" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20161123205002870" alt><br></p>
<p>可以看出第一次成功进入了servlet，前台也alert出了这个返回的值。</p>
<p>接着我们点击第二次，发现居然还是进入了servlet!!!!!<br><br><img src="http://img.blog.csdn.net/20161123205119785" alt="这里写图片描述"><br><br><br>这是怎么回事呢？ 没办法只能继续踏上百度谷歌之路，经过查找发现，在IE浏览器下，可以实现这个功能，点击两次，第二次就不再进入servlet了。<br><br><img src="http://img.blog.csdn.net/20161123205002870" alt><br><br><br>不过，并不鼓励使用cache:true,因为ajax是实时获取数据的，所以不太适合从缓存中加载信息，我想也正是因为这个原因，谷歌 safari浏览器实现不了这个功能吧，那么问题来了为什么ie还可以这么坚挺？（日常吐槽）。</p>
<p>附：ajax其他参数<br><br><strong>参数：</strong><br>url: 要求为String类型的参数，（默认为当前页地址）发送请求的地址。<br>type: 要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。<br>timeout: 要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。<br>async：要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。<br>cache：要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false）。设置为false将不会从浏览器缓存中加载请求信息。<br>data: 要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看processData选项。对象必须为key/value格<br> 式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。<br>dataType: 要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。<br>          可用的类型如下：<br><br>          xml：返回XML文档，可用JQuery处理。<br><br>          html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。<br><br>          script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。<br><br>          json：返回JSON数据。<br><br>          jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。<br><br>          text：返回纯文本字符串。<br>beforeSend：要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义。<br>            HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM常量池及字符串==比较分析</title>
    <url>/2017/02/18/JVM%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>java中的常量池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有的话就创建一个），这样在我们需要重复创建相等变量节省了很多时间。<br><br>&nbsp;&nbsp;常量池其实也就是一个内存空间，不同于使用new关键字创建的对象所在的堆空间。String类是java中用的比较多的类，同样为了创建String对象的方便，该类也实现了常量池的技术。<br><br><a id="more"></a><br>在讲述常量池之前，我们有必要先说说<font color="red">JVM运行时数据区的内存模型</font>。<br><br>JVM运行时数据区的内存模型由五部分组成:<br><br>1.方法区<br>2.堆<br>3.JAVA栈<br>4.PC寄存器<br>5.本地方法栈</p>
<p>例如对于<figure class="highlight plain"><figcaption><span>s </span></figcaption><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">0:   ldc     #16; //String haha    </span><br><span class="line">2:   astore_1 </span><br><span class="line">3:   return</span><br></pre></td></tr></table></figure></p>
<p>从上面的ldc指令的执行过程可以得出：s的值是来自被拘留String对象（由解析该入口的进程产生）的引用，即可以理解为是从被拘留String对象的引用复制而来的，故我个人的理解是s的值是存在栈当中。上面是对于s值得分析，接着是对于”haha”值的分析,我们知道，对于String s = “haha” 其中”haha”值在JAVA程序编译期就确定下来了的。简单一点说，就是haha的值在程序编译成class文件后，就在class文件中生成了。执行JAVA程序的过程中，第一步是class文件生 成，然后被JVM装载到内存执行。那么JVM装载这个class到内存中，其中的haha这个值，在内存中是怎么为其开辟空间并存储在哪个区域中呢？</p>
<p>&nbsp;&nbsp;首先我们不妨先来了解一下JVM常量池这个结构,这里我查询了一些资料,在资料中这样描述<strong>常量池</strong>:<br><br>虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和 floating point常量）和对其他类型，字段和方法的符号引用。对于String常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的，对于String类型，有一张固定长度的CONSTANT_String_info表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。</p>
<p>下面讲讲<strong>八种基本类型的包装类和对象池</strong></p>
<p>Java中基本类型的包装类的大部分都实现了常量池技术，这些类是 Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外 Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。一些对应的测试代码：<br><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line"><span class="comment">//5种整形的包装类Byte,Short,Integer,Long,Character的对象，</span></span><br><span class="line"><span class="comment">//在值小于127时可以使用常量池</span></span><br><span class="line">        Integer i1 = <span class="number">127</span>;</span><br><span class="line">        Integer i2 = <span class="number">127</span>;</span><br><span class="line">        Sstem.out.<span class="keyword">println</span>(i1 == i2); <span class="comment">//输出true  </span></span><br><span class="line"><span class="comment">//值大于127时，不会从常量池中取对象</span></span><br><span class="line">        Integer i3 = <span class="number">128</span>;</span><br><span class="line">        Integer i4 = <span class="number">128</span>;</span><br><span class="line">        System.out.<span class="keyword">println</span>(i3 == i4); <span class="comment">//输出false  </span></span><br><span class="line"><span class="comment">//Boolean类也实现了常量池技术</span></span><br><span class="line">        <span class="keyword">Boolean</span> bool1 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">Boolean</span> bool2 = <span class="keyword">true</span>;</span><br><span class="line">        System.out.<span class="keyword">println</span>(bool1 == bool2); <span class="comment">//输出true  </span></span><br><span class="line"><span class="comment">//浮点类型的包装类没有实现常量池技术</span></span><br><span class="line">        <span class="keyword">Double</span> d1 = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">Double</span> d2 = <span class="number">1.0</span>;</span><br><span class="line">        System.out.<span class="keyword">println</span>(d1 == d2); <span class="comment">//输出false  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>对Integer对象的代码补充</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">       <span class="keyword">if</span> (i &gt;= <span class="number">-128</span> &amp;&amp; i &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + offset];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>当你直接给一个Integer对象一个int值的时候，其实它调用了valueOf方法，然后你赋的这个值很特别，是128，那么没有进行cache方法，相当于new了两个新对象。所以问题中定义a、b的两句代码就类似于：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Integer</span> a = <span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Integer</span> b = <span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">128</span>);</span><br></pre></td></tr></table></figure>
<p>这个时候再问你，输出结果是什么？你就知道是false了。如果把这个数换成127，再执行：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">Integer <span class="attr">a</span> = <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">Integer <span class="attr">b</span> = <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="attr">a</span> == b);</span><br><span class="line"></span><br><span class="line">结果就是：<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>进行对象比较时最好还是使用equals，便于按照自己的目的进行控制。这里引出equals()和= =,equals比较的是字符串字面值即比较内容,==比较引用。</p>
<p><strong>看一下IntegerCache这个类里面的内容：</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[] = <span class="keyword">new</span> Integer[-(<span class="number">-128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</span><br><span class="line">                cache[i] = <span class="keyword">new</span> Integer(i - <span class="number">128</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>由于cache[]在IntegerCache类中是静态数组，也就是只需要初始化一次，即static{……}部分，所以，如果Integer 对象初始化时是-128~127的范围，就不需要再重新定义申请空间，都是同一个对象—在IntegerCache.cache中，这样可以在一定程度上提高效率。</p>
<p><strong>针对String方面的补充</strong></p>
<p>在同包同类下,引用自同一String对象.<br><br>在同包不同类下,引用自同一String对象.<br><br>在不同包不同类下,依然引用自同一String对象.<br><br>在编译成.class时能够识别为同一字符串的,自动优化成常量,所以也引用自同一String对象.<br><br>在运行时创建的字符串具有独立的内存地址,所以不引用自同一String对象.<br><br>String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,<br><br>如果有则返回一个引用,没有则添加自己的字符串进入常量池，注意：只是字符串部分。 所以这时会存在2份拷贝，常量池的部分被String类私有并管理，自己的那份按对象生命周期继续使用。</p>
<p>在介绍完JVM常量池的相关概念后，接着谈开始提到的”haha”的值的内存分布的位置。对于haha的值，实际上是在class文件被JVM装载到内存 当中并被引擎在解析ldc指令并执行ldc指令之前，JVM就已经为haha这个字符串在常量池的CONSTANT_String_info表中分配了空 间来存储haha这个值。既然haha这个字符串常量存储在常量池中，根据《深入JAVA虚拟机》书中描述：常量池是属于类型信息的一部分，类型信息也就 是每一个被转载的类型，这个类型反映到JVM内存模型中是对应存在于JVM内存模型的方法区中，也就是这个类型信息中的常量池概念是存在于在方法区中，而 方法区是在JVM内存模型中的堆中由JVM来分配的。所以，haha的值是应该是存在堆空间中的。</p>
<p>而对于<figure class="highlight plain"><figcaption><span>s </span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>0:   new     #16; //class String<br>3:   dup<br>4:   ldc     #18; //String haha<br>6:   invokespecial   #20; //Methodjava/lang/String.””:(Ljava/lang/String;)V<br>9:   astore_1<br>10:  return<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">&lt;br&gt;</span><br><span class="line">通过上面<span class="number">6</span>个指令，可以看出，<span class="keyword">String</span> s = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"haha"</span>);中的haha存储在堆空间中，而s则是在操作数栈中。 </span><br><span class="line">上面是对s和haha值的内存情况的分析和理解；那对于<span class="keyword">String</span> s = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"haha"</span>);语句,到底创建了几个对象呢? </span><br><span class="line">我的理解：这里<span class="string">"haha"</span>本身就是常量池中的一个对象，而在运行时执行<span class="keyword">new</span> <span class="keyword">String</span>()时，将常量池中的对象复制一份放到堆中，并且把堆中的这个对象的引用交给s持有。所以这条语句就创建了<span class="number">2</span>个<span class="keyword">String</span>对象。如下图所示：&lt;br&gt;</span><br><span class="line">&lt;img src=<span class="string">"http://static.open-open.com/lib/uploadImg/20121021/20121021191840_830.jpg"</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**<span class="keyword">String</span> 常量池问题的几个例子：**&lt;br&gt;</span><br><span class="line">【<span class="number">1</span>】</span><br></pre></td></tr></table></figure></p>
<p>String a = “a1”;<br>String b = “a” + 1;<br>System.out.println((a == b)); //result = true<br>String a = “atrue”;<br>String b = “a” + “true”;<br>System.out.println((a == b)); //result = true<br>String a = “a3.4”;<br>String b = “a” + 3.4;<br>System.out.println((a == b)); //result = true<br><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">分析：JVM对于字符串常量的<span class="string">"+"</span>号连接，将程序编译期，JVM就将常量字符串的<span class="string">"+"</span>连接优化为连接后的值，拿<span class="string">"a"</span> + <span class="number">1</span>来说，经编译器优化后在<span class="class"><span class="keyword">class</span>中就已经是<span class="title">a1</span>。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为<span class="title">true</span>。&lt;br&gt;</span></span><br><span class="line"></span><br><span class="line">【<span class="number">2</span>】</span><br></pre></td></tr></table></figure></p>
<p>String a = “ab”;<br>String bb = “b”;<br>String b = “a” + bb;<br>System.out.println((a == b)); //result = false<br><figure class="highlight smalltalk"><table><tr><td class="code"><pre><span class="line">分析：<span class="type">JVM</span>对于字符串引用，由于在字符串的<span class="comment">"+"</span>连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即<span class="comment">"a"</span> + bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为<span class="keyword">false</span>。</span><br><span class="line"></span><br><span class="line">【<span class="number">3</span>】</span><br></pre></td></tr></table></figure></p>
<p>String a = “ab”;<br>final String bb = “b”;<br>String b = “a” + bb;<br>System.out.println((a == b)); //result = true<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">分析：和[<span class="number">3</span>]中唯一不同的是bb字符串加了<span class="keyword">final</span>修饰，对于<span class="keyword">final</span>修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或 嵌入到它的字节码流中。所以此时的<span class="string">"a"</span> + bb和<span class="string">"a"</span> + <span class="string">"b"</span>效果是一样的。故上面程序的结果为<span class="literal">true</span>。</span><br><span class="line"></span><br><span class="line">【<span class="number">4</span>】</span><br></pre></td></tr></table></figure></p>
<p>String a = “ab”;<br>final String bb = getBB();<br>String b = “a” + bb;<br>System.out.println((a == b)); //result = false<br>private static String getBB() {<br>return “b”;<br>}<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">分析：JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和<span class="string">"a"</span>来动态连接并分配地址为b，故上面程序的结果为<span class="keyword">false</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过上面<span class="number">4</span>个例子可以得出得知：&lt;<span class="keyword">br</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>String  s  =  “a” + “b” + “c”;等价于String s = “abc”</p>
<p>这个就不一样了，最终结果等于:<br>StringBuffer temp = new StringBuffer();<br>temp.append(a).append(b).append(c);<br>String s = temp.toString();<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">由上面的分析结果，可就不难推断出<span class="keyword">String</span> 采用连接运算符（+）效率低下原因分析，形如这样的代码：</span><br></pre></td></tr></table></figure></p>
<p> public static void main(String args[]) {<br>        String s = null;<br>        for (int i = 0; i &lt; 100; i++) {<br>            s += “a”;<br>        }<br>    }<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">每做一次 + 就产生个StringBuilder对象，然后<span class="built_in">append</span>后就扔掉。下次循环再到达时重新产生个StringBuilder对象，然后 <span class="built_in">append</span> 字符串，如此循环直至结束。 如果我们直接采用 StringBuilder 对象进行 <span class="built_in">append</span> 的话，我们可以节省 N - <span class="number">1</span> 次创建和销毁对象的时间。所以对于在循环中要进行字符串连接的应用，一般都是用StringBuffer或StringBulider对象来进行 <span class="built_in">append</span>操作。</span><br><span class="line"></span><br><span class="line">最后贴一个<span class="keyword">String</span>对象的intern方法理解和分析，这是今天在群里看到的一个题目，也可以说是这篇博客的印子吧：</span><br></pre></td></tr></table></figure></p>
<p>public class Test {<br>    private static String a = “ab”;<br>    public static void main(String[] args) {<br>        String s1 = “a”;<br>        String s2 = “b”;<br>        String s = s1 + s2;<br>        System.out.println(s == a);//false<br>        System.out.println(s.intern() == a);//true<br>    }<br>}<br><code>`</code></p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
        <tag>常量池</tag>
      </tags>
  </entry>
  <entry>
    <title>关于多线程的饥饿和公平</title>
    <url>/2017/02/18/%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A5%A5%E9%A5%BF%E5%92%8C%E5%85%AC%E5%B9%B3/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>偶然学习到多线程，看到多线程的饥饿和公平，觉得可以写点什么。<br><br>什么是饥饿什么是公平呢？如果一个线程因为CPU运行时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。解决饥饿的方案被称之为“公平性”，即所有线程均能公平地获得运行机会。<br><br><a id="more"></a><br>&nbsp;&nbsp;<strong>首先我们要知道，什么原因导致了“饥饿”？在Java方面我觉的分为了三种情况:</strong><br><br>&nbsp;&nbsp;①.线程中高优先级的吞噬所有的低优先级的CPU时间。<br><br>&nbsp;&nbsp;你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。所以对大多数应用来说，你最好是不要改变其优先级值。<br><br>&nbsp;&nbsp;②线程被永久堵塞在一个等待进入同步块的状态<br><br>&nbsp;&nbsp;Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。<br><br>&nbsp;&nbsp;③.线程被永久堵塞在一个等待进入同步块的状态<br><br>&nbsp;&nbsp;如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
<p>&nbsp;&nbsp;<strong>如何在Java中实现公平？</strong><br>无论哪里都不可能实现100%公平，所以我们只能提出比较好的方案来达到目的，首先可以通过同步结构来实现公平性的提高。<br><br>先来一段简单的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronizer</span></span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSynchronized</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="comment">//需要运行很长时间的某些代码</span></span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;如果有多个线程调用了doSynchronized()方法，在第一个获得访问的线程未完成前，其他线程将一直处于阻塞状态，而且在这种多线程被阻塞的场景下，接下来将是哪个线程获得访问是没有保障的。<br><br>&nbsp;&nbsp;<strong>现在我们使用<font color="red">锁方式替代同步块</font>来试试:</strong><br><br><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Synchronizer</span>&#123;  </span><br><span class="line">  Lock <span class="keyword">lock</span> = <span class="keyword">new</span> Lock();   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSynchronized</span>(<span class="params"></span>) throws InterruptedException</span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">lock</span>.<span class="keyword">lock</span>();  <span class="comment">//当前线程锁住lock对象  </span></span><br><span class="line">      <span class="comment">//时间临界区</span></span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">lock</span>.unlock();  <span class="comment">//当前线程释放lock对象上的锁  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;我们可以注意到doSynchronized()不再声明为synchronized，而是用lock.lock()和lock.unlock()来替代。<br>下面是用Lock类做的一个实现:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked      = <span class="keyword">false</span>;  <span class="comment">//是否加过锁的信号  </span></span><br><span class="line">  <span class="keyword">private</span> Thread  lockingThread = <span class="keyword">null</span>;   <span class="comment">//进行加锁的线程  </span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(isLocked)&#123;  <span class="comment">//如果lock对象已被其他线程加锁了（线程已经退出了本lock()方法）  </span></span><br><span class="line">      wait();  <span class="comment">//当前线程阻塞，它释放锁对象上的锁，其他线程可以再进入本lock()  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    isLocked = <span class="keyword">true</span>;  <span class="comment">//如果没加锁，则当前线程对锁对象加锁  </span></span><br><span class="line">    lockingThread = Thread.currentThread();  </span><br><span class="line">  &#125;  </span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.lockingThread != Thread.currentThread())&#123;  <span class="comment">//如果调用lock()加锁的不是当前线程  </span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(  </span><br><span class="line">        <span class="string">"所调用线程尚未锁定"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    isLocked = <span class="keyword">false</span>;  <span class="comment">//释放锁，标记为未加锁  </span></span><br><span class="line">    lockingThread = <span class="keyword">null</span>;  </span><br><span class="line">    notify();  <span class="comment">//通知阻塞在锁对象上的线程队列，唤醒其中某一个线程  </span></span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;注意到上面对Lock的实现，如果存在多线程并发访问lock()，这些线程将阻塞在对lock()方法的访问上。另外，如果isLocked=true时，表示锁已被锁上，这些线程将阻塞在while(isLocked)循环的wait()调用里面。要注意的是，当线程正在等待进入lock() 时，可以调用wait()释放其锁实例对应的同步锁，使得其他多个线程可以进入lock()方法，并调用wait()方法。<br><br>&nbsp;&nbsp;我们回头看doSynchronized()方法，可以看到在lock()和unlock()之间：一段代码将长时间运行，和进入lock()并调用wait()来比较的话。这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。<br><br>&nbsp;&nbsp;由于同步块不会对等待进入的多个线程谁能获得访问做任何保障，同样当调用notify()时，wait()也不会做保障一定能唤醒线程。因此这个版本的Lock类和doSynchronized()那个版本就保障公平性而言，没有任何区别。<br><br>&nbsp;&nbsp;但我们能改变这种情况。当前的Lock类版本调用自己的wait()方法，如果每个线程在不同的对象上调用wait()，那么只有一个线程会在该对象上调用wait()，Lock类可以决定哪个对象能对其调用notify()，因此能做到有效的选择唤醒哪个线程。<br><br>&nbsp;&nbsp;<strong>下面看看如何把Lock类转变为公平锁FairLock</strong>。<br><br>&nbsp;&nbsp;新的实现和之前的Lock类中的同步和wait()/notify()将会稍有不同。<br>每一个调用lock()的线程都会进入一个队列，当解锁后，只有队列里的第一个线程被允许锁住FairLock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;  <span class="comment">//是否加锁的信号  </span></span><br><span class="line">    <span class="keyword">private</span> Thread lockingThread = <span class="keyword">null</span>;   <span class="comment">//加锁的线程  </span></span><br><span class="line">    <span class="keyword">private</span> List&lt;QueueObject&gt; waitingThreads =  </span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;QueueObject&gt;();   <span class="comment">//信号量队列  </span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;  <span class="comment">//多个线程可同时进入  </span></span><br><span class="line">    QueueObject queueObject = <span class="keyword">new</span> QueueObject();  <span class="comment">//局部对象，线程安全  </span></span><br><span class="line">    <span class="keyword">boolean</span> isLockedForThisThread = <span class="keyword">true</span>;  <span class="comment">//是否为当前线程加锁  </span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;  <span class="comment">//将当前线程（用信号量）推入队列  </span></span><br><span class="line">        waitingThreads.add(queueObject);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(isLockedForThisThread)&#123;  </span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;  <span class="comment">//加锁操作需要同步  </span></span><br><span class="line">          <span class="comment">//锁状态依然被检查和设置，以避免出现滑漏条件  </span></span><br><span class="line">          isLockedForThisThread = isLocked || waitingThreads.get(<span class="number">0</span>) != queueObject;  </span><br><span class="line">          <span class="keyword">if</span>(!isLockedForThisThread)&#123; <span class="comment">//如果对象未加锁且队列头部是当前线程  </span></span><br><span class="line">              isLocked = <span class="keyword">true</span>; <span class="comment">//加锁  </span></span><br><span class="line">              waitingThreads.remove(queueObject); <span class="comment">//从队列中移除当前线程  </span></span><br><span class="line">              lockingThread = Thread.currentThread(); <span class="keyword">return</span>;   </span><br><span class="line">          &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">try</span>&#123; <span class="comment">//放在同步块之外，避免monitor嵌套锁死   </span></span><br><span class="line">            queueObject.doWait(); <span class="comment">//监视器对象（持有信号量isNotified）等待  </span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;   </span><br><span class="line">           <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; waitingThreads.remove(queueObject); &#125;   </span><br><span class="line">            <span class="keyword">throw</span> e;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">  &#125;   </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;   </span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.lockingThread != Thread.currentThread())&#123; <span class="comment">//加锁的不是当前线程   </span></span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException( <span class="string">"该线程尚未锁"</span>);   </span><br><span class="line">      &#125;   </span><br><span class="line">      isLocked = <span class="keyword">false</span>; <span class="comment">//解锁   </span></span><br><span class="line">      lockingThread = <span class="keyword">null</span>;   </span><br><span class="line">      <span class="keyword">if</span>(waitingThreads.size() &gt; <span class="number">0</span>)&#123; <span class="comment">//唤醒第一个线程   </span></span><br><span class="line">          waitingThreads.get(<span class="number">0</span>).doNotify();   </span><br><span class="line">      &#125;   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueObject</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isNotified = <span class="keyword">false</span>;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(!isNotified)&#123;  </span><br><span class="line">        <span class="keyword">this</span>.wait();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">this</span>.isNotified = <span class="keyword">false</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.isNotified = <span class="keyword">true</span>;  </span><br><span class="line">    <span class="keyword">this</span>.notify();  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == o;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;首先注意到lock()方法不再声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。<br><br>&nbsp;&nbsp;FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程都将其QueueObject实例推入队列。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。<br><br>&nbsp;&nbsp;请注意，<font color="red">在同一个同步块中，锁状态依然被检查和设置，以避免出现滑漏条件</font>。<br><br>&nbsp;&nbsp;还需注意到，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以进入unlock()来解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。<br><br>&nbsp;&nbsp;最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。<br><br><strong>性能考虑<br></strong><br>&nbsp;&nbsp;如果比较Lock和FairLock类，你会注意到在FairLock类中lock()和unlock()还有更多需要深入的地方。这些额外的代码会导致FairLock的同步机制实现比Lock要稍微慢些。究竟存在多少影响，还依赖于应用在FairLock临界区执行的时长。执行时长越大，FairLock带来的负担影响就越小，当然这也和代码执行的频繁度相关。</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>饥饿</tag>
        <tag>公平</tag>
      </tags>
  </entry>
  <entry>
    <title>实验插入b站h5播放器</title>
    <url>/2017/02/18/%E5%AE%9E%E9%AA%8C%E6%8F%92%E5%85%A5b%E7%AB%99h5%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Hexo 插 B 站的播放器很简单，在 md 文档中插个 iframe 标签就行，aid 和 cid 值需要手动填写，播放器大小可以自己调节：</p>
<blockquote>
<p>B 站每个视频都有对应的 aid 和 cid 值，在视频网页的源代码中可以找到</p>
</blockquote>
<a id="more"></a>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=<span class="string">"https://www.bilibili.com/html/html5player.html?aid=3521416&amp;cid=6041635"</span> <span class="built_in">width</span>=<span class="string">"960"</span> <span class="built_in">height</span>=<span class="string">"600"</span> frameborder=<span class="string">"0"</span> webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>
<p><br></p>
<iframe src="https://www.bilibili.com/html/html5player.html?aid=3521416&cid=6041635" width="960" height="600" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>小插件</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM虚拟机关于“不使用的对象手动赋值为null”的理解</title>
    <url>/2017/02/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B3%E4%BA%8E%E2%80%9C%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%8B%E5%8A%A8%E8%B5%8B%E5%80%BC%E4%B8%BAnull%E2%80%9D%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>今天逛博客,看到了一个关于<code>一个对象有没有必要手动赋值为null</code>的问题，捋了捋思路，决定写个测试代码来实践一下。<br><a id="more"></a><br><br><br>百说不如一用，直接上代码:<br><br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//作用就是向内存中填充一个10MB的对象</span></span><br><span class="line">		System.gc();<span class="comment">//手动执行GC操作</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序前，可以将JVM参数设置为如下:<br><br>-verbose:gc<br><br>-XX:+PrintGCDetails<br><br>控制台部分输出结果如下:<br><br><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">[<span class="name">GC</span> (<span class="name">System.gc</span>()) [<span class="name">PSYoungGen:</span> <span class="number">3932</span>K-&gt;744K(<span class="name">76288K</span>)] <span class="number">69468</span>K-&gt;66288K(<span class="name">251392K</span>), <span class="number">0.0016500</span> secs] [<span class="name">Times:</span> user=0.00 sys=0.03, real=0.00 secs] </span><br><span class="line">[<span class="name">Full</span> GC (<span class="name">System.gc</span>()) [<span class="name">PSYoungGen:</span> <span class="number">744</span>K-&gt;0K(<span class="name">76288K</span>)] [<span class="name">ParOldGen:</span> <span class="number">65544</span>K-&gt;66145K(<span class="name">175104K</span>)] <span class="number">66288</span>K-&gt;66145K(<span class="name">251392K</span>), [<span class="name">Metaspace:</span> <span class="number">3169</span>K-&gt;3169K(<span class="name">1056768K</span>)], <span class="number">0.0101306</span> secs] [<span class="name">Times:</span> user=0.00 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure></p>
<p>根据ParOldGen: 65544K-&gt;66145K(175104K)可以看出，bytes对象并没有因为没有使用而被gc回收。<br><br><br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * -verbose:GC</span></span><br><span class="line"><span class="comment">	 * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">	 * @param args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		&#123;</span><br><span class="line">	           <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		System.gc();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>控制台输出结果如下:<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">[GC (System<span class="number">.</span>gc()) [PSYoungGen: 3932K-&gt;776K(76288K)] 69468K-&gt;66320K(251392K), <span class="number">0.0013737</span> secs] [<span class="built_in">Times</span>: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full GC (System<span class="number">.</span>gc()) [PSYoungGen: 776K-&gt;0K(76288K)] [ParOldGen: 65544K-&gt;66145K(175104K)] 66320K-&gt;66145K(251392K), [Metaspace: 3169K-&gt;3169K(1056768K)], <span class="number">0.0063873</span> secs] [<span class="built_in">Times</span>: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [<span class="number">0x000000076b500000</span>, <span class="number">0x0000000770a00000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">1</span>% used [<span class="number">0x000000076b500000</span>,<span class="number">0x000000076b5a3ee8</span>,<span class="number">0x000000076f500000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076f500000</span>,<span class="number">0x000000076f500000</span>,<span class="number">0x000000076ff80000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076ff80000</span>,<span class="number">0x000000076ff80000</span>,<span class="number">0x0000000770a00000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 66145K [<span class="number">0x00000006c1e00000</span>, <span class="number">0x00000006cc900000</span>, <span class="number">0x000000076b500000</span>)</span><br><span class="line">  object space 175104K, <span class="number">37</span>% used [<span class="number">0x00000006c1e00000</span>,<span class="number">0x00000006c5e987b8</span>,<span class="number">0x00000006cc900000</span>)</span><br><span class="line"> Metaspace       used 3176K, capacity 4494K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 346K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure></p>
<p>可以看出，根据gc日志[ParOldGen: 65544K-&gt;66145K(175104K)] ，gc依然没有回收bytes对象，哪怕已经不在方法区了，我们再次修改代码。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * -verbose:GC</span></span><br><span class="line"><span class="comment">	 * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">	 * @param args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>gc日志输出如下:<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">[GC (System<span class="number">.</span>gc()) [PSYoungGen: 3932K-&gt;776K(76288K)] 69468K-&gt;66320K(251392K), <span class="number">0.0014193</span> secs] [<span class="built_in">Times</span>: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full GC (System<span class="number">.</span>gc()) [PSYoungGen: 776K-&gt;0K(76288K)] [ParOldGen: 65544K-&gt;609K(175104K)] 66320K-&gt;609K(251392K), [Metaspace: 3169K-&gt;3169K(1056768K)], <span class="number">0.0076485</span> secs] [<span class="built_in">Times</span>: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [<span class="number">0x000000076b500000</span>, <span class="number">0x0000000770a00000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">1</span>% used [<span class="number">0x000000076b500000</span>,<span class="number">0x000000076b5a3ee8</span>,<span class="number">0x000000076f500000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076f500000</span>,<span class="number">0x000000076f500000</span>,<span class="number">0x000000076ff80000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076ff80000</span>,<span class="number">0x000000076ff80000</span>,<span class="number">0x0000000770a00000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 609K [<span class="number">0x00000006c1e00000</span>, <span class="number">0x00000006cc900000</span>, <span class="number">0x000000076b500000</span>)</span><br><span class="line">  object space 175104K, <span class="number">0</span>% used [<span class="number">0x00000006c1e00000</span>,<span class="number">0x00000006c1e987a8</span>,<span class="number">0x00000006cc900000</span>)</span><br><span class="line"> Metaspace       used 3176K, capacity 4494K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 346K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure></p>
<p>见证奇迹的时候到，[ParOldGen: 65544K-&gt;609K(175104K)]，竟然被回收了！这是为什么？当创建bytes对象的时候，那是因为当我们创建bytes对象的时候，局部变量表中当然有bytes的引用，哪怕我们没有使用，但GC roots依然存在着和bytes对象的关联。根据test2和代码test3，我们大概可以猜到如果不操作局部变量表，那么GC roots依然会保留，所以test2依然没有回收，但是到了test3，就回收了。好吧，再来一个无用的测试，我们手动赋值为null看看结果。<br><br><br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> &#123;</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * -verbose:GC</span></span><br><span class="line"><span class="comment">	 * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">	 * @param args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">		<span class="comment">//do something</span></span><br><span class="line">		bytes = null;</span><br><span class="line">		System.gc();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实都能想到，果然被gc干掉了……当然这只是一个实验，总结性的话就不说了，反正我也说不来，不过实践出真理！</p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jvm</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>黑车司机发车器Java版</title>
    <url>/2017/02/18/%E9%BB%91%E8%BD%A6%E5%8F%B8%E6%9C%BA%E5%8F%91%E8%BD%A6%E5%99%A8Java%E7%89%88/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>既然是发的黑车，磁力链接那套就不必仔细研究了，<br>磁力链接其实类似于这样（下面的这个是真车）：</p>
<blockquote>
<p>magnet:?xt=urn:btih:3AEA94481B0A406C66083F14C6F42635C14562C2</p>
</blockquote>
<a id="more"></a>
<p>说白了就是随机填充 40 个字母或数字，不过有一定几率会发出真车。</p>
<p> <img src="https://ooo.0o0.ooo/2016/12/25/585f760101362.png " width="300" height="300" alt="图片名称" align="center"></p>
<hr>

<p>代码实现：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldDriver</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		java.util.Scanner input = <span class="keyword">new</span> java.util.Scanner(System.in);</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="string">"黑车司机虚假磁力链接发车器"</span>);</span><br><span class="line">		System.out.<span class="built_in">print</span>(<span class="string">"输入需要发的黑车数量："</span>);</span><br><span class="line">		<span class="keyword">int</span> ljs = input.nextInt();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ljs;i++)&#123;</span><br><span class="line">			System.out.<span class="built_in">println</span>(<span class="string">"magnet:?xt=urn:btih:"</span>+CLSC());</span><br><span class="line"><span class="comment">/*调用 CLSC 函数，获取 40 个随机生成的字符串（CLSC指 磁力生成）*/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> <span class="title">CLSC</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">String</span> cllj = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">String</span> randomchar;</span><br><span class="line">		<span class="keyword">String</span> chars = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> RandomNumber = (<span class="keyword">int</span>)(Math.<span class="built_in">random</span>()*<span class="number">35</span>);</span><br><span class="line"><span class="comment">/*随机生成一个范围在 [0,35] 的数字*/</span></span><br><span class="line">			randomchar = <span class="string">""</span> + chars.charAt(RandomNumber);</span><br><span class="line"><span class="comment">/*随机选择一个字符，字符位置由上一步随机数字决定*/</span></span><br><span class="line">			cllj = cllj+randomchar;</span><br><span class="line"><span class="comment">/*将随机字符附到 cllj 字符串上，重复 40 次*/</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cllj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行效果：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">黑车司机虚假磁力链接发车器</span><br><span class="line">输入需要发的黑车数量：<span class="number">5</span></span><br><span class="line"><span class="string">magnet:</span>?xt=urn:<span class="string">btih:</span><span class="number">126</span>XT8JCPZ6ZWV1Q77OSOAD2P2UOWOAZEIGNN0UH</span><br><span class="line"><span class="string">magnet:</span>?xt=urn:<span class="string">btih:</span>VEKIXXTDDC6STSZN2IS1IQSW6RHJ6ZGC7NEGYIAJ</span><br><span class="line"><span class="string">magnet:</span>?xt=urn:<span class="string">btih:</span>G8Z7O3AIGY2C1PRRNJEZ6Q1VY3HGZQ34E2MOQUWR</span><br><span class="line"><span class="string">magnet:</span>?xt=urn:<span class="string">btih:</span>MRXYGZUFONLDPN5G4E5EDCWMWLI00PB8ZVK6IIKQ</span><br><span class="line"><span class="string">magnet:</span>?xt=urn:<span class="string">btih:</span><span class="number">3</span>WQ1IYXW0MD3Z32DT80NCJBLTAJ0FC837TB2HW2M</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>黑车</tag>
        <tag>种子</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2017/02/17/Hello-Hexo/</url>
    <content><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>本博客由 Hexo 强力驱动，托管于 Github ，支持 https 。</p>
<a id="more"></a>
<p>早就有自己建博客的念头了，先前在把csdn和简书作为博客，写了有大半年吧，后来学生计划买了个云服务器，用ghost搭建了一个博客，但是太简洁了！！ 于是昨天天花了大半天的时间终于搞好了这个博客。</p>
<p>之后会将简书上的文章搬运过来，Markdown 语法的文章复制一下就行，富文本写的，还得转成 Markdown 语法。（csdn的Markdown复制十分好用！）</p>
<p>博客与csdn将同步更新，两边的留言都会认真回复，反正有(mei)的(you)是(nv)时(peng)间(you)</p>
<p> <img src="http://oa0thinbz.bkt.clouddn.com/0.jpeg " width="350" height="320" alt="图片名称" align="center"></p>
]]></content>
      <categories>
        <category>蜜汁开始</category>
      </categories>
      <tags>
        <tag>迁移</tag>
      </tags>
  </entry>
</search>
