<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">
<link href="/platelet/assets/css/platelet.css" rel="stylesheet" type="text/css">


  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="李智‘Blog">
<meta property="og:url" content="http://justdoitlee.github.io/index.html">
<meta property="og:site_name" content="李智‘Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李智‘Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://justdoitlee.github.io/">





  <title>李智‘Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/JustDoItLee" class="github-corner" aria-label="View source on Github"><svg width="92" height="92" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a>

    <style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李智‘Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">读了一些书，看了一些文章，编过一些小例程，搞了一些没有什么技术含量的开发工作。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-globe-asia">
          <a href="/rice/index.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            朋友圈
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>
    
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://justdoitlee.github.io/2021/06/30/MySQL-·-引擎特性-·-InnoDB-事务系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李智">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李智‘Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/30/MySQL-·-引擎特性-·-InnoDB-事务系统/" itemprop="url">MySQL · 引擎特性 · InnoDB 事务系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-30T14:17:31+08:00">
                2021-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  8,410
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  30分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <script src="/assets/js/APlayer.min.js"> </script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关系型数据库的事务机制因其有原子性，一致性等优秀特性深受开发者喜爱，类似的思想已经被应用到很多其他系统上，例如文件系统等。本文主要介绍InnoDB事务子系统，主要包括，事务的启动，事务的提交，事务的回滚，多版本控制，垃圾清理，回滚段以及相应的参数和监控方法。代码主要基于RDS 5.6，部分特性已经开源到AliSQL。事务系统是InnoDB最核心的中控系统，涉及的代码比较多，主要集中在trx目录，read目录以及row目录中的一部分，包括头文件和IC文件，一共有两万两千多行代码。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>事务ACID:</strong> 原子性，指的是整个事务要么全部成功，要么全部失败，对InnoDB来说，只要client收到server发送过来的commit成功报文，那么这个事务一定是成功的。如果收到的是rollback的成功报文，那么整个事务的所有操作一定都要被回滚掉，就好像什么都没执行过一样。另外，如果连接中途断开或者server crash事务也要保证会滚掉。InnoDB通过undolog保证rollback的时候能找到之前的数据。一致性，指的是在任何时刻，包括数据库正常提供服务的时候，数据库从异常中恢复过来的时候，数据都是一致的，保证不会读到中间状态的数据。在InnoDB中，主要通过crash recovery和double write buffer的机制保证数据的一致性。隔离性，指的是多个事务可以同时对数据进行修改，但是相互不影响。InnoDB中，依据不同的业务场景，有四种隔离级别可以选择。默认是RR隔离级别，因为相比于RC，InnoDB的RR性能更加好。持久性，值的是事务commit的数据在任何情况下都不能丢。在内部实现中，InnoDB通过redolog保证已经commit的数据一定不会丢失。</p>
<p><strong>多版本控制:</strong> 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p>
<p><strong>垃圾清理:</strong> 对于用户删除的数据，InnoDB并不是立刻删除，而是标记一下，后台线程批量的真正删除。类似的还有InnoDB的二级索引的更新操作，不是直接对索引进行更新，而是标记一下，然后产生一条新的。这个线程就是后台的Purge线程。此外，过期的undolog也需要回收，这里说的过期，指的是undo不需要被用来构建之前的版本，也不需要用来回滚事务。</p>
<p><strong>回滚段:</strong> 可以理解为数据页的修改链，链表最前面的是最老的一次修改，最后面的最新的一次修改，从链表尾部逆向操作可以恢复到数据最老的版本。在InnoDB中，与之相关的还有undo tablespace, undo segment, undo slot, undo log这几个概念。undo log是最小的粒度，所在的数据页称为undo page，然后若干个undo page构成一个undo slot。一个事务最多可以有两个undo slot，一个是insert undo slot, 用来存储这个事务的insert undo，里面主要记录了主键的信息，方便在回滚的时候快速找到这一行。另外一个是update undo slot，用来存储这个事务delete/update产生的undo，里面详细记录了被修改之前每一列的信息，便于在读请求需要的时候构造。1024个undo slot构成了一个undo segment。然后若干个undo segemnt构成了undo tablespace。</p>
<p><strong>历史链表:</strong> insert undo可以在事务提交/回滚后直接删除，没有事务会要求查询新插入数据的历史版本，但是update undo则不可以，因为其他读请求可能需要使用update undo构建之前的历史版本。因此，在事务提交的时候，会把update undo加入到一个全局链表(<code>history list</code>)中，链表按照事务提交的顺序排序，保证最先提交的事务的update undo在前面，这样Purge线程就可以从最老的事务开始做清理。这个链表如果太长说明有很多记录没被彻底删除，也有很多undolog没有被清理，这个时候就需要去看一下是否有个长事务没提交导致Purge线程无法工作。在InnoDB具体实现上，history list其实只是undo segment维度的，全局的history list采用最小堆来实现，最小堆的元素是某个undo segment中最小事务no对应的undopage。当这个undolog被Purge清理后，通过history list找到次小的，然后替换掉最小堆元素中的值，来保证下次Purge的顺序的正确性。</p>
<p><strong>回滚点:</strong> 又称为savepoint，事务回滚的时候可以指定回滚点，这样可以保证回滚到指定的点，而不是回滚掉整个事务，对开发者来说，这是一个强大的功能。在InnoDB内部实现中，每打一个回滚点，其实就是保存一下当前的undo_no，回滚的时候直接回滚到这个undo_no点就可以了。</p>
<h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><p>在分析核心的代码之前，先介绍一下几个核心的数据结构。这些结构贯穿整个事务系统，理解他们对理解整个InnoDB的工作原理也颇有帮助。</p>
<p><strong>trx_t:</strong> 整个结构体每个连接持有一个，也就是在创建连接后执行第一个事务开始，整个结构体就被初始化了，后续这个连接的所有事务一直复用里面的数据结构，直到这个连接断开。同时，事务启动后，就会把这个结构体加入到全局事务链表中(<code>trx_sys-&gt;mysql_trx_list</code>)，如果是读写事务，还会加入到全局读写事务链表中(<code>trx_sys-&gt;rw_trx_list</code>)。在事务提交的时候，还会加入到全局提交事务链表中(<code>trx_sys-&gt;trx_serial_list</code>)。state字段记录了事务四种状态:<code>TRX_STATE_NOT_STARTED</code>, <code>TRX_STATE_ACTIVE</code>, <code>TRX_STATE_PREPARED</code>, <code>TRX_STATE_COMMITTED_IN_MEMORY</code>。 这里有两个字段值得区分一下，分别是id和no字段。id是在事务刚创建的时候分配的(只读事务永远为0，读写事务通过一个全局id产生器产生，非0)，目的就是为了区分不同的事务(只读事务通过指针地址来区分)，而no字段是在事务提交前，通过同一个全局id生产器产生的，主要目的是为了确定事务提交的顺序，保证加入到<code>history list</code>中的update undo有序，方便purge线程清理。 此外，trx_t结构体中还有自己的read_view用来表示当前事务的可见范围。分配的insert undo slot和update undo slot。如果是只读事务，read_only也会被标记为true。</p>
<p><strong>trx_sys_t:</strong> 这个结构体用来维护系统的事务信息，全局只有一个，在数据库启动的时候初始化。比较重要的字段有：max_trx_id，这个字段表示系统当前还未分配的最小事务id，如果有一个新的事务，直接把这个值作为新事务的id，然后这个字段递增即可。descriptors，这个是一个数组，里面存放着当前所有活跃的读写事务id，当需要开启一个readview的时候，就从这个字段里面拷贝一份，用来判断记录的对事务的可见性。rw_trx_list，这个主要是用来存放当前系统的所有读写事务，包括活跃的和已经提交的事务。按照事务id排序，此外，奔溃恢复后产生的事务和系统的事务也放在上面。mysql_trx_list，这里面存放所有用户创建的事务，系统的事务和奔溃恢复后的事务不会在这个链表上，但是这个链表上可能会有还没开始的用户事务。trx_serial_list，按照事务no(trx_t-&gt;no)排序的已经提交的事务。rseg_array，这个指向系统所有可以用的回滚段(<code>undo segments</code>)，当某个事务需要回滚段的时候，就从这里分配。rseg_history_len， 所有提交事务的update undo的长度，也就是上文提到的历史链表的长度，具体的update undo链表是存放在这个undo log中以文件指针的形式管理起来。view_list，这个是系统当前所有的readview, 所有开启的readview的事务都会把自己的readview放在这个上面，按照事务no排序。</p>
<p><strong>trx_purge_t:</strong> Purge线程使用的结构体，全局只有一个，在系统启动的时候初始化。view，是一个readview，Purge线程不会尝试删除所有大于view-&gt;low_limit_no的undolog。limit，所有小于这个值的undolog都可以被truncate掉，因为标记的日志已经被删除且不需要用他们构建之前的历史版本。此外，还有rseg，page_no, offset，hdr_page_no, hdr_offset这些字段，主要用来保存最后一个还未被purge的undolog。</p>
<p><strong>read_view_t:</strong> InnDB为了判断某条记录是否对当前事务可见，需要对此记录进行可见性判断，这个结构体就是用来辅助判断的。每个连接都的trx_t里面都有一个readview，在事务需要一致性的读时候(不同隔离级别不同)，会被初始化，在读结束的时候会释放(缓存)。low_limit_no，这个主要是给purge线程用，readview创建的时候，会把当前最小的提交事务id赋值给low_limit_no，这样Purge线程就可以把所有已经提交的事务的undo日志给删除。low_limit_id, 所有大于等于此值的记录都不应该被此readview看到，可以理解为high water mark。up_limit_id, 所有小于此值的记录都应该被此readview看到，可以理解为low water mark。descriptors, 这是一个数组，里面存了readview创建时候所有全局读写事务的id，除了事务自己做的变更外，此readview应该看不到descriptors中事务所做的变更。view_list，每个readview都会被加入到trx_sys中的全局readview链表中。</p>
<p><strong>trx_id_t:</strong> 每个读写事务都会通过全局id产生器产生一个id，只读事务的事务id为0，只有当其切换为读写事务时候再分配事务id。为了保证在任何情况下(包括数据库不断异常恢复)，事务id都不重复，InnoDB的全局id产生器每分配256(<code>TRX_SYS_TRX_ID_WRITE_MARGIN</code>)个事务id，就会把当前的max_trx_id持久化到ibdata的系统页上面。此外，每次数据库重启，都从系统页上读取，然后加上256(<code>TRX_SYS_TRX_ID_WRITE_MARGIN</code>)。</p>
<p><strong>trx_rseg_t:</strong> undo segment内存中的结构体。每个undo segment都对应一个。update_undo_list表示已经被分配出去的正在使用的update undo链表，insert_undo_list表示已经被分配出去的正在使用的insert undo链表。update_undo_cached和insert_undo_cached表示缓存起来的undo链表，主要为了快速使用。last_page_no, last_offset, last_trx_no, last_del_marks表示这个undo segment中最后没有被Purge的undolog。</p>
<h2 id="事务的启动"><a href="#事务的启动" class="headerlink" title="事务的启动"></a>事务的启动</h2><p>在InnoDB里面有两种事务，一种是读写事务，就是会对数据进行修改的事务，另外一种是只读事务，仅仅对数据进行读取。读写事务需要比只读事务多做以下几点工作：首先，需要分配回滚段，因为会修改数据，就需要找地方把老版本的数据给记录下来，其次，需要通过全局事务id产生器产生一个事务id，最后，把读写事务加入到全局读写事务链表(<code>trx_sys-&gt;rw_trx_list</code>)，把事务id加入到活跃读写事务数组中(<code>trx_sys-&gt;descriptors</code>)。因此，可以看出，读写事务确实需要比只读事务多做不少工作，在使用数据库的时候尽可能把事务申明为只读。</p>
<p><code>start transaction</code>语句启动事务。这种语句和<code>begin work</code>,<code>begin</code>等效。这些语句默认是以只读事务的方式启动。<code>start transaction read only</code>语句启动事务。这种语句就把<code>thd-&gt;tx_read_only</code>置为true，后续如果做了DML/DDL等修改数据的语句，会返回错误<code>ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION</code>。<code>start transaction read write</code>语句启动事务。这种语句会把<code>thd-&gt;tx_read_only</code>置为true，此外，允许super用户在read_only参数为true的情况下启动读写事务。<code>start transaction with consistent snapshot</code>语句启动事务。这种启动方式还会进入InnoDB层，并开启一个readview。注意，只有在RR隔离级别下，这种操作才有效，否则会报错。</p>
<p>上述的几种启动方式，都会先去检查前一个事务是否已经提交，如果没有则先提交，然后释放MDL锁。此外，除了<code>with consistent snapshot</code>的方式会进入InnoDB层，其他所有的方式都只是在Server层做个标记，没有进入InnoDB做标记，在InnoDB看来所有的事务在启动时候都是只读状态，只有接受到修改数据的SQL后(InnoDB接收到才行。因为在<code>start transaction read only</code>模式下，DML/DDL都被Serve层挡掉了)才调用<code>trx_set_rw_mode</code>函数把只读事务提升为读写事务。 新建一个连接后，在开始第一个事务前，在InnoDB层会调用函数<code>innobase_trx_allocate</code>分配和初始化trx_t对象。默认的隔离级别为REPEATABLE_READ，并且加入到<code>mysql_trx_list</code>中。注意这一步仅仅是初始化trx_t对象，但是真正开始事务的是函数<code>trx_start_low</code>，在<code>trx_start_low</code>中，如果当前的语句只是一条只读语句，则先以只读事务的形式开启事务，否则按照读写事务的形式，这就需要分配事务id，分配回滚段等。</p>
<h2 id="事务的提交"><a href="#事务的提交" class="headerlink" title="事务的提交"></a>事务的提交</h2><p>相比于事务的启动，事务的提交就复杂许多。这里只介绍事务在InnoDB层的提交过程，Server层涉及到与Binlog的XA事务暂时不介绍。入口函数为<code>innobase_commit</code>。</p>
<p>函数有一个参数<code>commit_trx</code>来控制是否真的提交，因为每条语句执行结束的时候都会调用这个函数，而不是每条语句执行结束的时候事务都提交。如果这个参数为true，或者配置了<code>autocommit=1</code>, 则进入提交的核心逻辑。否则释放因为auto_inc而造成的表锁，并且记录undo_no(回滚单条语句的时候用到，相关参数<code>innodb_rollback_on_timeout</code>)。 提交的核心逻辑：</p>
<ol>
<li>依据参数innobase_commit_concurrency来判断是否有过多的线程同时提交，如果太多则等待。</li>
<li>设置事务状态为committing，我们可以在<code>show processlist</code>看到(<code>trx_commit_for_mysql</code>)。</li>
<li>使用全局事务id产生器生成事务no，然后把事务trx_t加入到<code>trx_serial_list</code>。如果当前的undo segment没有设置最后一个未Purge的undo，则用此事务no更新(<code>trx_serialisation_number_get</code>)。</li>
<li>标记undo，如果这个事务只使用了一个undopage且使用量小于四分之三个page，则把这个page标记为(<code>TRX_UNDO_CACHED</code>)。如果不满足且是insert undo则标记为<code>TRX_UNDO_TO_FREE</code>，否则undo为update undo则标记为<code>TRX_UNDO_TO_PURGE</code>。标记为<code>TRX_UNDO_CACHED</code>的undo会被回收，方便下次重新利用(<code>trx_undo_set_state_at_finish</code>)。</li>
<li>把update undo放入所在undo segment的history list，并递增<code>trx_sys-&gt;rseg_history_len</code>(这个值是全局的)。同时更新page上的<code>TRX_UNDO_TRX_NO</code>, 如果删除了数据，则重置delete_mark(<code>trx_purge_add_update_undo_to_history</code>)。</li>
<li>把undate undo从update_undo_list中删除，如果被标记为<code>TRX_UNDO_CACHED</code>，则加入到update_undo_cached队列中(<code>trx_undo_update_cleanup</code>)。</li>
<li>在系统页中更新binlog名字和偏移量(<code>trx_write_serialisation_history</code>)。</li>
<li>mtr_commit，至此，在文件层次事务提交。这个时候即使crash，重启后依然能保证事务是被提交的。接下来要做的是内存数据状态的更新(<code>trx_commit_in_memory</code>)。</li>
<li>如果是只读事务，则只需要把readview从全局readview链表中移除，然后重置trx_t结构体里面的信息即可。如果是读写事务，情况则复杂点，首先需要是设置事务状态为<code>TRX_STATE_COMMITTED_IN_MEMORY</code>，其次，释放所有行锁，接着，trx_t从rw_trx_list中移除，readview从全局readview链表中移除，另外如果有insert undo则在这里移除(update undo在事务提交前就被移除，主要是为了保证添加到history list的顺序)，如果有update undo，则唤醒Purge线程进行垃圾清理，最后重置trx_t里的信息，便于下一个事务使用。</li>
</ol>
<h2 id="事务的回滚"><a href="#事务的回滚" class="headerlink" title="事务的回滚"></a>事务的回滚</h2><p>InnoDB的事务回滚是通过undolog来逆向操作来实现的，但是undolog是存在undopage中，undopage跟普通的数据页一样，遵循bufferpool的淘汰机制，如果一个事务中的很多undopage已经被淘汰出内存了，那么在回滚的时候需要重新把这些undopage从磁盘中捞上来，这会造成大量io，需要注意。此外，由于引入了savepoint的概念，事务不仅可以全部回滚，也可以回滚到某个指定点。</p>
<p>回滚的上层函数是<code>innobase_rollback_trx</code>，主要流程如下：</p>
<ol>
<li>如果是只读事务，则直接返回。</li>
<li>判断当前是回滚整个事务还是部分事务，如果是部分事务，则记录下需要保留多少个undolog，多余的都回滚掉，如果是全部回滚，则记录0(trx_rollback_step)。</li>
<li>从update undo和insert undo中找出最后一条undo，从这条undo开始回滚(<code>trx_roll_pop_top_rec_of_trx</code>)。</li>
<li>如果是update undo则调用<code>row_undo_mod</code>进行回滚，标记删除的记录清理标记，更新过的数据回滚到最老的版本。如果是insert undo则调用<code>row_undo_ins</code>进行回滚，插入操作，直接删除聚集索引和二级索引。</li>
<li>如果是在奔溃恢复阶段且需要回滚的undolog个数大于1000条，则输出进度。</li>
<li>如果所有undo都已经被回滚或者回滚到了指定的undo，则停止，并且调用函数<code>trx_roll_try_truncate</code>把undolog删除(由于不需要使用unod构建历史版本，所以不需要留给Purge线程)。 此外，需要注意的是，回滚的代码由于是嵌入在query graphy的框架中，因此有些入口函数不太好找。例如，确定回滚范围的是在函数<code>trx_rollback_step</code>中，真正回滚的操作是在函数<code>row_undo_step</code>中，两者都是在函数<code>que_thr_step</code>被调用。</li>
</ol>
<h2 id="多版本控制MVCC"><a href="#多版本控制MVCC" class="headerlink" title="多版本控制MVCC"></a>多版本控制MVCC</h2><p>数据库需要做好版本控制，防止不该被事务看到的数据(例如还没提交的事务修改的数据)被看到。在InnoDB中，主要是通过使用readview的技术来实现判断。查询出来的每一行记录，都会用readview来判断一下当前这行是否可以被当前事务看到，如果可以，则输出，否则就利用undolog来构建历史版本，再进行判断，知道记录构建到最老的版本或者可见性条件满足。</p>
<p>在trx_sys中，一直维护这一个全局的活跃的读写事务id(<code>trx_sys-&gt;descriptors</code>)，id按照从小到大排序，表示在某个时间点，数据库中所有的活跃(已经开始但还没提交)的读写(必须是读写事务，只读事务不包含在内)事务。当需要一个一致性读的时候(即创建新的readview时)，会把全局读写事务id拷贝一份到readview本地(read_view_t-&gt;descriptors)，当做当前事务的快照。read_view_t-&gt;up_limit_id是read_view_t-&gt;descriptors这数组中最小的值，read_view_t-&gt;low_limit_id是创建readview时的max_trx_id，即一定大于read_view_t-&gt;descriptors中的最大值。当查询出一条记录后(记录上有一个trx_id，表示这条记录最后被修改时的事务id)，可见性判断的逻辑如下(<code>lock_clust_rec_cons_read_sees</code>)：</p>
<p>如果记录上的trx_id小于read_view_t-&gt;up_limit_id，则说明这条记录的最后修改在readview创建之前，因此这条记录可以被看见。</p>
<p>如果记录上的trx_id大于等于read_view_t-&gt;low_limit_id，则说明这条记录的最后修改在readview创建之后，因此这条记录肯定不可以被看家。</p>
<p>如果记录上的trx_id在up_limit_id和low_limit_id之间，且trx_id在read_view_t-&gt;descriptors之中，则表示这条记录的最后修改是在readview创建之时，被另外一个活跃事务所修改，所以这条记录也不可以被看见。如果trx_id不在read_view_t-&gt;descriptors之中，则表示这条记录的最后修改在readview创建之前，所以可以看到。</p>
<p>基于上述判断，如果记录不可见，则尝试使用undo去构建老的版本(<code>row_vers_build_for_consistent_read</code>)，直到找到可以被看见的记录或者解析完所有的undo。</p>
<p>针对RR隔离级别，在第一次创建readview后，这个readview就会一直持续到事务结束，也就是说在事务执行过程中，数据的可见性不会变，所以在事务内部不会出现不一致的情况。针对RC隔离级别，事务中的每个查询语句都单独构建一个readview，所以如果两个查询之间有事务提交了，两个查询读出来的结果就不一样。从这里可以看出，在InnoDB中，RR隔离级别的效率是比RC隔离级别的高。此外，针对RU隔离级别，由于不会去检查可见性，所以在一条SQL中也会读到不一致的数据。针对串行化隔离级别，InnoDB是通过锁机制来实现的，而不是通过多版本控制的机制，所以性能很差。</p>
<p>由于readview的创建涉及到拷贝全局活跃读写事务id，所以需要加上trx_sys-&gt;mutex这把大锁，为了减少其对性能的影响，关于readview有很多优化。例如，如果前后两个查询之间，没有产生新的读写事务，那么前一个查询创建的readview是可以被后一个查询复用的。</p>
<h2 id="垃圾回收Purge线程"><a href="#垃圾回收Purge线程" class="headerlink" title="垃圾回收Purge线程"></a>垃圾回收Purge线程</h2><p>Purge线程主要做两件事，第一，数据页内标记的删除操作需要从物理上删除，为了提高删除效率和空间利用率，由后台Purge线程解析undolog定期批量清理。第二，当数据页上标记的删除记录已经被物理删除，同时undo所对应的记录已经能被所有事务看到，这个时候undo就没有存在的必要了，因此Purge线程还会把这些undo给truncate掉，释放更多的空间。</p>
<p>Purge线程有两种，一种是Purge Worker(<code>srv_worker_thread</code>), 另外一种是Purge Coordinator(<code>srv_purge_coordinator_thread</code>)，前者的主要工作就是从队列中取出Purge任务，然后清理已经被标记的记录。后者的工作除了清理删除记录外，还需要把Purge任务放入队列，唤醒Purge Worker线程，此外，它还要truncate undolog。</p>
<p>我们先来分析一下Purge Coordinator的流程。启动线程后，会进入一个大的循环，循环的终止条件是数据库关闭。在循环内部，首先是自适应的sleep，然后才会进入核心Purge逻辑。sleep时间与全局历史链表有关系，如果历史链表没有增长，且总数小于5000，则进入sleep，等待事务提交的时候被唤醒(<code>srv_purge_coordinator_suspend</code>)。退出循环后，也就是数据库进入关闭的流程，这个时候就需要依据参数innodb_fast_shutdown来确定在关闭前是否需要把所有记录给清除。接下来，介绍一下核心Purge逻辑。</p>
<ol>
<li>首先依据当前的系统负载来确定需要使用的Purge线程数(<code>srv_do_purge</code>)，即如果压力小，只用一个Purge Cooridinator线程就可以了。如果压力大，就多唤醒几个线程一起做清理记录的操作。如果全局历史链表在增加，或者全局历史链表已经超过<code>innodb_max_purge_lag</code>，则认为压力大，需要增加处理的线程数。如果数据库处于不活跃状态(<code>srv_check_activity</code>)，则减少处理的线程数。</li>
<li>如果历史链表很长，超过<code>innodb_max_purge_lag</code>，则需要重新计算delay时间(不超过<code>innodb_max_purge_lag_delay</code>)。如果计算结果大于0，则在后续的DML中需要先sleep，保证不会太快产生undo(<code>row_mysql_delay_if_needed</code>)。</li>
<li>从全局视图链表中，克隆最老的readview，所有在这个readview开启之前提交的事务所产生的undo都被认为是可以清理的。克隆之后，还需要把最老视图的创建者的id加入到<code>view-&gt;descriptors</code>中，因为这个事务修改产生的undo，暂时还不能删除(<code>read_view_purge_open</code>)。</li>
<li>从undo segment的最小堆中，找出最早提交事务的undolog(<code>trx_purge_get_rseg_with_min_trx_id</code>)，如果undolog标记过delete_mark(表示有记录删除操作)，则把先关undopage信息暂存在purge_sys_t中(<code>trx_purge_read_undo_rec</code>)。</li>
<li>依据purge_sys_t中的信息，读取出相应的undo，同时把相关信息加入到任务队列中。同时更新扫描过的指针，方便后续truncate undolog。</li>
<li>循环第4步和第5步，直到全局历史链表为空，或者接下到view-&gt;low_limit_no，即最老视图创建时已经提交的事务，或者已经解析的page数量超过<code>innodb_purge_batch_size</code>。</li>
<li>把所有的任务都放入队列后，就可以通知所有Purge Worker线程(如果有的话)去执行记录删除操作了。删除记录的核心逻辑在函数<code>row_purge_record_func</code>中。有两种情况，一种是数据记录被删除了，那么需要删除所有的聚集索引和二级索引(<code>row_purge_del_mark</code>)，另外一种是二级索引被更新了(总是先删除+插入新记录)，所以需要去执行清理操作。</li>
<li>在所有提交的任务都已经被执行完后，就可以调用函数<code>trx_purge_truncate</code>去删除update undo(insert undo在事务提交后就被清理了)。每个undo segment分别清理，从自己的histrory list中取出最早的一个undo，进行truncate(<code>trx_purge_truncate_rseg_history</code>)。truncate中，最终会调用<code>fseg_free_page</code>来清理磁盘上的空间。</li>
</ol>
<h2 id="事务的复活"><a href="#事务的复活" class="headerlink" title="事务的复活"></a>事务的复活</h2><p>在奔溃恢复后，也就是所有的前滚redo都应用完后，数据库需要做undo回滚，至于哪些事务需要提交，哪些事务需要回滚，这取决于undolog和binlog的状态。启动阶段，事务相关的代码逻辑主要在函数<code>trx_sys_init_at_db_start</code>中，简单分析一下。</p>
<ol>
<li>首先创建管理undo segment的最小堆，堆中的元素是每个undo segment提交最早的事务id和相应undo segment的指针，也就是说通过这个元素可以找到这个undo segment中最老的未被Purge的undo。通过这个最小堆，可以找到所有undo segment中最老未被Purge的undo，方便Purge线程操作。</li>
<li>创建全局的活跃读写事务id数组。主要是给readview使用。</li>
<li>初始化所有的undo segment。主要是从磁盘读取undolog的内容，构建内存中的undo slot和undo segment，同时也构建每个undo segment中的history list，因为如果是fast shutdown，被标记为删除的记录可能还没来得及被彻底清理。此外，也构建每个undo segment中的inset_undo_list和update_undo_list，理论上来说，如果数据库关闭的时候所有事务都正常提交了，这两个链表都为空，如果数据库非正常关闭，则链表非空(<code>trx_undo_mem_create_at_db_start</code>, <code>trx_rseg_mem_create</code>)。</li>
<li>从系统页里面读取max_trx_id，然后加上TRX_SYS_TRX_ID_WRITE_MARGIN来保证trx_id不会重复，即使在很极端的情况下。</li>
<li>遍历所有的undo segment，针对每个undo segment，分别遍历inset_undo_list和update_undo_list，依据undo的状态来复活事务。</li>
<li>insert/update undo的处理逻辑：如果undolog上的状态是<code>TRX_UNDO_ACTIVE</code>，则事务也被设置为<code>TRX_STATE_ACTIVE</code>，如果undolog上的状态是<code>TRX_UNDO_PREPARED</code>，则事务也被设置为<code>TRX_UNDO_PREPARED</code>(如果force_recovery不为0，则设置为<code>TRX_STATE_ACTIVE</code>)。如果undolog状态是<code>TRX_UNDO_CACHED</code>,<code>TRX_UNDO_TO_FREE</code>,<code>TRX_UNDO_TO_PURGE</code>，那么都任务事务已经提交了(<code>trx_resurrect_insert</code>和<code>trx_resurrect_update</code>)。</li>
<li>除了从undolog中复活出事务的状态信息，还需要复活出当前的锁信息(<code>trx_resurrect_table_locks</code>)，此外还需要把事务trx_t加入到rw_trx_list中。</li>
<li>所有事务信息复活后，InnoDB会做个统计，告诉你有多少undo需要做，因此可以在错误日志中看到类似的话: InnoDB: 120 transaction(s) which must be rolled back or cleaned up. InnoDB: in total 20M row operations to undo。</li>
<li>如果事务中操作了数据字典，比如创建删除表和索引，则这个事务会在奔溃恢复结束后直接回滚，这个是个同步操作，会延长奔溃恢复的时间(<code>recv_recovery_from_checkpoint_finish</code>)。如果事务中没有操作数据字典，则后台会开启一个线程，异步回滚事务，所以我们常常发现，在数据库启动后，错误日志里面依然会有很多事务正在回滚的信息。</li>
</ol>
<h2 id="事务运维相关命令和参数"><a href="#事务运维相关命令和参数" class="headerlink" title="事务运维相关命令和参数"></a>事务运维相关命令和参数</h2><ol>
<li><p>首先介绍一下information_schema中的三张表: innodb_trx, innodb_locks和innodb_lock_waits。由于这些表几乎需要查询所有事务子系统的核心数据结构，为了减少查询对系统性能的影响，InnoDB预留了一块内存，内存里面存了相关数据的副本，如果两次查询的时间小于0.1秒(<code>CACHE_MIN_IDLE_TIME_US</code>)，则访问的都是同一个副本。如果超过0.1秒，则这块内存会做一次更新，每次更新会把三张表用到的所有数据统一更新一遍，因为这三张表经常需要做表连接操作，所以一起更新能保证数据的一致性。这里简单介绍一下innodb_trx表中的字段，另外两张表涉及到事物锁的相关信息，由于篇幅限制，后续有机会在介绍。</p>
<p>trx_id: 就是trx_t中的事务id，如果是只读事务，这个id跟trx_t的指针地址有关，所以可能是一个很大的数字(<code>trx_get_id_for_print</code>)。</p>
<p>trx_weight: 这个是事务的权重，计算方法就是undolog数量加上事务已经加上锁的数量。在事务回滚的时候，优先选择回滚权重小的事务，有非事务引擎参与的事务被认为权重是最大的。</p>
<p>trx_rows_modified：这个就是当前事务已经产生的undolog数量，每更新一条记录一次，就会产生一条undo。</p>
<p>trx_concurrency_tickets: 每次这个事务需要进入InnoDB层时，这个值都会减一，如果减到0，则事务需要等待(压力大的情况下)。</p>
<p>trx_is_read_only: 如果是以<code>start transaction read only</code>启动事务的，那么这个字段是1，否则为0。</p>
<p>trx_autocommit_non_locking: 如果一个事务是一个普通的select语句(后面没有跟for update, share lock等)，且当时的autocommit为1，则这个字段为1，否则为0。</p>
<p>trx_state: 表示事务当前的状态，只能有<code>RUNNING</code>, <code>LOCK WAIT</code>, <code>ROLLING BACK</code>, <code>COMMITTING</code>这几种状态, 是比较粗粒度的状态。</p>
<p>trx_operation_state: 表示事务当前的详细状态，相比于trx_state更加详细，例如有<code>rollback to a savepoint</code>, <code>getting list of referencing foreign keys</code>, <code>rollback of internal trx on stats tables</code>, <code>dropping indexes</code>等。</p>
</li>
<li><p>与事务相关的undo参数</p>
<p>innodb_undo_directory: undo文件的目录，建议放在独立的一块盘上，尤其在经常有大事务的情况下。</p>
<p>innodb_undo_logs: 这个是定义了undo segment的个数。在给读写事务分配undo segment的时候，拿这个值去做轮训分配。</p>
<p>Innodb_available_undo_logs: 这个是一个status变量，在启动的时候就确定了，表示的是系统上分配的undo segment。举个例子说明其与innodb_undo_logs的关系：假设系统初始化的时候innodb_undo_logs为128，则在文件上一定有128个undo segment，Innodb_available_undo_logs也为128，但是启动起来后，innodb_undo_logs动态被调整为100，则后续的读写事务只会使用到前100个回滚段，最后的20多个不会使用。</p>
<p>innodb_undo_tablespaces: 存放undo segment的物理文件个数，文件名为undoN，undo segment会比较均匀的分布在undo tablespace中。</p>
</li>
<li><p>与Purge相关的参数</p>
<p>innodb_purge_threads: Purge Worker和Purge Coordinator总共的个数。在实际的实现中，使用多少个线程去做Purge是InnoDB根据实时负载进行动态调节的。</p>
<p>innodb_purge_batch_size: 一次性处理的undolog的数量，处理完这个数量后，Purge线程会计算是否需要sleep。</p>
<p>innodb_max_purge_lag: 如果全局历史链表超过这个值，就会增加Purge Worker线程的数量，也会使用sleep的方式delay用户的DML。</p>
<p>innodb_max_purge_lag_delay: 这个表示通过sleep方式delay用户DML最大的时间。</p>
</li>
<li><p>与回滚相关的参数</p>
<p>innodb_lock_wait_timeout: 等待行锁的最大时间，如果超时，则会滚当前语句或者整个事务。发生回滚后返回类似错误：Lock wait timeout exceeded; try restarting transaction。</p>
<p>innodb_rollback_on_timeout: 如果这个参数为true，则当发生因为等待行锁而产生的超时时，回滚掉整个事务，否则只回滚当前的语句。这个就是隐式回滚机制。主要是为了兼容之前的版本。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://justdoitlee.github.io/2021/06/07/Spring-Security-身份认证流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李智">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李智‘Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/07/Spring-Security-身份认证流程/" itemprop="url">Spring Security 身份认证流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-07T16:57:02+08:00">
                2021-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java二三事/" itemprop="url" rel="index">
                    <span itemprop="name">Java二三事</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  3,510
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  15分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>Spring Security 就像一个行政服务中心，如果我们去里面办事，可以办啥事呢？可以小到咨询简单问题、查询社保信息，也可以户籍登记、补办身份证，同样也可以大到企业事项、各种复杂的资质办理。但是我们并不需要跑一次行政服务中心，就挨个把业务全部办理一遍，现实中没有这样的人吧。</p>
</blockquote>
<p>总结一下，啥意思呢，就是说选择你需要的服务（功能），无视那些不需要的，等有需要的时候再了解不迟。这也是给众多工程师们的一个建议，特别是体系异常庞大的Java系，别动不动就精通，撸遍源码之类的，真没啥意义，我大脑的存储比较小，人生苦短，没必要。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/06/07/Spring-Security-身份认证流程/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://justdoitlee.github.io/2021/04/29/Github自定义Overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李智">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李智‘Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/29/Github自定义Overview/" itemprop="url">Github自定义Overview</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-29T09:45:15+08:00">
                2021-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂七杂八/" itemprop="url" rel="index">
                    <span itemprop="name">杂七杂八</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  706
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>最近逛别人的Github发现别人的Overview很炫酷，然后发现Github允许在个人主页 Your profile 中的 Overview 页面定义自己的内容，来突出用户的个人风格。</p>
<p>在用户名同名库的READ.ME中所填入的所有信息都会被及时渲染到 GitHub 首页，支持常规的 Markdown 语法。效果如下：</p>
<p><img src="/img/githubOverview.png"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/04/29/Github自定义Overview/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://justdoitlee.github.io/2021/04/22/Iterm2使用agnosterzak打造个性终端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李智">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李智‘Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/22/Iterm2使用agnosterzak打造个性终端/" itemprop="url">Iterm2使用agnosterzak打造个性终端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-22T08:42:00+08:00">
                2021-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/杂七杂八/" itemprop="url" rel="index">
                    <span itemprop="name">杂七杂八</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  613
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>关机之后打开电脑，突然电脑配置全部恢复默认，Iterm2样式跟着失效了，然后重新打造一下，方便下次快速恢复终端样式。</p>
<p>效果如下：</p>
<p><img src="/img/iterm2css.png"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2021/04/22/Iterm2使用agnosterzak打造个性终端/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://justdoitlee.github.io/2020/12/10/贪心算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李智">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李智‘Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/10/贪心算法/" itemprop="url">贪心算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-12-10T12:54:00+08:00">
                2020-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,091
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="https://leetcode.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a></p>
<p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p>
<p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p>
<p>什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。</p>
<p>比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。</p>
<p>然而，大部分问题明显不具有贪心选择性质。比如打斗地主，对手出对三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况甚至可能会出王炸，这种情况就不能用贪心算法，而得使用动态规划解决。</p>
<h4 id="一、问题概述"><a href="#一、问题概述" class="headerlink" title="一、问题概述"></a>一、问题概述</h4><p>经典的贪心算法问题 Interval Scheduling（区间调度问题）。</p>
<p>给你很多形如 <code>[start, end]</code> 的闭区间，<strong>算出这些区间中最多有几个互不相交的区间</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intervalSchedule</span><span class="params">(<span class="keyword">int</span>[][] intvs)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>举个例子，<code>intvs = [[1,3], [2,4], [3,6]]</code>，这些区间最多有 2 个区间互不相交，即 <code>[[1,3], [3,6]]</code>，你的算法应该返回 2。注意边界相同并不算相交。</p>
<p>这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 <code>[start, end]</code> 表示开始和结束的时间，请问你今天<strong>最多能参加几个活动呢？</strong>显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/12/10/贪心算法/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://justdoitlee.github.io/2020/10/29/四键键盘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李智">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李智‘Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/29/四键键盘/" itemprop="url">四键键盘</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-29T13:20:42+08:00">
                2020-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,358
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <script src="/assets/js/APlayer.min.js"> </script><p><a href="https://leetcode.com/problems/4-keys-keyboard" target="_blank" rel="noopener">651.四键键盘</a></p>
<h4 id="第一种思路"><a href="#第一种思路" class="headerlink" title="第一种思路"></a>第一种思路</h4><p>这种思路会很容易理解，但是效率并不高，直接走流程：<strong>对于动态规划问题，首先要明白有哪些「状态」，有哪些「选择」</strong>。</p>
<p>具体到这个问题，对于每次敲击按键，有哪些「选择」是很明显的：4 种，就是题目中提到的四个按键，分别是 <code>A</code>、<code>C-A</code>、<code>C-C</code>、<code>C-V</code>（<code>Ctrl</code> 简写为 <code>C</code>）。</p>
<p>接下来，思考一下对于这个问题有哪些「状态」？<strong>或者换句话说，需要知道什么信息，才能将原问题分解为规模更小的子问题</strong>？</p>
<p>第一个状态是剩余的按键次数，用 <code>n</code> 表示；</p>
<p>第二个状态是当前屏幕上字符 A 的数量，用 <code>a_num</code> 表示；</p>
<p>第三个状态是剪切板中字符 A 的数量，用 <code>copy</code> 表示。</p>
<p>如此定义「状态」，就可以知道 base case：当剩余次数 <code>n</code> 为 0 时，<code>a_num</code> 就是我们想要的答案。</p>
<p>结合刚才说的 4 种「选择」，可以把这几种选择通过状态转移表示出来：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">dp</span><span class="params">(n - <span class="number">1</span>, a_num + <span class="number">1</span>, copy)</span></span>,    <span class="comment">// A</span></span><br><span class="line">解释：按下 A 键，屏幕上加一个字符</span><br><span class="line">同时消耗 <span class="number">1</span> 个操作数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dp</span><span class="params">(n - <span class="number">1</span>, a_num + copy, copy)</span></span>, <span class="comment">// C-V</span></span><br><span class="line">解释：按下 C-V 粘贴，剪切板中的字符加入屏幕</span><br><span class="line">同时消耗 <span class="number">1</span> 个操作数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">dp</span><span class="params">(n - <span class="number">2</span>, a_num, a_num)</span></span>        <span class="comment">// C-A C-C</span></span><br><span class="line">解释：全选和复制必然是联合使用的，</span><br><span class="line">剪切板中 A 的数量变为屏幕上 A 的数量</span><br><span class="line">同时消耗 <span class="number">2</span> 个操作数</span><br></pre></td></tr></table></figure>
<p>这样可以看到问题的规模 <code>n</code> 在不断减小，肯定可以到达 <code>n = 0</code> 的 base case，所以这个思路是正确的：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxA(<span class="keyword">int</span> N) &#123;</span><br><span class="line">       <span class="comment">// 可以按 N 次按键，屏幕和剪切板里都还没有 A</span></span><br><span class="line">       <span class="keyword">return</span> dp(N, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对于 (n, a_num, copy) 这个状态，</span></span><br><span class="line">   <span class="comment">// 屏幕上能最终最多能有 dp(n, a_num, copy) 个 A</span></span><br><span class="line">   <span class="keyword">int</span> dp(<span class="keyword">int</span> n, <span class="keyword">int</span> a_num, <span class="keyword">int</span> <span class="keyword">copy</span>) &#123;</span><br><span class="line">       <span class="comment">// base case</span></span><br><span class="line">       <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> a_num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 几种选择全试一遍，选择最大的结果</span></span><br><span class="line">       <span class="keyword">return</span> Math.max(</span><br><span class="line">               Math.max(dp(n - <span class="number">1</span>, a_num + <span class="number">1</span>, <span class="keyword">copy</span>),    <span class="comment">// A</span></span><br><span class="line">                       dp(n - <span class="number">1</span>, a_num + <span class="keyword">copy</span>, <span class="keyword">copy</span>)), <span class="comment">// C-V</span></span><br><span class="line">               dp(n - <span class="number">2</span>, a_num, a_num)        <span class="comment">// C-A C-C</span></span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面就继续走流程，用备忘录消除一下重叠子问题：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> maxA(<span class="built_in">int</span> N) &#123;</span><br><span class="line">       <span class="comment">// 可以按 N 次按键，屏幕和剪切板里都还没有 A</span></span><br><span class="line">       <span class="keyword">return</span> dp(N, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 对于 (n, a_num, copy) 这个状态，</span></span><br><span class="line">   <span class="comment">// 屏幕上能最终最多能有 dp(n, a_num, copy) 个 A</span></span><br><span class="line">   <span class="built_in">int</span> dp(<span class="built_in">int</span> n, <span class="built_in">int</span> a_num, <span class="built_in">int</span> <span class="built_in">copy</span>) &#123;</span><br><span class="line">       <span class="comment">// base case</span></span><br><span class="line">       <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> a_num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 避免计算重叠子问题</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(n + <span class="string">"*"</span> + a_num + <span class="built_in">copy</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(n + <span class="string">"*"</span> + a_num + <span class="built_in">copy</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 几种选择全试一遍，选择最大的结果</span></span><br><span class="line">       <span class="built_in">map</span>.put(n + <span class="string">"*"</span> + a_num + <span class="built_in">copy</span>, Math.<span class="built_in">max</span>(</span><br><span class="line">               Math.<span class="built_in">max</span>(dp(n - <span class="number">1</span>, a_num + <span class="number">1</span>, <span class="built_in">copy</span>),    <span class="comment">// A</span></span><br><span class="line">                       dp(n - <span class="number">1</span>, a_num + <span class="built_in">copy</span>, <span class="built_in">copy</span>)), <span class="comment">// C-V</span></span><br><span class="line">               dp(n - <span class="number">2</span>, a_num, a_num)        <span class="comment">// C-A C-C</span></span><br><span class="line">       ));</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">map</span>.<span class="built_in">get</span>(n + <span class="string">"*"</span> + a_num + <span class="built_in">copy</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二种思路"><a href="#第二种思路" class="headerlink" title="第二种思路"></a>第二种思路</h4><p>这种思路稍微有点复杂，但是效率高。继续走流程，「选择」还是那 4 个，但是这次只定义一个「状态」，也就是剩余的敲击次数 <code>n</code>。</p>
<p>这个算法基于这样一个事实，<strong>最优按键序列一定只有两种情况</strong>：</p>
<p>要么一直按 <code>A</code>：A,A,…A（当 N 比较小时）。</p>
<p>要么是这么一个形式：A,A,…C-A,C-C,C-V,C-V,…C-V（当 N 比较大时）。</p>
<p>因为字符数量少（N 比较小）时，<code>C-A C-C C-V</code> 这一套操作的代价相对比较高，可能不如一个个按 <code>A</code>；而当 N 比较大时，后期 <code>C-V</code> 的收获肯定很大。这种情况下整个操作序列大致是：<strong>开头连按几个</strong> <strong><code>A</code>，然后</strong> <strong><code>C-A C-C</code></strong> <strong>组合再接若干</strong> <strong><code>C-V</code>，然后再</strong> <strong><code>C-A C-C</code></strong> <strong>接着若干</strong> <strong><code>C-V</code>，循环下去</strong>。</p>
<p>换句话说，最后一次按键要么是 <code>A</code> 要么是 <code>C-V</code>。明确了这一点，可以通过这两种情况来设计算法：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 定义：dp[i] 表示 i 次操作后最多能显示多少个 A</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    dp[i] = Math.<span class="built_in">max</span>(</span><br><span class="line">            这次按 A 键，</span><br><span class="line">            这次按 C-V</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>对于「按 <code>A</code> 键」这种情况，就是状态 <code>i - 1</code> 的屏幕上新增了一个 A 而已，很容易得到结果：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按 A 键，就比上次多一个 A 而已</span></span><br><span class="line">dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>但是，如果要按 <code>C-V</code>，还要考虑之前是在哪里 <code>C-A C-C</code> 的。</p>
<p><strong>刚才说了，最优的操作序列一定是</strong> <strong><code>C-A C-C</code></strong> <strong>接着若干</strong> <strong><code>C-V</code>，所以用一个变量</strong> <strong><code>j</code></strong> <strong>作为若干</strong> <strong><code>C-V</code></strong> <strong>的起点</strong>。那么 <code>j</code> 之前的 2 个操作就应该是 <code>C-A C-C</code> 了：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxA(<span class="keyword">int</span> N) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="comment">// 按 A 键</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 全选 &amp; 复制 dp[j-2]，连续粘贴 i - j 次</span></span><br><span class="line">            <span class="comment">// 屏幕上共 dp[j - 2] * (i - j + 1) 个 A</span></span><br><span class="line">            dp[i] = Math.max(dp[i], dp[j - <span class="number">2</span>] * (i - j + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// N 次按键之后最多有几个 A？</span></span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>j</code> 变量减 2 是给 <code>C-A C-C</code> 留下操作数</p>
<p><img src="/img/4key.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://justdoitlee.github.io/2020/10/11/正则表达/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李智">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李智‘Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/11/正则表达/" itemprop="url">正则表达</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-11T13:23:52+08:00">
                2020-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,863
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10.正则表达式匹配</a></p>
<p>正则表达式是一个非常强力的工具，这两个通配符是最常用的，其中点号「.」可以匹配任意一个字符，星号「*」可以让之前的那个字符重复任意次数（包括 0 次）。</p>
<p>比如说模式串 <code>&quot;.a*b&quot;</code> 就可以匹配文本 <code>&quot;zaaab&quot;</code>，也可以匹配 <code>&quot;cb&quot;</code>；模式串 <code>&quot;a..b&quot;</code> 可以匹配文本 <code>&quot;amnb&quot;</code>；而模式串 <code>&quot;.*&quot;</code> 就比较牛逼了，它可以匹配任何文本。</p>
<p>题目输入两个字符串 <code>s</code> 和 <code>p</code>，<code>s</code> 代表文本，<code>p</code> 代表模式串，判断模式串 <code>p</code> 是否可以匹配文本 <code>s</code>。可以假设模式串只包含小写字母和上述两种通配符且一定合法，不会出现 <code>*a</code> 或者 <code>b**</code> 这种不合法的模式串。</p>
<p>首先<code>s</code>和<code>p</code>相互匹配的过程大致是，两个指针<code>i, j</code>分别在<code>s</code>和<code>p</code>上移动，如果最后两个指针都能移动到字符串的末尾，那么久匹配成功，反之则匹配失败。</p>
<p><strong>正则表达算法问题只需要把住一个基本点：看两个字符是否匹配，一切逻辑围绕匹配/不匹配两种情况展开即可。</strong></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/10/11/正则表达/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://justdoitlee.github.io/2020/10/02/博弈问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李智">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李智‘Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/02/博弈问题/" itemprop="url">博弈问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-10-02T12:56:32+08:00">
                2020-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1,855
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  8分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="https://leetcode.com/problems/stone-game" target="_blank" rel="noopener">877.石子游戏</a></p>
<p>你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。</p>
<p>石头的堆数可以是任意正整数，石头的总数也可以是任意正整数，这样就能打破先手必胜的局面了。比如有三堆石头 <code>piles = [1, 100, 3]</code>，先手不管拿 1 还是 3，能够决定胜负的 100 都会被后手拿走，后手会获胜。</p>
<p><strong>假设两人都很聪明</strong>，请你设计一个算法，返回先手和后手的最后得分（石头总数）之差。比如上面那个例子，先手能获得 4 分，后手会获得 100 分，你的算法应该返回 -96。</p>
<p>这样推广之后，这个问题算是一道 Hard 的动态规划问题了。<strong>博弈问题的难点在于，两个人要轮流进行选择，而且都贼精明，应该如何编程表示这个过程呢？</strong></p>
<p>还是强调多次的套路，首先明确 dp 数组的含义，然后和股票买卖系列问题类似，只要找到「状态」和「选择」，一切就水到渠成了。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/10/02/博弈问题/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://justdoitlee.github.io/2020/09/29/子序列问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李智">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李智‘Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/29/子序列问题/" itemprop="url">子序列问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-29T15:16:51+08:00">
                2020-09-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  737
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  3分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>子序列问题是常见的算法问题，而且并不好解决。</p>
<p>首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举都不容易，更别说求解相关的算法问题了。</p>
<p>而且，子序列问题很可能涉及到两个字符串，比如让你求两个字符串的<strong>最长公共子序列</strong>，如果没有一定的处理经验，真的不容易想出来。针对子序列问题的套路，<strong>其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。</strong></p>
<p>一般来说，这类问题都是让你求一个<strong>最长</strong>子序列，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，<strong>考察的是动态规划技巧，时间复杂度一般都是 O(n^2)</strong>。</p>
<p>原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着呢？</p>
<p>既然要用动态规划，那就要定义 dp 数组，找状态转移关系。我们说的两种思路模板，就是 dp 数组的定义思路。不同的问题可能需要不同的 dp 数组定义来解决。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/09/29/子序列问题/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://justdoitlee.github.io/2020/09/27/最长公共子序列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李智">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李智‘Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/27/最长公共子序列/" itemprop="url">最长公共子序列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-27T13:33:08+08:00">
                2020-09-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  851
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="https://leetcode.com/problems/longest-common-subsequence" target="_blank" rel="noopener">1143.最长公共子序列</a></p>
<p><strong>第一步，一定要明确</strong> <strong><code>dp</code></strong> <strong>数组的含义</strong>。对于两个字符串的动态规划问题，套路是通用的。</p>
<p>比如说对于字符串 <code>s1</code> 和 <code>s2</code>，一般来说都要构造一个这样的 DP table：</p>
<p><img src="/img/zuichanggonggongzixulie.png"></p>
<p>为了方便理解此表，暂时认为索引是从 1 开始的，待会的代码中只要稍作调整即可。其中，<code>dp[i][j]</code> 的含义是：对于 <code>s1[1..i]</code> 和 <code>s2[1..j]</code>，它们的 LCS 长度是 <code>dp[i][j]</code>。</p>
<p>比如上图的例子，<code>d[2][4]</code> 的含义就是：对于 <code>&quot;ac&quot;</code> 和 <code>&quot;babc&quot;</code>，它们的 LCS 长度是 2。最终想得到的答案应该是 <code>dp[3][6]</code>。</p>
<p><strong>第二步，定义 base case。</strong></p>
<p>让索引为 0 的行和列表示空串，<code>dp[0][..]</code> 和 <code>dp[..][0]</code> 都应该初始化为 0，这就是 base case。</p>
<p>比如说，按照刚才 dp 数组的定义，<code>dp[0][3]=0</code> 的含义是：对于字符串 <code>&quot;&quot;</code> 和 <code>&quot;bab&quot;</code>，其 LCS 的长度为 0。因为有一个字符串是空串，它们的最长公共子序列的长度显然应该是 0。</p>
<p><strong>第三步，找状态转移方程。</strong></p>
<p>这是动态规划最难的一步</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/09/27/最长公共子序列/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="李智">
            
              <p class="site-author-name" itemprop="name">李智</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/JustDoItLee" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:mailto:justdoitleeee@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" style="margin-left:40%">&copy; 2015 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李智</span>

  
</div>
<div style="margin-left:30%">

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>

</div>
<div class="theme-info" style="margin-left:20%">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共150.3k字</span>&nbsp&nbsp
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
本站总访问量 <span id="busuanzi_value_site_pv"></span> &nbsp&nbsp
您是第<span id="busuanzi_value_site_uv"></span>个来到的小伙伴
</div>


  <div class="platelet" style="display: block; margin-left:-22%;">
    <div class="platelet-tips"></div>
    <div style="width: 250px;overflow: hidden;">
      <canvas id="live2d" width="650" height="600" class="live2d" style="width: 325px;height: 300px;"></canvas>
    </div>
    <div class="platelet-tool">
      <i class="fa fa-eye eye"></i>
      <i class="fa fa-music music"></i>
      <i class="fa fa-comment comment"></i>
      <i class="fa fa-camera camera"></i>
    </div>
  </div>
  <div id="main" class="container"></div>

<script src="https://code.jquery.com/jquery-3.2.1.js"></script>
<script src="/platelet/assets/js/live2d.js"></script>
<script src="/platelet/assets/js/platelet.js"></script>
<script src="/platelet/assets/js/renderer.js"></script>
<script type="text/javascript">
  loadlive2d("live2d", "/platelet/assets/kesshouban_v2/model.json");
</script>





        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>
  

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"platelet"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
